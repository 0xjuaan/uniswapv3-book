[{"id":0,"href":"/uniswapv3-book/docs/introduction/amm/","title":"Introduction to markets","section":"Milestone 0","content":"Introduction to markets #  How centralized exchanges work #  In this book, we\u0026rsquo;ll build a decentralized exchange (DEX) that will run on Ethereum. There\u0026rsquo;re multiple approaches to how an exchange can be designed. All centralized exchanges have an order book at their core. An order book is just a journal that stores all sell or buy orders that traders what to make. Each order in this book contains a price the order must be executed at and the amount that must be bought or sold.\n[TODO: illustration]\nFor trading to happen, there must exist liquidity, which is simply the availability of assets on a market. If you want to buy a wardrobe but no one is selling one, there\u0026rsquo;s no liquidity. If you want to sell a wardrobe but no one wants to buy it, there\u0026rsquo;s liquidity but no buyers. If there\u0026rsquo;s no liquidity, there\u0026rsquo;s nothing to buy or sell.\nOn centralized exchanges, the order book is where liquidity is accumulated. If someone places a sell order, they provide liquidity to the market. If someone places a buy order, they expected the market to have liquidity, otherwise, no trade is possible.\nSince liquidity is not always available, but markets are still interested in trades, entities called market makers were established. A market maker is a firm or an individual who provides liquidity to markets, that is someone who has a lot of money and who buys different assets to sell them on exchanges. For this job, market makers are paid by exchanges.\nHow decentralized exchanges work #  Don\u0026rsquo;t be surprised, decentralized exchanges also need liquidity. And they also need someone who provides it to traders of a wide variety of assets. However, this process cannot be handled in a centralized way. A decentralized solution must exist. There are multiple decentralized solutions and the same solutions are implemented in different ways, but our focus will be on how Uniswap solves this problem.\nAutomated Market Makers #  The evolution of on-chain markets brought us to the idea of Automated Market Makers (AMM). As the name implies, this algorithm works exactly like market makers but in an automated way. Moreover, it\u0026rsquo;s decentralized and permissionless (anyone can use them).\nWhat is an AMM? #  The core idea is pooling-different and not connected groups of people are incentivized to put their assets (tokens) into pools, which are smart contracts. Anyone else can use these pool contracts to trade, thanks to liquidity provided by the first group.\n[TODO: illustration]\nWhat makes this approach different from centralized exchanges is that the smart contracts are fully automated and not managed by anyone. There are no managers, admins, privileged users, etc. There are only liquidity providers and traders, and all the algorithms are programmed and immutable.\n"},{"id":1,"href":"/uniswapv3-book/docs/introduction/cfmm/","title":"Constant Function Market Makers","section":"Milestone 0","content":"Constant Function Market Makers #   function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]  As I mentioned in the previous section, there are different approaches to building AMM. We\u0026rsquo;ll be focusing on and building one specific type of AMM–Constant Function Market Maker. Don\u0026rsquo;t be scared by the long name! At its core is a very simple mathematical formula:\n$$x * y = k$$\nThat\u0026rsquo;s it, that\u0026rsquo;s the formula.\n$x$ and $y$ are pool contract reserves–the amounts of tokens it currently holds. k is just their product, actual value doesn\u0026rsquo;t matter.\n Why there are only two reserves, x and y?\nEach Uniswap pool can hold only two tokens. We use x and y to refer to reserves of one pool, where x is the reserve of the first token and y is the reserve of the other token, and the order doesn\u0026rsquo;t matter.\n The constant function formula says: after each trade, k must remain unchanged. When traders make trades, they put some amount of one token into a pool (token they want to sell) and remove some amount of the other token from the pool (token they want to buy). This changes the reserves of the pool, and the constant function formula says that the product of reserves must not change. As we will see many times in this book, this simple requirement is the core algorithm of the exchange we\u0026rsquo;re building.\nThe trade function #  Now that we know what pools are, let\u0026rsquo;s write the formula of how trading happens in a pool:\n$$(x + r\\Delta x)(y - \\Delta y) = k$$\n[TODO: illustration]\n There\u0026rsquo;s a pool with some amount of token A ($x$) and some amount of token B ($y$). When we buy token B for token A, we give some amount of token A to the pool ($\\Delta x$). The pool gives us some amount of token B in exchange ($\\Delta y$). The pool also takes a small fee from the amount of token A we gave ($r$). The reserve of token A changes ($x + r \\Delta x$), and the reserve of token B changes as well ($y - \\Delta y$). The product of updated reserves must still equal $k$.  The order of tokens in the formula doesn\u0026rsquo;t matter: Uniswap pools allow swapping tokens in both directions.\nPricing #  How do we calculate the prices of tokens in a pool?\nSince Uniswap pools are separate smart contracts, tokens in a pool are priced in terms of each other. For example: in USDC-ETH pool, ETH is priced in terms of USDC and USDC is priced in terms of ETH. If 1 ETH costs 1000 USDC, then 1 USDC costs 0.001 ETH. The same is true for any other pool, whether it\u0026rsquo;s a stablecoin pair or not. And actual token prices are simply relations of reserves:\n$$P_x = \\frac{y}{x}, \\quad P_y=\\frac{x}{y}$$\nWhere $P_x$ and $P_y$ are prices of tokens in terms of the other token. Such prices are called spot prices and they only reflect current market prices. However, the actual price of a trade is calculated differently. Let\u0026rsquo;s return to the trade function and try to come up with some conclusions about how an actual trade price is calculated:\n$$(x + r\\Delta x)(y - \\Delta y) = k$$\nSuppose we want to find the price of token A (its reserve is $x$ in the formula) when swapping it for token B (its reserve is $y$ in the formula). We\u0026rsquo;re trading in some amount of token A ($\\Delta x$) in exchange for some amount of token B ($\\Delta y$). This means that the actual price of the trade will be the relation of the amounts. Not the reserves, but the amounts we give and get.\nLet\u0026rsquo;s rewrite the trade function to find out trade amounts:\n First, we write $k$ as the product of reserves before a trade: $$(x + r\\Delta x)(y - \\Delta y) = xy$$ On the left side, is the product of updated reserves (after a swap). On the right side, is the product of current reserves (before a swap). Then, we can find $\\Delta y$ using simple algebraic operations: $$\\Delta y = \\frac{yr\\Delta x}{x + r\\Delta x}$$ [TODO: explain] Similarly, we can express $\\Delta x$ in terms of $\\Delta y$: $$\\Delta x = \\frac{x \\Delta y}{r(y - \\Delta y)}$$ [TODO: explain]  Having these functions, we don\u0026rsquo;t need to calculate prices because we can calculate amounts instead! If we know how many tokens we want to sell, we can calculate the amount we\u0026rsquo;ll get without calculating the price. And vice versa: if we want to buy a specific amount of tokens, we can calculate the amount we need to sell right away, without calculating the price.\nLast thing to notice here is that the trade function can be rewritten using geometric means. So this formula: $$(x + r\\Delta x)(y - \\Delta y) = xy$$\nBecomes this: $$\\sqrt[n]{\\prod_{i=1}^n X_i\u0026rsquo;} = \\sqrt[n]{\\prod_{i=1}^n X_i}$$\nWhere: $n=2$ (since we have only two tokens in a pool), $X_i$ is current reserves ($X_1 = x, X_2=y$), $X_i\u0026rsquo;$ is updated reserves. This is a general representation of the trade function, Uniswap\u0026rsquo;s implementation is a special case of this formula.\nThe Curve #  The above calculations might seem too abstract and dry. Let\u0026rsquo;s visualize the constant product function to better understand how it works\nWhen plotted, the constant product function is a quadratic hyperbola:\n[TODO: add graph]\nWhere axes are reserves. Every trade starts at the point on the curve that corresponds to the current ratio of reserves. To calculate the output amount, we need to find a new point on the curve, which has the $x$ coordinate of $x+\\Delta x$, i.e. current reserve of token A + the amount we\u0026rsquo;re selling. The change in $y$ is the number of tokens B we\u0026rsquo;ll get.\nLet\u0026rsquo;s look at a concrete example:\n[TODO: add graph]\n Start price ($P_x = \\frac{y}{x}$) is 4: 1 X = 4 Y. We\u0026rsquo;re selling 42 X. If we use only the start price, we expect to get 42 * 4 = 168 Y. However, the execution price is 2.173, so we get only 91.304 Y!   To build a better intuition of how it works, try making up several scenario and plot them on the graph. Try different X amount relative to the reserve of X, see how output amount changes hen $\\Delta x$ is small relative to $x$.\n  This wonderful chart was created by Dan Robinson, one of the creators of Uniswap. Massive kudos!\n I bet you\u0026rsquo;re wondering why using such a curve? It might seem like it punishes you for trading big amounts. This is true, and this is a desirable property! The law of supply and demand tells us that when demand is high (and supply is constant) the price is also high. And when demand is low, the price is also lower. This is how markets work. And, magically, the constant product function implements this mechanism! Demand is defined by the amount you want to buy, and supply is the pool reserves. When you want to buy a big amount relative to pool reserves the price is higher than when you want to buy a smaller amount. Such a simple formula guarantees such a powerful mechanism!\nAnd that\u0026rsquo;s the whole math of Uniswap! Phew!\nWell, this is the math of Uniswap V2, and we\u0026rsquo;re studying Uniswap V3. So in the next part, we\u0026rsquo;ll see how the mathematics of Uniswap V3 is different.\n"},{"id":2,"href":"/uniswapv3-book/docs/introduction/uniswap-v3/","title":"Uniswap V3","section":"Milestone 0","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]  Introduction to Uniswap V3 #  To better understand the innovations Uniswap V3 brings, let\u0026rsquo;s first look at the imperfections of Uniswap V2.\nUniswap V2 is a general exchange that implements one AMM algorithm. However, not all trading pairs are equal. We can group pairs by price volatility:\n Pairs with medium and high volatility. This group includes most of the tokens since most tokens don\u0026rsquo;t have their prices pegged to something and are subject to market fluctuations. Pairs with low volatility. This group includes pegged tokens, mainly stablecoins: USDC-USDT, USDC-DAI, USDT-DAI, etc. Also: ETH-stETH, ETH-rETH.  These groups require different, let\u0026rsquo;s call them, pool configurations. The main difference is that pegged tokens require high liquidity to reduce the demand effect (we learned about it in the previous chapter) on big trades. The prices of USDC and USDT must stay close to 1, no matter how big the number of tokens we want to buy and sell.\nAnother imperfection of Uniswap V2 is that liquidity in a pool is distributed infinitely. Liquidity is provided at any price from 0 to infinity:\n[TODO: add illustration]\n[TODO: escape $]\nThis might not seem like a bad thing, but this reduces capital efficiency. Historical prices of an asset stay within some defined range, whether it\u0026rsquo;s narrow or wide. For example, the historical price range of ETH is from $0.75 to $4,800 (according to CoinMarketCap). Today (June 2022, 1 ETH costs $1,1800), no one will buy 1 ether for $5000 so it makes no sense to provide liquidity at this price. Thus, a lot of liquidity in a V2 pool cannot and won\u0026rsquo;t be used, ever. And this can be improved.\nConcentrated Liquidity #  Uniswap V3 introduces the idea of concentrated liquidity. Liquidity providers can now choose the price range they want to provide liquidity into. This improves capital efficiency by allowing to put more liquidity into a narrow price range, which makes Uniswap more diverse: it can now have pools configured specifically for medium-to-high volatility pairs or low-volatility pairs. This fixes the problem of Uniswap V2 we discussed above. However, this also feature doesn\u0026rsquo;t come without drawbacks: it\u0026rsquo;s now possible that the global price of an asset moves rapidly to a range V3 pools have no liquidity in.\n[TODO: add illustration, compare liquidity distributions]\nImplementing concentrated liquidity requires changing the mathematics of Uniswap. Pool contracts no longer track pool reserves, $x$ and $y$. Instead, they track liquidity, $L$:\n$$L = \\sqrt{xy}$$\nAnd square root of price, $\\sqrt{P}$: $$\\sqrt{P} = \\sqrt{\\frac{y}{x}}$$\n$L$ is simply the geometric mean of reserves, you can think of it as a unit of liquidity.\n In the previous chapter, we figured out that the trade function can be rewritten as a comparison of geometric means of reserves before and after a swap.\n $P$ is the price of token X in terms of token Y, and $\\sqrt{P}$ is the square root of this price. We don\u0026rsquo;t need to track both prices because they\u0026rsquo;re simply reciprocals of each other: the price of token Y is $\\frac{1}{\\sqrt{P}} = \\frac{1}{\\sqrt{y/x}}$.\n[TODO: explain why using sqrt(P)]\nThese values can be used to compute the reserves: $$x = \\frac{L}{\\sqrt{P}}$$ $$y = L \\sqrt{P}$$\n[TODO: explain calculations]\nTicks #  Custom liquidity ranges are implemented through ticks–the range of all possible prices is demarcated by ticks and liquidity is provided between two ticks chosen by a liquidity provider.\n[TODO: add illustration]\nEach tick is mapped to some price from the range of all available prices. This mapping is done through this formula:\n$$p(i) = 1.00001^i$$\nWhere $p(i)$ is the price at tick $i$. This formula is then improved to use $\\sqrt{p}$ instead of $p$ for two reasons:\n  Square root calculation is tricky and expensive in terms of gas consumption. Thus, it\u0026rsquo;s easier to store the square root of it.\n  $\\sqrt{P}$ has an interesting connection to $L$:\n$$L = \\frac{\\Delta y}{\\Delta\\sqrt{P}}$$\n$L$ is also the relation between the change in output amount and $\\sqrt{P}$. [TODO: prove this]\n  Thus, we can rewrite the tick-price formula as:\n$$ \\sqrt{p(i)} = \\sqrt{1.0001}^i = 1.0001^{\\frac{i}{2}}$$\n$1.0001^i$ was chosen because it makes adjacent ticks 0.01% away from each other. The difference in price between two adjacent ticks is 0.01%, or 1 basis point.\n Basis point (1/100th of 1%, or 0.01%, or 0.0001) is a unit of measure of percentages in finance. You could heard about basis point when central banks announced changes in interest rates.\n The takeaway is: this seemingly tricky algorithm allows to demarcate the continuous range of prices into evenly distributed prices indexed by ticks, where the distance between two prices/ticks is always 0.01%. This is a powerful design. If it\u0026rsquo;s hard to understand now, it\u0026rsquo;ll become clearer after we implemented it.\nPricing #  The last thing we need to figure out is how prices (or output amounts) are calculated.\nSince we can find $x$ and $y$ from $L$ and $\\sqrt{P}$, we can calculate $\\Delta x$ and $\\Delta y$ using the formulas from the previous chapter. However, there\u0026rsquo;s a better way. Let\u0026rsquo;s return to this formula:\n$$L = \\frac{\\Delta y}{\\Delta\\sqrt{P}}$$\nWe can find $\\Delta y$ using this formula:\n$$\\Delta y = \\Delta \\sqrt{P} L$$\nAs we discussed above, prices in a pool are reciprocals of each other. Since $\\frac{y}{x}$ is the price of $x$ in terms of $y$, then $\\frac{x}{y}$ (or $\\frac{1}{y/x}$) is the other way around. Next, if $\\sqrt{P} = \\sqrt{\\frac{y}{x}}$, then $\\frac{1}{\\sqrt{P}} = \\frac{1}{\\sqrt{y/x}}$, then $\\frac{1}{\\sqrt{P}}$ is the square root of the price of $y$ in terms of $x$ (reciprocal of $\\sqrt{P}$). Knowing this, we can express $L$ in terms of $\\Delta x$:\n$$L = \\frac{\\Delta x}{\\Delta \\frac{1}{\\sqrt{P}}}$$\nAnd, finally:\n$$\\Delta x = \\Delta \\frac{1}{\\sqrt{P}} L$$\nThis means that we don\u0026rsquo;t need to store reserves in the contract, and we also don\u0026rsquo;t need to calculate the square root of P. To calculate output amount we need to know input amount (trader chooses it) and $L$ (calculated based on liquidity in a pool). To calculate input amount we need to know output amount (trader chooses it) and $L$. In both cases, we first need to calculate $\\Delta \\sqrt{P}$ or $\\Delta \\frac{1}{\\sqrt{P}}$.\n[TODO: clean up, make the connection between the formulas clearer.]\nSummary #  "}]