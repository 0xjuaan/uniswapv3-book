<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); }    \[ \]   You&rsquo;ll find the complete code of this chapter in this Github branch.
 First Swap #  Enough of theory, let&rsquo;s start coding!"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="First Swap"><meta property="og:description" content="function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); }    \[ \]   You&rsquo;ll find the complete code of this chapter in this Github branch.
 First Swap #  Enough of theory, let&rsquo;s start coding!"><meta property="og:type" content="article"><meta property="og:url" content="https://jeiwan.net/uniswapv3-book/docs/milestone_1/first-swap/"><meta property="article:section" content="docs"><title>First Swap | Uniswap V3 Development Book</title><link rel=manifest href=/uniswapv3-book/manifest.json><link rel=icon href=/uniswapv3-book/favicon.png type=image/x-icon><link rel=stylesheet href=/uniswapv3-book/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/uniswapv3-book/flexsearch.min.js></script>
<script defer src=/uniswapv3-book/en.search.min.c5f6147ca96de252a9662c5397abc34aac1bbf230b0e753b38524894de891684.js integrity="sha256-xfYUfKlt4lKpZixTl6vDSqwbvyMLDnU7OFJIlN6JFoQ=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/uniswapv3-book/><span>Uniswap V3 Development Book</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Milestone 0</span><ul><li><a href=/uniswapv3-book/docs/introduction/amm/>Introduction to markets</a></li><li><a href=/uniswapv3-book/docs/introduction/cfmm/>Constant Function Market Makers</a></li><li><a href=/uniswapv3-book/docs/introduction/uniswap-v3/>Uniswap V3</a></li><li><a href=/uniswapv3-book/docs/introduction/dev-environment/>Development Environment</a></li></ul></li><li class=book-section-flat><span>Milestone 1</span><ul><li><a href=/uniswapv3-book/docs/milestone_1/first-swap/ class=active>First Swap</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/uniswapv3-book/svg/menu.svg class=book-icon alt=Menu></label>
<strong>First Swap</strong>
<label for=toc-control><img src=/uniswapv3-book/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#first-swap>First Swap</a><ul><li><a href=#pool-contract>Pool Contract</a></li><li><a href=#liquidity-calculation>Liquidity Calculation</a></li><li><a href=#minting>Minting</a></li></ul></li></ul></nav></aside></header><article class=markdown><link rel=stylesheet href=/uniswapv3-book/katex/katex.min.css><script>function renderKatex(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})}</script><script defer src=/uniswapv3-book/katex/katex.min.js></script>
<script defer src=/uniswapv3-book/katex/auto-render.min.js onload=renderKatex(document.body)></script><span>
\[ \]</span><blockquote><p>You&rsquo;ll find the complete code of this chapter in <a href=https://github.com/Jeiwan/uniswapv3-code/tree/milestone_1>this Github branch</a>.</p></blockquote><h1 id=first-swap>First Swap
<a class=anchor href=#first-swap>#</a></h1><p>Enough of theory, let&rsquo;s start coding!</p><p>Create a new folder (mine is called <code>uniswapv3-code</code>), and run <code>forge init --vscode</code> in it–this will initialize a Forge
project. The <code>--vscode</code> flag tells Forge to configure the Solidity extension for Forge projects.</p><p>Next, remove the default contract and its test:</p><ul><li><code>script/Contract.s.sol</code></li><li><code>src/Contract.sol</code></li><li><code>test/Contract.t.sol</code></li></ul><p>And that&rsquo;s it! Let&rsquo;s create our first contract!</p><h2 id=pool-contract>Pool Contract
<a class=anchor href=#pool-contract>#</a></h2><p>As you&rsquo;ve learned from the introduction, Uniswap deploys multiple Pool contracts, each of which is an exchange market of
a pair of tokens. Uniswap groups all its contract into two categories:</p><ul><li>core contracts, and</li><li>periphery contracts.</li></ul><p>Core contracts are, as the name implies, the contracts that implement core logic. These are minimal, user-<em>un</em>friendly,
low-level contracts. Their purpose is to do one thing. In Uniswap V3, there are 2 such contracts:</p><ol><li>Pool contract, which implements the core logic of a decentralized exchange.</li><li>Factory contract, which serves as a registry of Pool contracts and a contract that makes deployment of pools easier.</li></ol><p>We&rsquo;ll begin with the pool contract. Create <code>src/UniswapV3Pool.sol</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// SPDX-License-Identifier: UNLICENSED
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pragma solidity</span> <span style=color:#f92672>^</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>8</span>.<span style=color:#ae81ff>14</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>contract</span> <span style=color:#a6e22e>UniswapV3Pool</span> {}
</span></span></code></pre></div><p>Let&rsquo;s think about what data the contract will store:</p><ol><li>Since every pool contract is an exchange market of two tokens, we need to track the two token addresses. And these
addresses will be static, set once and forever during contract initialization.</li><li>Each pool contract is a set of liquidity positions, a data structure to manage positions identified by: liquidity
provider&rsquo;s address, and upper and lower bounds of the position.</li><li>Each pool contract will also need to maintain a ticks registry and information about each tick–the amount of liquidity
provided by each tick.</li><li>Since the tick range is limited, we need to store the limits in the contract, as constants.</li><li>And as we discussed in the introduction, pool contracts store the amount of liquidity, $L$, and $\sqrt{P}$ instead of
token reserves. So we&rsquo;ll need to store them in the contract as well.</li></ol><p>Here&rsquo;s what our pool contract with all the state variables:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>contract</span> <span style=color:#a6e22e>UniswapV3Pool</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>using</span> Tick <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>int24</span> <span style=color:#f92672>=&gt;</span> Tick.Info);
</span></span><span style=display:flex><span>    <span style=color:#f92672>using</span> Position <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>bytes32</span> <span style=color:#f92672>=&gt;</span> Position.Info);
</span></span><span style=display:flex><span>    <span style=color:#f92672>using</span> Position <span style=color:#66d9ef>for</span> Position.Info;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>constant</span> MIN_TICK <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>887272</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>constant</span> MAX_TICK <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>MIN_TICK;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Pool tokens, immutable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>address</span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>immutable</span> token0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>address</span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>immutable</span> token1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// First slot will contain essential data
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Slot0</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Current sqrt(P)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>uint160</span> sqrtPriceX96;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Current tick
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int24</span> tick;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Slot0 <span style=color:#66d9ef>public</span> slot0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Amount of liquidity, L.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>uint128</span> <span style=color:#66d9ef>public</span> liquidity;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Ticks info
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>int24</span> <span style=color:#f92672>=&gt;</span> Tick.Info) <span style=color:#66d9ef>public</span> ticks;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Positions info
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>bytes32</span> <span style=color:#f92672>=&gt;</span> Position.Info) <span style=color:#66d9ef>public</span> positions;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ...
</span></span></code></pre></div><p>And we&rsquo;ll initialize them in the constructor:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>    <span style=color:#66d9ef>constructor</span>(
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>address</span> token0_,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>address</span> token1_,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint160</span> sqrtPriceX96,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int24</span> tick
</span></span><span style=display:flex><span>    ) {
</span></span><span style=display:flex><span>        token0 <span style=color:#f92672>=</span> token0_;
</span></span><span style=display:flex><span>        token1 <span style=color:#f92672>=</span> token1_;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        slot0 <span style=color:#f92672>=</span> Slot0({sqrtPriceX96<span style=color:#f92672>:</span> sqrtPriceX96, tick<span style=color:#f92672>:</span> tick});
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Tick</code> and <code>Position</code> are custom types that make the managing of ticks and positions easier. You&rsquo;ll find their code in <code>lib</code>
folder.</p><blockquote><p>For brevity, I&rsquo;ll omit detailed explanation of Solidity syntax and features. Solidity has <a href=https://docs.soliditylang.org/en/latest/>great documentation</a>,
don&rsquo;t hesitate referring to it if something is not clear!</p></blockquote><p>This is our starting point, and our goal in this chapter is to make our first swap.</p><h2 id=liquidity-calculation>Liquidity Calculation
<a class=anchor href=#liquidity-calculation>#</a></h2><p>Trading is not possible without liquidity, and to make our first swap we need to put some liquidity into the pool contract.
Providing liquidity into a pool simply means:</p><ul><li>sending tokens to the pool,</li><li>updating pool parameters so our liquidity is recorded and used for swaps.</li></ul><p>Tokens are smart contracts, they track balances inside their own storage: when you send tokens to someone you simply
update balances in token&rsquo;s storage. Thus, we don&rsquo;t need to enable tokens receiving in our pool contract–it&rsquo;ll just
work! However, we want the contract to put provided liquidity into some price range.</p><p>Remember that, in Uniswap V3, the entire price range is demaracted into <em>ticks</em>: each tick corresponds to a price and has
an index. For the sake of simplicity, let&rsquo;s pretend that we&rsquo;re going to buy ETH for USDC at the price of <span>$5000</span>
per 1 ETH. And we&rsquo;re going to buy some amount of ETH to push the price slightly above <span>$5000</span>. We want
to provide liquidity at a range that includes this price. And we want to be sure that final price will stay <strong>within this
range</strong> (again, let&rsquo;s keep it as simple as possible at this moment).</p><p>Let&rsquo;s find the index of the tick that corresponds to the price of $5000 per 1 ETH. We know that:</p><p>$$\sqrt{p(i)}=1.0001^{\frac{i}{2}}$$</p><p>Thus, to find $i$:</p><p>$$i = log_{\sqrt{1.0001}} \sqrt{p(i)}$$</p><p>Since we&rsquo;re going to buy ETH, we&rsquo;re going to sell USDC. Thus the price is:</p><p>$$p = \frac{y}{x} = \frac{1}{5000} = 0.0002 \enspace ETH/USDC$$</p><p>We can find the tick:</p><p>$$i = log_{\sqrt{1.0001}}\sqrt{0.0002} = log_{1.00005}0.014142135 = -85174.062077$$</p><p>And we&rsquo;ll then round it down to nearest integer:</p><p>$$i = -85174$$</p><p>This tick will be the lower bound of the price range we&rsquo;ll provide liquidity into. How to find the upper bound? We can
choose whichever we want! Let&rsquo;s choose the span of 100 ticks:</p><p>$$[-85174;-85074]$$</p><p>[TODO: 100 or 101?]</p><p>Let&rsquo;s see how we can convert the upper tick to the corresponding price:</p><ol><li>First, we know that the difference in $\sqrt{p}$ of two adjacent ticks is 1 basis point (0.01% or 0.0001).</li><li>Since our range is 100 ticks, the price of $\sqrt{p(i+100)}$ is:
$$\sqrt{p(i+100)} = \sqrt{p(i)}*1.0001^{100}$$</li><li>Let&rsquo;s find it:
$$\sqrt{p(-85074)} = \sqrt{p(-85174)}*1.0001^{100} = \sqrt{0.0002}*1.0001^{100} \approx 0,0142842$$
$$p(-85074) \approx 0,0142842^{2} \approx 0,00020404 \enspace ETH/USDC$$</li></ol><p>Expectedly, the price is higher! And the reciprocal price is expectedly lower:
$$\frac{1}{0.00020404} = 4901 \enspace USDC/ETH$$</p><p>So, if we pick this price range, the curve within this range will look like this:</p><p>[TODO: add curve]</p><blockquote><p>At this point, we&rsquo;ll only implement a swapping within this curve and price range. Later on, we&rsquo;ll see how swapping works
when current price range doesn&rsquo;t have enough liquidity.</p></blockquote><p>Lastly, we need to calculate the amount of liquidity that will be enough to make a small trade within the price range. We
expect to start at 0.0002 ETH/USDC and bring the price not higher than 0.00020404 ETH/USDC:</p><p>[TODO: add curve with start and end prices]</p><p>To not overload this chapter with calculations, we&rsquo;ll simply pick it up empirically 🤷‍♂️ During development and testing,
we&rsquo;ll be able to mint as many tokens as we want.</p><h2 id=minting>Minting
<a class=anchor href=#minting>#</a></h2><p>The process of providing liquidity in Uniswap V2 is called <em>minting</em>. The reason is that the V2 pool contract mints
tokens (LP-tokens) in exchange for liquidity. V3 doesn&rsquo;t do that, but it still uses the same name for the function. Let&rsquo;s
use it as well:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>mint</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>address</span> owner,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> lowerTick,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> upperTick,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint128</span> amount
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>external</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>uint256</span> amount0, <span style=color:#66d9ef>uint256</span> amount1) {
</span></span><span style=display:flex><span>    ...
</span></span></code></pre></div><p>Our <code>mint</code> function will take:</p><ol><li>Owner&rsquo;s address, to track the owner of the liquidity.</li><li>Upper and lower ticks, to set the bounds of a price range.</li><li>The amount of liquidity we have provided.</li></ol><p>When adding initial liquidity to a pool, this function adds a new tick and a position.</p><p>We begin with checking the ticks:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>if</span> (
</span></span><span style=display:flex><span>    lowerTick <span style=color:#f92672>&gt;=</span> upperTick <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>    lowerTick <span style=color:#f92672>&lt;</span> MIN_TICK <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>    upperTick <span style=color:#f92672>&gt;</span> MAX_TICK
</span></span><span style=display:flex><span>) revert InvalidTickRange();
</span></span></code></pre></div><p>And ensuring that some amount of liquidity is provided:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>if</span> (amount <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) revert ZeroLiquidity();
</span></span></code></pre></div><p>Then, add a tick and a position:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>ticks.update(lowerTick, amount);
</span></span><span style=display:flex><span>ticks.update(upperTick, amount);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Position.Info <span style=color:#66d9ef>storage</span> position <span style=color:#f92672>=</span> positions.get(
</span></span><span style=display:flex><span>    owner,
</span></span><span style=display:flex><span>    lowerTick,
</span></span><span style=display:flex><span>    upperTick
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>position.update(amount);
</span></span></code></pre></div><p>The <code>ticks.update</code> function is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// src/libs/Tick.sol
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>...
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>update</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>int24</span> <span style=color:#f92672>=&gt;</span> Tick.Info) <span style=color:#66d9ef>storage</span> self,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> tick,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int128</span> liquidityDelta
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>internal</span> {
</span></span><span style=display:flex><span>    Tick.Info <span style=color:#66d9ef>storage</span> tickInfo <span style=color:#f92672>=</span> self[tick];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint128</span> liquidityBefore <span style=color:#f92672>=</span> tickInfo.liquidity;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint128</span> liquidityAfter <span style=color:#f92672>=</span> liquidityBefore <span style=color:#f92672>+</span> <span style=color:#66d9ef>uint128</span>(liquidityDelta);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (liquidityBefore <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        tickInfo.initialized <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    tickInfo.liquidity <span style=color:#f92672>=</span> liquidityAfter;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>It initialized a tick if it has 0 liquidity before and adds new liquidity to it. As you can see, we&rsquo;re calling this
function on both lower and upper ticks, thus liquidity is added to both of them–we&rsquo;ll see why later on.</p><p>The <code>position.update</code> function is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// src/libs/Position.sol
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>update</span>(Info <span style=color:#66d9ef>storage</span> self, <span style=color:#66d9ef>int128</span> liquidityDelta) <span style=color:#66d9ef>internal</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint128</span> liquidityBefore <span style=color:#f92672>=</span> self.liquidity;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint128</span> liquidityAfter <span style=color:#f92672>=</span> liquidityBefore <span style=color:#f92672>+</span> <span style=color:#66d9ef>uint128</span>(liquidityDelta);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    self.liquidity <span style=color:#f92672>=</span> liquidityAfter;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Similar to the tick update function, it adds liquidity to a specific position. And to get a position we call:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// src/libs/Position.sol
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>...
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>get</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>bytes32</span> <span style=color:#f92672>=&gt;</span> Info) <span style=color:#66d9ef>storage</span> self,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>address</span> owner,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> lowerTick,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> upperTick
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>view</span> <span style=color:#66d9ef>returns</span> (Position.Info <span style=color:#66d9ef>storage</span> position) {
</span></span><span style=display:flex><span>    position <span style=color:#f92672>=</span> self[
</span></span><span style=display:flex><span>        keccak256(abi.encodePacked(owner, lowerTick, upperTick))
</span></span><span style=display:flex><span>    ];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>Each position is uniquely identified by three keys: owner address, lower tick index, and upper tick index. We&rsquo;re storing
positions in a <code>bytes32 => Info</code> map and are using hashes of concatenated owner address, lower tick, and upper tick as
keys. This is cheaper than storing three nested maps.</p><p>We&rsquo;re not done yet! Next, we need to calculate the amounts that a user must deposit. These amounts will be based on current
$\sqrt{P}$ and the parameters the user passed to <code>mint</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#first-swap>First Swap</a><ul><li><a href=#pool-contract>Pool Contract</a></li><li><a href=#liquidity-calculation>Liquidity Calculation</a></li><li><a href=#minting>Minting</a></li></ul></li></ul></nav></div></aside></main></body></html>