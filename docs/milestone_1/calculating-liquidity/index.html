<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); }    \[ \]  Calculating liquidity #  Trading is not possible without liquidity, and to make our first swap we need to put some liquidity into the pool contract."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Calculating Liquidity"><meta property="og:description" content="function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); }    \[ \]  Calculating liquidity #  Trading is not possible without liquidity, and to make our first swap we need to put some liquidity into the pool contract."><meta property="og:type" content="article"><meta property="og:url" content="https://uniswapv3book.com/docs/milestone_1/calculating-liquidity/"><meta property="article:section" content="docs"><title>Calculating Liquidity | Uniswap V3 Development Book</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.b248e12614ae8e694552a346b0b4ec7f363b9ec02f2f32570dc79f9c9be409f8.js integrity="sha256-skjhJhSujmlFUqNGsLTsfzY7nsAvLzJXDcefnJvkCfg=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Uniswap V3 Development Book</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Milestone 0</span><ul><li><a href=/docs/introduction/amm/>Introduction to markets</a></li><li><a href=/docs/introduction/cfmm/>Constant Function Market Makers</a></li><li><a href=/docs/introduction/uniswap-v3/>Uniswap V3</a></li><li><a href=/docs/introduction/dev-environment/>Development Environment</a></li></ul></li><li class=book-section-flat><span>Milestone 1. First Swap</span><ul><li><a href=/docs/milestone_1/introduction/>Introduction</a></li><li><a href=/docs/milestone_1/calculating-liquidity/ class=active>Calculating Liquidity</a></li><li><a href=/docs/milestone_1/providing-liquidity/>Providing Liquidity</a></li><li><a href=/docs/milestone_1/first-swap/>First Swap</a></li><li><a href=/docs/milestone_1/manager-contract/>Manager Contract</a></li><li><a href=/docs/milestone_1/deployment/>Deployment</a></li><li><a href=/docs/milestone_1/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 2. Second Swap</span><ul><li><a href=/docs/milestone_2/introduction/>Introduction</a></li><li><a href=/docs/milestone_2/output-amount-calculation/>Output Amount Calculation</a></li><li><a href=/docs/milestone_2/math-in-solidity/>Math in Solidity</a></li><li><a href=/docs/milestone_2/tick-bitmap-index/>Tick Bitmap Index</a></li><li><a href=/docs/milestone_2/generalize-minting/>Generalize Minting</a></li><li><a href=/docs/milestone_2/generalize-swapping/>Generalize Swapping</a></li><li><a href=/docs/milestone_2/quoter-contract/>Quoter Contract</a></li><li><a href=/docs/milestone_2/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 3. Cross-tick Swaps</span><ul><li><a href=/docs/milestone_3/introduction/>Introduction</a></li><li><a href=/docs/milestone_3/different-ranges/>Different Price Ranges</a></li><li><a href=/docs/milestone_3/cross-tick-swaps/>Cross-Tick Swaps</a></li><li><a href=/docs/milestone_3/slippage-protection/>Slippage Protection</a></li><li><a href=/docs/milestone_3/liquidity-calculation/>Liquidity Calculation</a></li><li><a href=/docs/milestone_3/more-on-fixed-point-numbers/>A Little Bit More on Fixed-point Numbers</a></li><li><a href=/docs/milestone_3/flash-loans/>Flash Loans</a></li><li><a href=/docs/milestone_3/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 4. Multi-pool Swaps</span><ul><li><a href=/docs/milestone_4/introduction/>Introduction</a></li><li><a href=/docs/milestone_4/factory-contract/>Factory Contract</a></li><li><a href=/docs/milestone_4/path/>Swap Path</a></li><li><a href=/docs/milestone_4/multi-pool-swaps/>Multi-pool Swaps</a></li><li><a href=/docs/milestone_4/user-interface/>User Interface</a></li><li><a href=/docs/milestone_4/tick-rounding/>Tick Rounding</a></li></ul></li><li class=book-section-flat><span>Milestone 5. Fees and Price Oracle</span><ul><li><a href=/docs/milestone_5/introduction/>Introduction</a></li><li><a href=/docs/milestone_5/swap-fees/>Swap Fees</a></li><li><a href=/docs/milestone_5/flash-loan-fees/>Flash Loan Fees</a></li><li><a href=/docs/milestone_5/protocol-fees/>Protocol Fees</a></li><li><a href=/docs/milestone_5/price-oracle/>Price Oracle</a></li><li><a href=/docs/milestone_5/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 6: NFT positions</span><ul><li><a href=/docs/milestone_6/introduction/>Introduction</a></li><li><a href=/docs/milestone_6/erc721-overview/>ERC721 Overview</a></li><li><a href=/docs/milestone_6/nft-manager/>NFT Manager</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Calculating Liquidity</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#calculating-liquidity>Calculating liquidity</a><ul><li><a href=#price-range-calculation>Price Range Calculation</a></li><li><a href=#token-amounts-calculation>Token Amounts Calculation</a></li><li><a href=#liquidity-amount-calculation>Liquidity Amount Calculation</a></li><li><a href=#token-amounts-calculation-again>Token Amounts Calculation, Again</a></li></ul></li></ul></nav></aside></header><article class=markdown><link rel=stylesheet href=/katex/katex.min.css><script>function renderKatex(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})}</script><script defer src=/katex/katex.min.js></script>
<script defer src=/katex/auto-render.min.js onload=renderKatex(document.body)></script><span>
\[ \]</span><h1 id=calculating-liquidity>Calculating liquidity
<a class=anchor href=#calculating-liquidity>#</a></h1><p>Trading is not possible without liquidity, and to make our first swap we need to put some liquidity into the pool contract.
Here&rsquo;s what we need to know to add liquidity to the pool contract:</p><ol><li>A price range. As a liquidity provider, we want to provide liquidity at a specific price range, and it&rsquo;ll only be used
in this range.</li><li>Amount of liquidity, which is the amounts of two tokens. We&rsquo;ll need to transfer these amounts to the pool contract.</li></ol><p>Here, we&rsquo;re going to calculate these manually, but, in a later chapter, a contract will do this for us. Let&rsquo;s begin with
a price range.</p><h2 id=price-range-calculation>Price Range Calculation
<a class=anchor href=#price-range-calculation>#</a></h2><p>Recall that, in Uniswap V3, the entire price range is demaracted into <em>ticks</em>: each tick corresponds to a price and has
an index. In our first pool implementation, we&rsquo;re going to buy ETH for USDC at the price of <span>$5000</span> per 1 ETH.
Buying ETH will remove some amount of it from the pool and will push the price slightly above <span>$5000</span>.
We want to provide liquidity at a range that includes this price. And we want to be sure that the final price will stay
<strong>within this range</strong> (we&rsquo;ll do multi-range swaps in a later chapter).</p><p>We&rsquo;ll need to find three ticks:</p><ol><li>The current tick will correspond to the current price (5000 USDC for 1 ETH).</li><li>The lower and upper bounds of the price range we&rsquo;re providing liquidity into. Let the lower price be <span>$4500</span>
and the upper price be <span>$5500</span>.</li></ol><p>From the theoretical introduction we know that:</p><p>$$\sqrt{p} = \sqrt{\frac{y}{x}}$$</p><p>Since we&rsquo;ve agreed to use ETH as the $x$ reserve and USDC as the $y$ reserve, the prices at each of the ticks are:</p><p>$$\sqrt{p_c} = \sqrt{\frac{5000}{1}} = \sqrt{5000} \approx 70.71$$</p><p>$$\sqrt{p_l} = \sqrt{\frac{4545}{1}} \approx 67.42$$</p><p>$$\sqrt{p_u} = \sqrt{\frac{5500}{1}} \approx 74.16$$</p><p>Where $p_c$ is the current price, $p_l$ is the lower bound of the range, $p_u$ is the upper bound of the range.</p><p>Now, we can find corresponding ticks. We know that prices and ticks are connected via this formula:</p><p>$$\sqrt{p(i)}=1.0001^{\frac{i}{2}}$$</p><p>Thus, we can find tick $i$ via:</p><p>$$i = log_{\sqrt{1.0001}} \sqrt{p(i)}$$</p><blockquote><p>The square roots in this formula cancel out, but since we&rsquo;re working with $\sqrt{p}$ we need to preserve them.</p></blockquote><p>Let&rsquo;s find the ticks:</p><ol><li>Current tick: $i_c = log_{\sqrt{1.0001}} 70.71 = 85176$</li><li>Lower tick: $i_l = log_{\sqrt{1.0001}} 67.42 = 84222$</li><li>Upper tick: $i_u = log_{\sqrt{1.0001}} 74.16 = 86129$</li></ol><blockquote><p>To calculate these, I used Python:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> math
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>price_to_tick</span>(p):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> math<span style=color:#f92672>.</span>floor(math<span style=color:#f92672>.</span>log(p, <span style=color:#ae81ff>1.0001</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>price_to_tick(<span style=color:#ae81ff>5000</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>85176</span>
</span></span></code></pre></div><p>(Feel free using any other language.)</p></blockquote><p>That&rsquo;s it for price range calculation!</p><p>Last thing to note here is that Uniswap uses Q64.96 number to store $\sqrt{p}$. This is a fixed point number that has
64 bits for the integer part and 96 bits for the fractional part. In our above calculations, prices are floating point
numbers: <code>70.71</code>, <code>67.42</code>, <code>74.16</code>. We need to convert them to Q64.96. Luckily, this is simple: we need to multiply the
numbers by the maximum value of the fractional part of Q64.96, which is $2^{96}$. We&rsquo;ll get:</p><p>$$\sqrt{p_c} = 5602277097478614198912276234240$$</p><p>$$\sqrt{p_l} = 5314786713428871004159001755648$$</p><p>$$\sqrt{p_u} = 5875717789736564987741329162240$$</p><blockquote><p>In Python:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>q96 <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>**</span><span style=color:#ae81ff>96</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>price_to_sqrtp</span>(p):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> int(math<span style=color:#f92672>.</span>sqrt(p) <span style=color:#f92672>*</span> q96)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>price_to_sqrtp(<span style=color:#ae81ff>5000</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>5602277097478614198912276234240</span>
</span></span></code></pre></div><p>Notice that we&rsquo;re multiplying before converting to integer. Otherwise, we&rsquo;ll use precision.</p></blockquote><p>Ok, we&rsquo;re done here.</p><h2 id=token-amounts-calculation>Token Amounts Calculation
<a class=anchor href=#token-amounts-calculation>#</a></h2><p>Next step is to decide how many tokens we want to deposit into the pool. The answer is: as many as we want. The amounts
are not strictly defined, we can deposit as much as it is enough to buy a small amount of ETH without causing the price
leave the price range we put liquidity into. During development and testing we&rsquo;ll be able to mint any amount of tokens,
so getting the amounts we want is not a problem.</p><p>For our first swap, let&rsquo;s deposit 1 ETH and 5000 USDC.</p><h2 id=liquidity-amount-calculation>Liquidity Amount Calculation
<a class=anchor href=#liquidity-amount-calculation>#</a></h2><p>Next, we need to calculate $L$ based on the amounts we&rsquo;ll deposit.</p><p>From the theoretical introduction, you remember that:
$$L = \sqrt{xy}$$</p><p>However, we cannot simply multiply 1 ETH by 5000 USDC and take the square root. The reason is that the $x$ and $y$ in this
formula are <strong>virtual reserves</strong>.
[TODO: what are virtual reserves?]</p><p>We need to calculate $L$ specifically for the price range we&rsquo;re going to deposit liquidity into, and it&rsquo;ll be calculated
based on the amounts we&rsquo;re going to deposit. To find $L$, we need to look at one interesting fact: when the current price
equals the lower or the upper price, <strong>one of the pool reserves is 0 and all pool&rsquo;s liquidity is in the other reserve</strong>.
For example, if the current price is <span>$5500</span> then all ETH was bought from the pool and there&rsquo;s only USDC left.
And vice versa: when the current price is <span>$4500</span> then all USDC was bought from the pool and there&rsquo;s only ETH.</p><p>[TODO: illustrate]</p><p>[TODO: or maybe use the delta x and delta y formulas?]
$$\Delta x = \frac{L}{\sqrt{p(i_u)}} - \frac{L}{\sqrt{p(i_c)}} = \frac{L(\sqrt{p(i_u)} - \sqrt{p(i_c)})}{\sqrt{p(i_u)}\sqrt{p(i_c)}}$$
$$\Delta y = L\sqrt{p(i_c)} - L\sqrt{p(i_l)} = L(\sqrt{p(i_c)} - \sqrt{p(i_l)})$$</p><p>Knowing this, let&rsquo;s return to the trading formula of real reserves:</p><p>$$(x + \frac{L}{\sqrt{p_b}})(y + L\sqrt{p_a}) = L^{2}$$</p><p>So, there are two possible situations:</p><ol><li>$x$ can be 0 when the entire reserve of $x$ is bought from the pool.</li><li>$y$ can be 0 when the entire reserve of $y$ is bought from the pool.</li></ol><p>And these situations also serve as constraints: the amount of $L$ we deposit <strong>must</strong> satisfy both of them.</p><p>So, to find $L$, we need to calculate it in both of these scenarios. Let&rsquo;s begin with the one where $y$ is zero. The
trade function will look like so:</p><p>$$(x+\frac{L}{\sqrt{p_b}})L\sqrt{p_a} = L^{2}$$</p><p>When $y$ is zero, any trade will add some $\Delta y$ ($L\sqrt{p_a}$) to the empty reserve of $y$, and no buying of $y$ in
this situation is possible.</p><p>Next, we can find $L$:</p><p>$$L = x\frac{\sqrt{p_a}\sqrt{p_b}}{\sqrt{p_b}-\sqrt{p_a}}$$</p><p>Now, let&rsquo;s find a similar formula for the situation when $x$ is zero:</p><p>$$\frac{L}{\sqrt{p_b}}(y + L\sqrt{p_a}) = L^{2}$$
$$L = \frac{y}{\sqrt{p_b}-\sqrt{p_a}}$$</p><p>[TODO: show the calculations]</p><p>Having these two $L&rsquo;s$, we need to choose one of them and we&rsquo;ll choose the smaller one. Why? The amount of liquidity
we deposit must allow equally big price movements in both directions. If we pick the bigger amount, the other on won&rsquo;t
be enough to satisfy this requirement.</p><p>Now, let&rsquo;s plug our numbers into the formulas. For $x$, $p_a$ is the current price, and $p_b$ is the upper bound of the
price range. For $y$, $p_a$ is the lower bound and $p_b$ is the current price.</p><p>[TODO: add graph, x_real, y_real, from the whitepaper]</p><p>$$L = x\frac{\sqrt{p_a}\sqrt{p_b}}{\sqrt{p_b}-\sqrt{p_a}} = 1 ETH * \frac{67.42 * 70.71}{70.71 - 67.42}$$
After converting to Q64.96, we get:</p><p>$$L = 1519437308014769733632$$</p><p>Solving the other $L$:
$$L = \frac{y}{\sqrt{p_b}-\sqrt{p_a}} = \frac{5000USDC}{74.16-70.71}$$
$$L = 1517882343751509868544$$</p><blockquote><p>In Python:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>sqrtp_low <span style=color:#f92672>=</span> price_to_sqrtp(<span style=color:#ae81ff>4545</span>)
</span></span><span style=display:flex><span>sqrtp_cur <span style=color:#f92672>=</span> price_to_sqrtp(<span style=color:#ae81ff>5000</span>)
</span></span><span style=display:flex><span>sqrtp_upp <span style=color:#f92672>=</span> price_to_sqrtp(<span style=color:#ae81ff>5500</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>liquidity0</span>(amount, pa, pb):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> pa <span style=color:#f92672>&gt;</span> pb:
</span></span><span style=display:flex><span>        pa, pb <span style=color:#f92672>=</span> pb, pa
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (amount <span style=color:#f92672>*</span> (pa <span style=color:#f92672>*</span> pb) <span style=color:#f92672>/</span> q96) <span style=color:#f92672>/</span> (pb <span style=color:#f92672>-</span> pa)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>liquidity1</span>(amount, pa, pb):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> pa <span style=color:#f92672>&gt;</span> pb:
</span></span><span style=display:flex><span>        pa, pb <span style=color:#f92672>=</span> pb, pa
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> amount <span style=color:#f92672>*</span> q96 <span style=color:#f92672>/</span> (pb <span style=color:#f92672>-</span> pa)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>liq0 <span style=color:#f92672>=</span> liquidity0(amount_eth, sqrtp_cur, sqrtp_upp)
</span></span><span style=display:flex><span>liq1 <span style=color:#f92672>=</span> liquidity1(amount_usdc, sqrtp_cur, sqrtp_low)
</span></span><span style=display:flex><span>liq <span style=color:#f92672>=</span> int(min(liq0, liq1))
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1517882343751509868544</span>
</span></span></code></pre></div></blockquote><p>Of these two we&rsquo;re picking the smaller one, <code>1517882343751509868544</code>.</p><h2 id=token-amounts-calculation-again>Token Amounts Calculation, Again
<a class=anchor href=#token-amounts-calculation-again>#</a></h2><p>Since we choose the amounts we&rsquo;re going to deposit, the amounts can be wrong. We cannot deposit any amounts at any price
ranges; liquidity amounts need to aligned with the shape of curve in the price range we&rsquo;re depositing into. Thus, even
though users choose amounts, the contract needs to re-calculate them, and actual amounts will be slightly different (at
least because of rounding). Luckily, we can re-use the formulas from the previous paragraph:</p><p>$$L = x\frac{\sqrt{p_a}\sqrt{p_b}}{\sqrt{p_b}-\sqrt{p_a}}$$
$$L = \frac{y}{\sqrt{p_b}-\sqrt{p_a}}$$</p><p>From them, we can find $x$ and $y$:</p><p>$$ x = \frac{L(\sqrt{p_b}-\sqrt{p_a})}{\sqrt{p_b}\sqrt{p_a}}$$
$$ y = L(\sqrt{p_b}-\sqrt{p_a}) $$</p><blockquote><p>In Python:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>calc_amount0</span>(liq, pa, pb):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> pa <span style=color:#f92672>&gt;</span> pb:
</span></span><span style=display:flex><span>        pa, pb <span style=color:#f92672>=</span> pb, pa
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> int(liq <span style=color:#f92672>*</span> q96 <span style=color:#f92672>*</span> (pb <span style=color:#f92672>-</span> pa) <span style=color:#f92672>/</span> pa <span style=color:#f92672>/</span> pb)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>calc_amount1</span>(liq, pa, pb):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> pa <span style=color:#f92672>&gt;</span> pb:
</span></span><span style=display:flex><span>        pa, pb <span style=color:#f92672>=</span> pb, pa
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> int(liq <span style=color:#f92672>*</span> (pb <span style=color:#f92672>-</span> pa) <span style=color:#f92672>/</span> q96)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>amount0 <span style=color:#f92672>=</span> calc_amount0(liq, sqrtp_upp, sqrtp_cur)
</span></span><span style=display:flex><span>amount1 <span style=color:#f92672>=</span> calc_amount1(liq, sqrtp_low, sqrtp_cur)
</span></span><span style=display:flex><span>(amount0, amount1)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;</span> (<span style=color:#ae81ff>998976618347425408</span>, <span style=color:#ae81ff>5000000000000000000000</span>)
</span></span></code></pre></div><p>As you can see, the number are close to the amounts we want to provide, but ETH is slightly smaller.</p></blockquote><blockquote><p><strong>Hint</strong>: use <code>cast --from-wei AMOUNT</code> to convert from wei to ether. For example:<br><code>cast --from-wei 998976618347425280</code> will give you <code>0.998976618347425280</code>.</p></blockquote><p>To sum it up, when providing liquidity, users:</p><ol><li>choose the price range they want to provide liquidity into,</li><li>choose the amounts of tokens they want to provide.</li></ol><p>Contracts then:</p><ol><li>calculate $L$ based on the amounts and the price range chosen by the user,</li><li>calculate exact amounts the user needs to deposit.</li></ol><p>The amounts users choose are upper bounds, and contracts guarantee that users won&rsquo;t send more tokens than they&rsquo;ve chosen.
We&rsquo;ll see how this works in a later milestone.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#calculating-liquidity>Calculating liquidity</a><ul><li><a href=#price-range-calculation>Price Range Calculation</a></li><li><a href=#token-amounts-calculation>Token Amounts Calculation</a></li><li><a href=#liquidity-amount-calculation>Liquidity Amount Calculation</a></li><li><a href=#token-amounts-calculation-again>Token Amounts Calculation, Again</a></li></ul></li></ul></nav></div></aside></main></body></html>