<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Milestone 1. First Swap on Uniswap V3 Development Book</title><link>https://uniswapv3book.com/docs/milestone_1/</link><description>Recent content in Milestone 1. First Swap on Uniswap V3 Development Book</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://uniswapv3book.com/docs/milestone_1/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction</title><link>https://uniswapv3book.com/docs/milestone_1/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/introduction/</guid><description>First Swap # In this milestone, we&amp;rsquo;ll build a pool contract that can receive liquidity from users and make swaps within a price range. To keep it as simple as possible, we&amp;rsquo;ll provide liquidity only in one price range and we&amp;rsquo;ll allow to make swaps only in one direction. Also, we&amp;rsquo;ll calculate all the required math manually to get better intuition before starting using mathematical libs in Solidity.
Let&amp;rsquo;s model the situation we&amp;rsquo;ll build:</description></item><item><title>Calculating Liquidity</title><link>https://uniswapv3book.com/docs/milestone_1/calculating-liquidity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/calculating-liquidity/</guid><description>Calculating liquidity # Trading is not possible without liquidity, and to make our first swap we need to put some liquidity into the pool contract. Here&amp;rsquo;s what we need to know to add liquidity to the pool contract:
A price range. As a liquidity provider, we want to provide liquidity at a specific price range, and it&amp;rsquo;ll only be used in this range. Amount of liquidity, which is the amounts of two tokens.</description></item><item><title>Providing Liquidity</title><link>https://uniswapv3book.com/docs/milestone_1/providing-liquidity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/providing-liquidity/</guid><description>Providing Liquidity # Enough of theory, let&amp;rsquo;s start coding!
Create a new folder (mine is called uniswapv3-code), and run forge init --vscode in it–this will initialize a Forge project. The --vscode flag tells Forge to configure the Solidity extension for Forge projects.
Next, remove the default contract and its test:
script/Contract.s.sol src/Contract.sol test/Contract.t.sol And that&amp;rsquo;s it! Let&amp;rsquo;s create our first contract!
Pool Contract # As you&amp;rsquo;ve learned from the introduction, Uniswap deploys multiple Pool contracts, each of which is an exchange market of a pair of tokens.</description></item><item><title>First Swap</title><link>https://uniswapv3book.com/docs/milestone_1/first-swap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/first-swap/</guid><description>First Swap # Now that we have liquidity, we can make our first swap!
Calculating Swap Amounts # First step, of course, is to figure out how to calculate swap amounts. And, again, let&amp;rsquo;s pick and hardcode some amount of USDC we&amp;rsquo;re going to trade in for ETH. Let it be 42! We&amp;rsquo;re going to buy ETH for 42 USDC.
After deciding how many tokens we want to sell, we need to calculate how many tokens we&amp;rsquo;ll get in exchange.</description></item><item><title>Manager Contract</title><link>https://uniswapv3book.com/docs/milestone_1/manager-contract/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/manager-contract/</guid><description>Manager Contract # Before deploying our pool contract, we need to solve one problem. As you remember, Uniswap V3 contracts are split into two categories:
Core contracts that implement the core functions and don&amp;rsquo;t provide user-friendly interfaces. Periphery contracts that implement user-friendly interfaces for the core contracts. The pool contract is a core contract, it&amp;rsquo;s not supposed to be user-friendly and flexible. It expects the caller to do all the calculations (prices, amounts) and to provide proper call parameters.</description></item><item><title>Deployment</title><link>https://uniswapv3book.com/docs/milestone_1/deployment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/deployment/</guid><description>Deployment # Alright, our pool contract is done. Now, let&amp;rsquo;s see how we can deploy it to a local Ethereum network so we could use it from a front-end app later on.
Choosing Local Blockchain Network # Smart contracts development requires running a local network, where you deploy your contracts during development and testing. This is what we want from such a network:
Real blockchain. It must be a real Ethereum network, not an emulation.</description></item><item><title>User Interface</title><link>https://uniswapv3book.com/docs/milestone_1/user-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/user-interface/</guid><description>User Interface # Finally, we made it to the final stop of this milestone–building a user interface!
Since building a front-end app is not the main goal of this book, I won&amp;rsquo;t show how to build such an app from scratch. Instead, I&amp;rsquo;ll show how to use MetaMask to interact with smart contracts.
If you want to experiment with the app and run it locally, you can fund it in the ui folder in the code repo.</description></item></channel></rss>