<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Milestone 2. Second Swap on Uniswap V3 Development Book</title><link>https://uniswapv3book.com/docs/milestone_2/</link><description>Recent content in Milestone 2. Second Swap on Uniswap V3 Development Book</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://uniswapv3book.com/docs/milestone_2/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction</title><link>https://uniswapv3book.com/docs/milestone_2/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/introduction/</guid><description>Second Swap # Alright, this is where it gets real. So far, our implementation has been looking too synthetic and static. We have calculated and hard coded all the amounts to make the learning curve less steep, and now we&amp;rsquo;re ready to make it dynamic. We&amp;rsquo;re going to implement the second swap, that is a swap in the opposite direction: sell ETH to buy USDC. To do this, we&amp;rsquo;re going to improve our smart contracts significantly:</description></item><item><title>Output Amount Calculation</title><link>https://uniswapv3book.com/docs/milestone_2/output-amount-calculation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/output-amount-calculation/</guid><description>Output Amount Calculation # Our collection of Uniswap math formulas lacks a final piece: the formula of calculating the output amount when selling ETH (that is: selling token $x$). In the previous milestone, we had an analogous formula for the scenario when ETH is bought (buying token $x$):
$$\Delta \sqrt{P} = \frac{\Delta y}{L}$$
This formula finds the change in the price when selling token $y$. We then added this change to the current price to find the target price:</description></item><item><title>Math in Solidity</title><link>https://uniswapv3book.com/docs/milestone_2/math-in-solidity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/math-in-solidity/</guid><description>Math in Solidity # Due to Solidity not supporting numbers with th fractional part, math in Solidity is somewhat complicated. Solidity gives us integer and unsigned integer types, which are not enough for for more or less complex math calculations.
Another difficulty is gas consumption: the more complex an algorithm, the more gas it consumes. Thus, if we need to have advanced math operations (like exp, ln, sqrt), we want them to be as gas efficient as possible.</description></item><item><title>Tick Bitmap Index</title><link>https://uniswapv3book.com/docs/milestone_2/tick-bitmap-index/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/tick-bitmap-index/</guid><description>Tick Bitmap Index # As the first step towards dynamic swaps, we need to implement an index of ticks. In the previous milestone, we used to calculate the target tick when making a swap:
function swap(address recipient, bytes calldata data) public returns (int256 amount0, int256 amount1) { int24 nextTick = 85184; ... } When there&amp;rsquo;s liquidity provided in different price ranges, we cannot simply calculate the target tick.</description></item><item><title>Generalize Minting</title><link>https://uniswapv3book.com/docs/milestone_2/generalize-minting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/generalize-minting/</guid><description>Generalize Minting # Now, we&amp;rsquo;re ready to update mint function so we don&amp;rsquo;t need to hard code values anymore and can calculate them instead.
Indexing Initialized Ticks # Recall that, in the mint function, we update the TickInfo mapping to store information about available liquidity at ticks. Now, we also need to index newly initialized ticks in the bitmap indexâ€“we&amp;rsquo;ll later use this index to find next initialized tick during swapping.</description></item><item><title>Generalize Swapping</title><link>https://uniswapv3book.com/docs/milestone_2/generalize-swapping/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/generalize-swapping/</guid><description>Generalize Swapping # This will be the hardest chapter of this milestone. Before updating the code, we need to understand how the algorithm of swapping in Uniswap V3 works.
You can think of a swap as of filling of an order: a user submits an order to buy a specified amount of tokens from a pool. The pool will use the available liquidity to &amp;ldquo;convert&amp;rdquo; the input amount into an output amount of the other token.</description></item><item><title>Quoter Contract</title><link>https://uniswapv3book.com/docs/milestone_2/quoter-contract/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/quoter-contract/</guid><description>Quoter Contract # To integrate our updated Pool contract into the front end app, we need a way to calculate swap amounts without making a swap. Users will type in the amount they want to sell, and we want to calculate and show them the amount they&amp;rsquo;ll get in exchange. We&amp;rsquo;ll do this through Quoter contract.
Since liquidity in Uniswap V3 is scattered over multiple price ranges, we cannot calculate swap amounts with a formula (which was possible in Uniswap V2).</description></item><item><title>User Interface</title><link>https://uniswapv3book.com/docs/milestone_2/user-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/user-interface/</guid><description>User Interface # Let&amp;rsquo;s make our web app work more like a real DEX. We can now remove hardcoded swap amounts and let users type arbitrary amounts. Moreover, we can now let users swap in both direction, so we also need a button to swap the token inputs. After updating, the swap form will look like:
&amp;lt;form className=&amp;#34;SwapForm&amp;#34;&amp;gt; &amp;lt;SwapInput amount={zeroForOne ? amount0 : amount1} disabled={!enabled || loading} readOnly={false} setAmount={setAmount_(zeroForOne ?</description></item></channel></rss>