<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Tick Bitmap Index #  As the first step towards dynamic swaps, we need to implement an index of ticks. In the previous milestone, we used to calculate the target tick when making a swap:
function swap(address recipient, bytes calldata data)  public  returns (int256 amount0, int256 amount1) {  int24 nextTick = 85184;  ... } When there&rsquo;s liquidity provided in different price ranges, we cannot simply calculate the target tick."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Tick Bitmap Index"><meta property="og:description" content="Tick Bitmap Index #  As the first step towards dynamic swaps, we need to implement an index of ticks. In the previous milestone, we used to calculate the target tick when making a swap:
function swap(address recipient, bytes calldata data)  public  returns (int256 amount0, int256 amount1) {  int24 nextTick = 85184;  ... } When there&rsquo;s liquidity provided in different price ranges, we cannot simply calculate the target tick."><meta property="og:type" content="article"><meta property="og:url" content="https://uniswapv3book.com/docs/milestone_2/tick-bitmap-index/"><meta property="article:section" content="docs"><title>Tick Bitmap Index | Uniswap V3 Development Book</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.4fbe0b321bb16d3ea7a51c7988385215a9c3ac0b18ebcf99ed624bb68bc78c16.js integrity="sha256-T74LMhuxbT6npRx5iDhSFanDrAsY68+Z7WJLtovHjBY=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Uniswap V3 Development Book</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Milestone 0</span><ul><li><a href=/docs/introduction/amm/>Introduction to markets</a></li><li><a href=/docs/introduction/cfmm/>Constant Function Market Makers</a></li><li><a href=/docs/introduction/uniswap-v3/>Uniswap V3</a></li><li><a href=/docs/introduction/dev-environment/>Development Environment</a></li></ul></li><li class=book-section-flat><span>Milestone 1. First Swap</span><ul><li><a href=/docs/milestone_1/introduction/>Introduction</a></li><li><a href=/docs/milestone_1/calculating-liquidity/>Calculating Liquidity</a></li><li><a href=/docs/milestone_1/providing-liquidity/>Providing Liquidity</a></li><li><a href=/docs/milestone_1/first-swap/>First Swap</a></li><li><a href=/docs/milestone_1/manager-contract/>Manager Contract</a></li><li><a href=/docs/milestone_1/deployment/>Deployment</a></li><li><a href=/docs/milestone_1/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 2. Second Swap</span><ul><li><a href=/docs/milestone_2/introduction/>Introduction</a></li><li><a href=/docs/milestone_2/output-amount-calculation/>Output Amount Calculation</a></li><li><a href=/docs/milestone_2/math-in-solidity/>Math in Solidity</a></li><li><a href=/docs/milestone_2/tick-bitmap-index/ class=active>Tick Bitmap Index</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Tick Bitmap Index</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#tick-bitmap-index>Tick Bitmap Index</a><ul><li><a href=#bitmap>Bitmap</a></li><li><a href=#tickbitmap-contract>TickBitmap Contract</a><ul><li><a href=#flipping-flags>Flipping Flags</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=tick-bitmap-index>Tick Bitmap Index
<a class=anchor href=#tick-bitmap-index>#</a></h1><p>As the first step towards dynamic swaps, we need to implement an index of ticks. In the previous milestone, we used to
calculate the target tick when making a swap:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>swap</span>(<span style=color:#66d9ef>address</span> recipient, <span style=color:#66d9ef>bytes</span> calldata data)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>int256</span> amount0, <span style=color:#66d9ef>int256</span> amount1)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int24</span> nextTick <span style=color:#f92672>=</span> <span style=color:#ae81ff>85184</span>;
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>When there&rsquo;s liquidity provided in different price ranges, we cannot simply calculate the target tick. We need to <strong>find
it</strong> depending on the amount of liquidity in different price ranges. Thus, we need to index all ticks that have liquidity
and then use the index to find ticks to &ldquo;fill&rdquo; enough liquidity for a swap. In this step, we&rsquo;re going to implement such
index.</p><h2 id=bitmap>Bitmap
<a class=anchor href=#bitmap>#</a></h2><p>Bitmap is a popular technique of indexing data in a compact way. A bitmap is simply an array of zeros and ones, where
each element as and index and corresponds to some external entity (something that&rsquo;s indexed). Each element can be a zero
or a one, which can be seemed as setting a flag: when 0, flag is not set; when 1, flag is set. What makes this approach
favorable is that the whole array can be stored as a single number in the binary number system!</p><p>For example, the array <code>111101001101001</code> is number 31337. The number takes two bytes (0x7a69) and two bytes can store 16
flags (1 byte = 8 bits).</p><p>Uniswap V3 uses this technique to store the information about initialized ticks, that is ticks with some liquidity. When
a flag is set (1), the tick has liquidity; when flag is not set (0), the tick is not initialized. Let&rsquo;s review the
implementation.</p><h2 id=tickbitmap-contract>TickBitmap Contract
<a class=anchor href=#tickbitmap-contract>#</a></h2><p>In the pool contract, the tick index is stored in a state variable:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>contract</span> <span style=color:#a6e22e>UniswapV3Pool</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>using</span> TickBitmap <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>int16</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>uint256</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>int16</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>uint256</span>) <span style=color:#66d9ef>public</span> tickBitmap;
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is mapping where keys are <code>int16</code>&rsquo;s and values are words (<code>uint256</code>). Imagine an infinite continuous array of ones
and zeros:</p><p>[TODO: add illustration]</p><p>Each element in this array corresponds to a tick. To navigate in this array, we break it into words: sub-arrays of
length 256 bits. To find tick&rsquo;s position in this array, we do:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>position</span>(<span style=color:#66d9ef>int24</span> tick) <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>pure</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>int16</span> wordPos, <span style=color:#66d9ef>uint8</span> bitPos) {
</span></span><span style=display:flex><span>    wordPos <span style=color:#f92672>=</span> <span style=color:#66d9ef>int16</span>(tick <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>    bitPos <span style=color:#f92672>=</span> <span style=color:#66d9ef>uint8</span>(<span style=color:#66d9ef>uint24</span>(tick <span style=color:#f92672>%</span> <span style=color:#ae81ff>256</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That is: we find its word position and then its bit in this word. <code>>> 8</code> is identical to division by 256. So, word
position is the integer part of tick index divided by 256, and bit position is the remainder.</p><p>As an example, let&rsquo;s calculate word and bit positions for one of our ticks:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>tick <span style=color:#f92672>=</span> <span style=color:#ae81ff>85176</span>
</span></span><span style=display:flex><span>word_pos <span style=color:#f92672>=</span> tick <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>8</span> <span style=color:#75715e># or tick // 2**8</span>
</span></span><span style=display:flex><span>bit_pos <span style=color:#f92672>=</span> tick <span style=color:#f92672>%</span> <span style=color:#ae81ff>256</span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Word </span><span style=color:#e6db74>{</span>word_pos<span style=color:#e6db74>}</span><span style=color:#e6db74>, bit </span><span style=color:#e6db74>{</span>bit_pos<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#75715e># Word 332, bit 184</span>
</span></span></code></pre></div><h3 id=flipping-flags>Flipping Flags
<a class=anchor href=#flipping-flags>#</a></h3><p>When adding liquidity into a pool, we need to set a couple of tick flags in the bitmap: one for the lower tick and one
for the upper tick. We do this in <code>flipTick</code> method of the bitmap mapping:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>flipTick</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>int16</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>uint256</span>) <span style=color:#66d9ef>storage</span> self,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> tick,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> tickSpacing
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>internal</span> {
</span></span><span style=display:flex><span>    require(tick <span style=color:#f92672>%</span> tickSpacing <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>); <span style=color:#75715e>// ensure that the tick is spaced
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    (<span style=color:#66d9ef>int16</span> wordPos, <span style=color:#66d9ef>uint8</span> bitPos) <span style=color:#f92672>=</span> position(tick <span style=color:#f92672>/</span> tickSpacing);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> mask <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> bitPos;
</span></span><span style=display:flex><span>    self[wordPos] <span style=color:#f92672>^=</span> mask;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>Until later in the book, <code>tickSpacing</code> is always 1.</p></blockquote><p>After finding word and bit positions, we need to make a mask. A mask is a number that has a single 1 flag set at the
bit position of the tick. To find the mask, we simply calculate <code>2**bit_pos</code> (equivalent of <code>1 &lt;&lt; bit_pos</code>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>mask <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>**</span>bit_pos <span style=color:#75715e># or 1 &lt;&lt; bit_pos</span>
</span></span><span style=display:flex><span>print(bin(mask))
</span></span><span style=display:flex><span><span style=color:#75715e>#0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span>
</span></span></code></pre></div><p>Next, to flip a flag, we apply the mask to the tick&rsquo;s word via bitwise XOR:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>word <span style=color:#f92672>=</span> (<span style=color:#ae81ff>2</span><span style=color:#f92672>**</span><span style=color:#ae81ff>256</span>) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e># set word to all ones</span>
</span></span><span style=display:flex><span>print(bin(word <span style=color:#f92672>^</span> mask))
</span></span><span style=display:flex><span><span style=color:#75715e>#0b11111111111111111111111111111111111111111111111111111111111111111111111-&gt;0&lt;-1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111</span>
</span></span></code></pre></div><p>You&rsquo;ll see that 184th bit (counting from the right starting at 0) has flipped to 0.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#tick-bitmap-index>Tick Bitmap Index</a><ul><li><a href=#bitmap>Bitmap</a></li><li><a href=#tickbitmap-contract>TickBitmap Contract</a><ul><li><a href=#flipping-flags>Flipping Flags</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>