<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Cross-Tick Swaps #  Cross-tick swaps is probably the most advanced feature of Uniswap V3. Luckily, we have already implemented almost everything we need to make cross-tick swaps. Let&rsquo;s see how cross-tick swaps work before implementing them.
How Cross-Tick Swaps Work #  A common Uniswap V3 pool is a pool with many overlapping (and outstanding) price ranges. Each pool tracks current $\sqrt{P}$ and tick. When users swap tokens they move current price and tick to the left or to the right, depending on swap direction."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Cross-Tick Swaps"><meta property="og:description" content="Cross-Tick Swaps #  Cross-tick swaps is probably the most advanced feature of Uniswap V3. Luckily, we have already implemented almost everything we need to make cross-tick swaps. Let&rsquo;s see how cross-tick swaps work before implementing them.
How Cross-Tick Swaps Work #  A common Uniswap V3 pool is a pool with many overlapping (and outstanding) price ranges. Each pool tracks current $\sqrt{P}$ and tick. When users swap tokens they move current price and tick to the left or to the right, depending on swap direction."><meta property="og:type" content="article"><meta property="og:url" content="https://uniswapv3book.com/docs/milestone_3/cross-tick-swaps/"><meta property="article:section" content="docs"><title>Cross-Tick Swaps | Uniswap V3 Development Book</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.67118a5934284ceffb3063bf8fdcb3382918a181732dcfb0703e858811348f69.js integrity="sha256-ZxGKWTQoTO/7MGO/j9yzOCkYoYFzLc+wcD6FiBE0j2k=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Uniswap V3 Development Book</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Milestone 0. Introduction</span><ul><li><a href=/docs/introduction/introduction-to-markets/>Introduction to Markets</a></li><li><a href=/docs/introduction/constant-function-market-maker/>Constant Function Market Makers</a></li><li><a href=/docs/introduction/uniswap-v3/>Uniswap V3</a></li><li><a href=/docs/introduction/dev-environment/>Development Environment</a></li><li><a href=/docs/introduction/what-we-will-build/>What We'll Build</a></li></ul></li><li class=book-section-flat><span>Milestone 1. First Swap</span><ul><li><a href=/docs/milestone_1/introduction/>Introduction</a></li><li><a href=/docs/milestone_1/calculating-liquidity/>Calculating Liquidity</a></li><li><a href=/docs/milestone_1/providing-liquidity/>Providing Liquidity</a></li><li><a href=/docs/milestone_1/first-swap/>First Swap</a></li><li><a href=/docs/milestone_1/manager-contract/>Manager Contract</a></li><li><a href=/docs/milestone_1/deployment/>Deployment</a></li><li><a href=/docs/milestone_1/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 2. Second Swap</span><ul><li><a href=/docs/milestone_2/introduction/>Introduction</a></li><li><a href=/docs/milestone_2/output-amount-calculation/>Output Amount Calculation</a></li><li><a href=/docs/milestone_2/math-in-solidity/>Math in Solidity</a></li><li><a href=/docs/milestone_2/tick-bitmap-index/>Tick Bitmap Index</a></li><li><a href=/docs/milestone_2/generalize-minting/>Generalize Minting</a></li><li><a href=/docs/milestone_2/generalize-swapping/>Generalize Swapping</a></li><li><a href=/docs/milestone_2/quoter-contract/>Quoter Contract</a></li><li><a href=/docs/milestone_2/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 3. Cross-tick Swaps</span><ul><li><a href=/docs/milestone_3/introduction/>Introduction</a></li><li><a href=/docs/milestone_3/different-ranges/>Different Price Ranges</a></li><li><a href=/docs/milestone_3/cross-tick-swaps/ class=active>Cross-Tick Swaps</a></li><li><a href=/docs/milestone_3/slippage-protection/>Slippage Protection</a></li><li><a href=/docs/milestone_3/liquidity-calculation/>Liquidity Calculation</a></li><li><a href=/docs/milestone_3/more-on-fixed-point-numbers/>A Little Bit More on Fixed-point Numbers</a></li><li><a href=/docs/milestone_3/flash-loans/>Flash Loans</a></li><li><a href=/docs/milestone_3/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 4. Multi-pool Swaps</span><ul><li><a href=/docs/milestone_4/introduction/>Introduction</a></li><li><a href=/docs/milestone_4/factory-contract/>Factory Contract</a></li><li><a href=/docs/milestone_4/path/>Swap Path</a></li><li><a href=/docs/milestone_4/multi-pool-swaps/>Multi-pool Swaps</a></li><li><a href=/docs/milestone_4/user-interface/>User Interface</a></li><li><a href=/docs/milestone_4/tick-rounding/>Tick Rounding</a></li></ul></li><li class=book-section-flat><span>Milestone 5. Fees and Price Oracle</span><ul><li><a href=/docs/milestone_5/introduction/>Introduction</a></li><li><a href=/docs/milestone_5/swap-fees/>Swap Fees</a></li><li><a href=/docs/milestone_5/flash-loan-fees/>Flash Loan Fees</a></li><li><a href=/docs/milestone_5/protocol-fees/>Protocol Fees</a></li><li><a href=/docs/milestone_5/price-oracle/>Price Oracle</a></li><li><a href=/docs/milestone_5/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 6: NFT positions</span><ul><li><a href=/docs/milestone_6/introduction/>Introduction</a></li><li><a href=/docs/milestone_6/erc721-overview/>ERC721 Overview</a></li><li><a href=/docs/milestone_6/nft-manager/>NFT Manager</a></li><li><a href=/docs/milestone_6/nft-renderer/>NFT Renderer</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Cross-Tick Swaps</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#cross-tick-swaps>Cross-Tick Swaps</a><ul><li><a href=#how-cross-tick-swaps-work>How Cross-Tick Swaps Work</a></li><li><a href=#updating-computeswapstep-function>Updating <code>computeSwapStep</code> Function</a></li><li><a href=#updating-swap-function>Updating <code>swap</code> Function</a></li><li><a href=#liquidity-tracking-and-ticks-crossing>Liquidity Tracking and Ticks Crossing</a></li><li><a href=#testing>Testing</a><ul><li><a href=#one-price-range>One Price Range</a></li><li><a href=#multiple-identical-and-overlapping-price-ranges>Multiple Identical and Overlapping Price Ranges</a></li><li><a href=#consecutive-price-ranges>Consecutive Price Ranges</a></li><li><a href=#partially-overlapping-price-ranges>Partially Overlapping Price Ranges</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=cross-tick-swaps>Cross-Tick Swaps
<a class=anchor href=#cross-tick-swaps>#</a></h1><p>Cross-tick swaps is probably the most advanced feature of Uniswap V3. Luckily, we have already implemented almost everything
we need to make cross-tick swaps. Let&rsquo;s see how cross-tick swaps work before implementing them.</p><h2 id=how-cross-tick-swaps-work>How Cross-Tick Swaps Work
<a class=anchor href=#how-cross-tick-swaps-work>#</a></h2><p>A common Uniswap V3 pool is a pool with many overlapping (and outstanding) price ranges. Each pool tracks current $\sqrt{P}$
and tick. When users swap tokens they move current price and tick to the left or to the right, depending on swap direction.
These movements are caused by tokens being added and removed from pools during swaps.</p><p>Pools also track $L$ (<code>liquidity</code> variable in our code), which is <strong>the total liquidity provided by all price ranges
that include current price</strong>. It&rsquo;s expected that, during big price moves, current price moves outside of price ranges.
When this happens, such price ranges become inactive and their liquidity gets subtracted from $L$. On the other hand,
when current price enters a price range, $L$ is increased and the price range gets activated.</p><p>Let&rsquo;s analyze this illustration:</p><p><img src=/images/milestone_3/price_range_dynamics.png alt="The dynamic of price ranges"></p><p>There are three price ranges on this image. The top one is the one currently engaged, it includes the current price. The
liquidity of this price range is set to the <code>liquidity</code> state variable of the Pool contract.</p><p>If we buy all the ETH from the top price range, the price will increase and we&rsquo;ll move to the right price range, which at
this moment contains only ETH, not USDC. We might stop in this price range if there&rsquo;s enough liquidity to satisfy our demand.
In this case, the <code>liquidity</code> variable will contain only the liquidity provided by this price range. If we continue buying
ETH and deplete the right price range, we&rsquo;ll need another price range that&rsquo;s to the right of this price range. If there
are no more price ranges, we&rsquo;ll have to stop, and our swap will be satisfied only partially.</p><p>If we buy all the USDC from the top price range (and sell ETH), the price will decrease and we&rsquo;ll move to the left price
range–at this moment it contains only USDC. If we deplete it, we&rsquo;ll need another price range to the left of it.</p><p>The current price moves during swapping. It moves from one price range to another, but it must always stay within a price
range–otherwise, trading is not possible.</p><p>Of course, price ranges can overlap, so, in practice, the transition between price ranges is seamless. And it&rsquo;s not
possible to hop over a gap–a swap would be completed partially. It&rsquo;s also worth noting that, in the areas where price ranges
overlap, price moves slower. This is due to the fact that supply is higher in such areas and the effect of demand is
lower (recall from the introduction that high demand with low supply increases the price).</p><p>Our current implementation doesn&rsquo;t support such fluidity: we only allow swaps within one active price range. This is what
we&rsquo;re going to improve now.</p><h2 id=updating-computeswapstep-function>Updating <code>computeSwapStep</code> Function
<a class=anchor href=#updating-computeswapstep-function>#</a></h2><p>In the <code>swap</code> function, we&rsquo;re iterating over initialized ticks (that is, ticks with liquidity) to fill the amount the
user has requested. In each iteration, we:</p><ol><li>find next initialized tick using <code>tickBitmap.nextInitializedTickWithinOneWord</code>;</li><li>swap in the range between the current price and the next initialized tick (using <code>SwapMath.computeSwapStep</code>);</li><li>always expect that current liquidity is enough to satisfy the swap (i.e. the price after swap is between the current
price and the next initialized tick).</li></ol><p>But what happens if the third step is not true? We have this scenario covered in tests:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// test/UniswapV3Pool.t.sol
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>testSwapBuyEthNotEnoughLiquidity</span>() <span style=color:#66d9ef>public</span> {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> swapAmount <span style=color:#f92672>=</span> <span style=color:#ae81ff>5300</span> <span style=color:#66d9ef>ether</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    vm.expectRevert(stdError.arithmeticError);
</span></span><span style=display:flex><span>    pool.swap(<span style=color:#66d9ef>address</span>(this), <span style=color:#66d9ef>false</span>, swapAmount, extra);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The &ldquo;Arithmetic over/underflow&rdquo; happens when the pool tries to send us more ether than it has. This error happens because,
in our current implementation, we always expect that there&rsquo;s enough liquidity to satisfy any swap:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// src/lib/SwapMath.sol
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>computeSwapStep</span>(...) {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sqrtPriceNextX96 <span style=color:#f92672>=</span> Math.getNextSqrtPriceFromInput(
</span></span><span style=display:flex><span>        sqrtPriceCurrentX96,
</span></span><span style=display:flex><span>        liquidity,
</span></span><span style=display:flex><span>        amountRemaining,
</span></span><span style=display:flex><span>        zeroForOne
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    amountIn <span style=color:#f92672>=</span> ...
</span></span><span style=display:flex><span>    amountOut <span style=color:#f92672>=</span> ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To improve this, we need to consider several situations:</p><ol><li>when the range between the current and the next ticks has enough liquidity to fill <code>amountRemaining</code>;</li><li>when the range doesn&rsquo;t fill the entire <code>amountRemaining</code>.</li></ol><p>In the first case, the swap is done entirely within the range–this is the scenario we have implemented. In the second
situation, we&rsquo;ll consume the whole liquidity provided by the range and <strong>will move to the next range</strong> (if it exists).
With this in mind, let&rsquo;s rework <code>computeSwapStep</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// src/lib/SwapMath.sol
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>computeSwapStep</span>(...) {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    amountIn <span style=color:#f92672>=</span> zeroForOne
</span></span><span style=display:flex><span>        <span style=color:#f92672>?</span> Math.calcAmount0Delta(
</span></span><span style=display:flex><span>            sqrtPriceCurrentX96,
</span></span><span style=display:flex><span>            sqrtPriceTargetX96,
</span></span><span style=display:flex><span>            liquidity
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> Math.calcAmount1Delta(
</span></span><span style=display:flex><span>            sqrtPriceCurrentX96,
</span></span><span style=display:flex><span>            sqrtPriceTargetX96,
</span></span><span style=display:flex><span>            liquidity
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (amountRemaining <span style=color:#f92672>&gt;=</span> amountIn) sqrtPriceNextX96 <span style=color:#f92672>=</span> sqrtPriceTargetX96;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        sqrtPriceNextX96 <span style=color:#f92672>=</span> Math.getNextSqrtPriceFromInput(
</span></span><span style=display:flex><span>            sqrtPriceCurrentX96,
</span></span><span style=display:flex><span>            liquidity,
</span></span><span style=display:flex><span>            amountRemaining,
</span></span><span style=display:flex><span>            zeroForOne
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    amountIn <span style=color:#f92672>=</span> Math.calcAmount0Delta(
</span></span><span style=display:flex><span>        sqrtPriceCurrentX96,
</span></span><span style=display:flex><span>        sqrtPriceNextX96,
</span></span><span style=display:flex><span>        liquidity
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    amountOut <span style=color:#f92672>=</span> Math.calcAmount1Delta(
</span></span><span style=display:flex><span>        sqrtPriceCurrentX96,
</span></span><span style=display:flex><span>        sqrtPriceNextX96,
</span></span><span style=display:flex><span>        liquidity
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>First, we calculate <code>amountIn</code>–the input amount the current range can satisfy. If it&rsquo;s smaller than <code>amountRemaining</code>,
we say that the current price range cannot fulfil the whole swap, thus the next $\sqrt{P}$ is the upper/lower $\sqrt{P}$
of the price range (in other words, we use the entire liquidity of the price range). If <code>amountIn</code> is greater than
<code>amountRemaining</code>, we compute <code>sqrtPriceNextX96</code>–it&rsquo;ll be a price within the current price range.</p><p>In the end, after figuring the next price, we re-compute <code>amountIn</code> and compute <code>amountOut</code> withing this shorter price range
(we don&rsquo;t consume the entire liquidity).</p><p>I hope this makes sense!</p><h2 id=updating-swap-function>Updating <code>swap</code> Function
<a class=anchor href=#updating-swap-function>#</a></h2><p>Now, in <code>swap</code> function, we need to handle the case we introduced in the previous part: when swap price reaches a boundary
of a price range. When this happens, we want to deactivate the price range we&rsquo;re leaving and active the next price range.
We also want to start another iteration of the loop and try to find another tick with liquidity.</p><p>Here&rsquo;s what we need to add to the end of the loop:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>if</span> (state.sqrtPriceX96 <span style=color:#f92672>==</span> step.sqrtPriceNextX96) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int128</span> liquidityDelta <span style=color:#f92672>=</span> ticks.cross(step.nextTick);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (zeroForOne) liquidityDelta <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>liquidityDelta;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    state.liquidity <span style=color:#f92672>=</span> LiquidityMath.addLiquidity(
</span></span><span style=display:flex><span>        state.liquidity,
</span></span><span style=display:flex><span>        liquidityDelta
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (state.liquidity <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) revert NotEnoughLiquidity();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    state.tick <span style=color:#f92672>=</span> zeroForOne <span style=color:#f92672>?</span> step.nextTick <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> step.nextTick;
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    state.tick <span style=color:#f92672>=</span> TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The second branch is what we had before–it handles the case when current price stays within the range. So let&rsquo;s focus on
the first one.</p><p><code>state.sqrtPriceX96</code> is the new current price, i.e. the price that will be set after the current swap; <code>step.sqrtPriceNextX96</code>
is the price at the next initialized tick. If these are equal, we have reached a price range boundary. As explained above,
when this happens, we want to update $L$ (add or remove liquidity) and continue the swap using the boundary tick as the
current tick.</p><p>By convention, crossing a tick means crossing it from left to right. Thus, crossing lower ticks always adds liquidity and
crossing upper ticks always removes it. However, when <code>zeroForOne</code> is true, we negate the sign: when price goes down
(token $x$ is being sold), upper ticks add liquidity and lower ticks remove it.</p><p>When updating <code>state.tick</code>, if price moves down (<code>zeroForOne</code> is true), we need to subtract 1 to step out of the price
range. When moving up (<code>zeroForOne</code> is false), current tick is always excluded in <code>TickBitmap.nextInitializedTickWithinOneWord</code>.</p><p>Another small, but very important, change that we need to make is to update $L$ when crossing a tick. We do this after
the loop:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>if</span> (liquidity_ <span style=color:#f92672>!=</span> state.liquidity) liquidity <span style=color:#f92672>=</span> state.liquidity;
</span></span></code></pre></div><p>Within the loop, we update <code>state.liquidity</code> multiple times when entering/leaving price ranges. After a swap, we need
to update the global $L$ for it to reflect the liquidity available at the new current price. Also, the reason why we only update the global variable when finishing the swap is also gas consumption optimization, since writing global variable is really an expensive operation!</p><h2 id=liquidity-tracking-and-ticks-crossing>Liquidity Tracking and Ticks Crossing
<a class=anchor href=#liquidity-tracking-and-ticks-crossing>#</a></h2><p>Let&rsquo;s now look at updated <code>Tick</code> library.</p><p>First change is in <code>Tick.Info</code> structure: we now have two variables to track tick liquidity:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Info</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> initialized;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// total liquidity at tick
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>uint128</span> liquidityGross;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// amount of liqudiity added or subtracted when tick is crossed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int128</span> liquidityNet;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>liquidityGross</code> tracks the absolute liquidity amount of a tick. It&rsquo;s needed to find if tick was flipped or not. <code>liquidityNet</code>,
on the other hand, is a signed integer–it tracks the amount of liquidity added (in case of lower tick) or removed
(in case of upper tick) when a tick is crossed.</p><p><code>liquidityNet</code> is set in <code>update</code> function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>update</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>int24</span> <span style=color:#f92672>=&gt;</span> Tick.Info) <span style=color:#66d9ef>storage</span> self,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> tick,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int128</span> liquidityDelta,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> upper
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>bool</span> flipped) {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    tickInfo.liquidityNet <span style=color:#f92672>=</span> upper
</span></span><span style=display:flex><span>        <span style=color:#f92672>?</span> <span style=color:#66d9ef>int128</span>(<span style=color:#66d9ef>int256</span>(tickInfo.liquidityNet) <span style=color:#f92672>-</span> liquidityDelta)
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> <span style=color:#66d9ef>int128</span>(<span style=color:#66d9ef>int256</span>(tickInfo.liquidityNet) <span style=color:#f92672>+</span> liquidityDelta);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>cross</code> function we saw above simply returns <code>liquidityNet</code> (it&rsquo;ll get more complicated after we introduce new
features in later milestones):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>cross</span>(<span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>int24</span> <span style=color:#f92672>=&gt;</span> Tick.Info) <span style=color:#66d9ef>storage</span> self, <span style=color:#66d9ef>int24</span> tick)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>internal</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>view</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>int128</span> liquidityDelta)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Tick.Info <span style=color:#66d9ef>storage</span> info <span style=color:#f92672>=</span> self[tick];
</span></span><span style=display:flex><span>    liquidityDelta <span style=color:#f92672>=</span> info.liquidityNet;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=testing>Testing
<a class=anchor href=#testing>#</a></h2><p>Let&rsquo;s review different liquidity set ups and test them to ensure our pool implementation can handle them correctly.</p><h3 id=one-price-range>One Price Range
<a class=anchor href=#one-price-range>#</a></h3><p><img src=/images/milestone_3/swap_within_price_range.png alt="Swap within price range"></p><p>This is the scenario we had earlier. After we have updated the code, we need to ensure old functionality keeps working
correctly.</p><blockquote><p>For brevity, I&rsquo;ll show only most important parts of the tests. You can find full tests in <a href=https://github.com/Jeiwan/uniswapv3-code/blob/milestone_3/test/UniswapV3Pool.Swaps.t.sol>the code repo</a>.</p></blockquote><ul><li>When buying ETH:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>testBuyETHOnePriceRange</span>() <span style=color:#66d9ef>public</span> {
</span></span><span style=display:flex><span>    LiquidityRange[] <span style=color:#66d9ef>memory</span> liquidity <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LiquidityRange[](<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    liquidity[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> liquidityRange(<span style=color:#ae81ff>4545</span>, <span style=color:#ae81ff>5500</span>, <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>ether</span>, <span style=color:#ae81ff>5000</span> <span style=color:#66d9ef>ether</span>, <span style=color:#ae81ff>5000</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>int256</span> expectedAmount0Delta, <span style=color:#66d9ef>int256</span> expectedAmount1Delta) <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>        <span style=color:#f92672>-</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>008396874645169943</span> <span style=color:#66d9ef>ether</span>,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>42</span> <span style=color:#66d9ef>ether</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    assertSwapState(
</span></span><span style=display:flex><span>        ExpectedStateAfterSwap({
</span></span><span style=display:flex><span>            ...
</span></span><span style=display:flex><span>            sqrtPriceX96<span style=color:#f92672>:</span> <span style=color:#ae81ff>5604415652688968742392013927525</span>, <span style=color:#75715e>// 5003.8180249710795
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            tick<span style=color:#f92672>:</span> <span style=color:#ae81ff>85183</span>,
</span></span><span style=display:flex><span>            currentLiquidity<span style=color:#f92672>:</span> liquidity[<span style=color:#ae81ff>0</span>].amount
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li>When buying USDC:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>testBuyUSDCOnePriceRange</span>() <span style=color:#66d9ef>public</span> {
</span></span><span style=display:flex><span>    LiquidityRange[] <span style=color:#66d9ef>memory</span> liquidity <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LiquidityRange[](<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    liquidity[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> liquidityRange(<span style=color:#ae81ff>4545</span>, <span style=color:#ae81ff>5500</span>, <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>ether</span>, <span style=color:#ae81ff>5000</span> <span style=color:#66d9ef>ether</span>, <span style=color:#ae81ff>5000</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>int256</span> expectedAmount0Delta, <span style=color:#66d9ef>int256</span> expectedAmount1Delta) <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>01337</span> <span style=color:#66d9ef>ether</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>-</span><span style=color:#ae81ff>66</span>.<span style=color:#ae81ff>807123823853842027</span> <span style=color:#66d9ef>ether</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    assertSwapState(
</span></span><span style=display:flex><span>        ExpectedStateAfterSwap({
</span></span><span style=display:flex><span>            ...
</span></span><span style=display:flex><span>            sqrtPriceX96<span style=color:#f92672>:</span> <span style=color:#ae81ff>5598737223630966236662554421688</span>, <span style=color:#75715e>// 4993.683362269102
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            tick<span style=color:#f92672>:</span> <span style=color:#ae81ff>85163</span>,
</span></span><span style=display:flex><span>            currentLiquidity<span style=color:#f92672>:</span> liquidity[<span style=color:#ae81ff>0</span>].amount
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><p>In both of these scenario we buy a small amount of ETH or USDC–it needs to be small enough for the price to not leave
the only price range we created. Key values after swapping is done:</p><ol><li><code>sqrtPriceX96</code> is slightly above or below the initial price and stays within the price rage;</li><li><code>currentLiquidity</code> remains unchanged.</li></ol><h3 id=multiple-identical-and-overlapping-price-ranges>Multiple Identical and Overlapping Price Ranges
<a class=anchor href=#multiple-identical-and-overlapping-price-ranges>#</a></h3><p><img src=/images/milestone_3/swap_within_overlapping_price_ranges.png alt="Swap within overlapping ranges"></p><ul><li><p>When buying ETH:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>testBuyETHTwoEqualPriceRanges</span>() <span style=color:#66d9ef>public</span> {
</span></span><span style=display:flex><span>    LiquidityRange <span style=color:#66d9ef>memory</span> range <span style=color:#f92672>=</span> liquidityRange(
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>4545</span>,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>5500</span>,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>ether</span>,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>5000</span> <span style=color:#66d9ef>ether</span>,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>5000</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    LiquidityRange[] <span style=color:#66d9ef>memory</span> liquidity <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LiquidityRange[](<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    liquidity[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> range;
</span></span><span style=display:flex><span>    liquidity[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> range;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>int256</span> expectedAmount0Delta, <span style=color:#66d9ef>int256</span> expectedAmount1Delta) <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>        <span style=color:#f92672>-</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>008398516982770993</span> <span style=color:#66d9ef>ether</span>,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>42</span> <span style=color:#66d9ef>ether</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    assertSwapState(
</span></span><span style=display:flex><span>        ExpectedStateAfterSwap({
</span></span><span style=display:flex><span>            ...
</span></span><span style=display:flex><span>            sqrtPriceX96<span style=color:#f92672>:</span> <span style=color:#ae81ff>5603319704133145322707074461607</span>, <span style=color:#75715e>// 5001.861214026131
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            tick<span style=color:#f92672>:</span> <span style=color:#ae81ff>85179</span>,
</span></span><span style=display:flex><span>            currentLiquidity<span style=color:#f92672>:</span> liquidity[<span style=color:#ae81ff>0</span>].amount <span style=color:#f92672>+</span> liquidity[<span style=color:#ae81ff>1</span>].amount
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>When buying USDC:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>testBuyUSDCTwoEqualPriceRanges</span>() <span style=color:#66d9ef>public</span> {
</span></span><span style=display:flex><span>    LiquidityRange <span style=color:#66d9ef>memory</span> range <span style=color:#f92672>=</span> liquidityRange(
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>4545</span>,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>5500</span>,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>ether</span>,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>5000</span> <span style=color:#66d9ef>ether</span>,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>5000</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    LiquidityRange[] <span style=color:#66d9ef>memory</span> liquidity <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LiquidityRange[](<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    liquidity[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> range;
</span></span><span style=display:flex><span>    liquidity[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> range;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>int256</span> expectedAmount0Delta, <span style=color:#66d9ef>int256</span> expectedAmount1Delta) <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>01337</span> <span style=color:#66d9ef>ether</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>-</span><span style=color:#ae81ff>66</span>.<span style=color:#ae81ff>827918929906650442</span> <span style=color:#66d9ef>ether</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    assertSwapState(
</span></span><span style=display:flex><span>        ExpectedStateAfterSwap({
</span></span><span style=display:flex><span>            ...
</span></span><span style=display:flex><span>            sqrtPriceX96<span style=color:#f92672>:</span> <span style=color:#ae81ff>5600479946976371527693873969480</span>, <span style=color:#75715e>// 4996.792621611429
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            tick<span style=color:#f92672>:</span> <span style=color:#ae81ff>85169</span>,
</span></span><span style=display:flex><span>            currentLiquidity<span style=color:#f92672>:</span> liquidity[<span style=color:#ae81ff>0</span>].amount <span style=color:#f92672>+</span> liquidity[<span style=color:#ae81ff>1</span>].amount
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><p>This scenario is similar to the previous one but this time we create two identical price ranges. Since those are fully
overlapping price ranges, they in fact act as one price range with a higher amount of liquidity. Thus, the price changes
slower than in the previous scenario. Also, we get slightly more tokens thanks to deeper liquidity.</p><h3 id=consecutive-price-ranges>Consecutive Price Ranges
<a class=anchor href=#consecutive-price-ranges>#</a></h3><p><img src=/images/milestone_3/swap_consecutive_price_ranges.png alt="Swap over consecutive price ranges"></p><ul><li>When buying ETH:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>testBuyETHConsecutivePriceRanges</span>() <span style=color:#66d9ef>public</span> {
</span></span><span style=display:flex><span>    LiquidityRange[] <span style=color:#66d9ef>memory</span> liquidity <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LiquidityRange[](<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    liquidity[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> liquidityRange(<span style=color:#ae81ff>4545</span>, <span style=color:#ae81ff>5500</span>, <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>ether</span>, <span style=color:#ae81ff>5000</span> <span style=color:#66d9ef>ether</span>, <span style=color:#ae81ff>5000</span>);
</span></span><span style=display:flex><span>    liquidity[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> liquidityRange(<span style=color:#ae81ff>5500</span>, <span style=color:#ae81ff>6250</span>, <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>ether</span>, <span style=color:#ae81ff>5000</span> <span style=color:#66d9ef>ether</span>, <span style=color:#ae81ff>5000</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>int256</span> expectedAmount0Delta, <span style=color:#66d9ef>int256</span> expectedAmount1Delta) <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>        <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>.<span style=color:#ae81ff>820694594787485635</span> <span style=color:#66d9ef>ether</span>,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>10000</span> <span style=color:#66d9ef>ether</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    assertSwapState(
</span></span><span style=display:flex><span>        ExpectedStateAfterSwap({
</span></span><span style=display:flex><span>            ...
</span></span><span style=display:flex><span>            sqrtPriceX96<span style=color:#f92672>:</span> <span style=color:#ae81ff>6190476002219365604851182401841</span>, <span style=color:#75715e>// 6105.045728033458
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            tick<span style=color:#f92672>:</span> <span style=color:#ae81ff>87173</span>,
</span></span><span style=display:flex><span>            currentLiquidity<span style=color:#f92672>:</span> liquidity[<span style=color:#ae81ff>1</span>].amount
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li>When buying USDC:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>testBuyUSDCConsecutivePriceRanges</span>() <span style=color:#66d9ef>public</span> {
</span></span><span style=display:flex><span>    LiquidityRange[] <span style=color:#66d9ef>memory</span> liquidity <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LiquidityRange[](<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    liquidity[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> liquidityRange(<span style=color:#ae81ff>4545</span>, <span style=color:#ae81ff>5500</span>, <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>ether</span>, <span style=color:#ae81ff>5000</span> <span style=color:#66d9ef>ether</span>, <span style=color:#ae81ff>5000</span>);
</span></span><span style=display:flex><span>    liquidity[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> liquidityRange(<span style=color:#ae81ff>4000</span>, <span style=color:#ae81ff>4545</span>, <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>ether</span>, <span style=color:#ae81ff>5000</span> <span style=color:#66d9ef>ether</span>, <span style=color:#ae81ff>5000</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>int256</span> expectedAmount0Delta, <span style=color:#66d9ef>int256</span> expectedAmount1Delta) <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>2</span> <span style=color:#66d9ef>ether</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>-</span><span style=color:#ae81ff>9103</span>.<span style=color:#ae81ff>264925902176327184</span> <span style=color:#66d9ef>ether</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    assertSwapState(
</span></span><span style=display:flex><span>        ExpectedStateAfterSwap({
</span></span><span style=display:flex><span>            ...
</span></span><span style=display:flex><span>            sqrtPriceX96<span style=color:#f92672>:</span> <span style=color:#ae81ff>5069962753257045266417033265661</span>, <span style=color:#75715e>// 4094.9666586581643
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            tick<span style=color:#f92672>:</span> <span style=color:#ae81ff>83179</span>,
</span></span><span style=display:flex><span>            currentLiquidity<span style=color:#f92672>:</span> liquidity[<span style=color:#ae81ff>1</span>].amount
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><p>In these scenarios, we make big swaps that cause price to move outside of a price range. As a result, the second price
range gets activated and provides enough liquidity to satisfy the swap. In both scenarios, we can see that price lands
outside of the current price range and that the price range gets deactivated (current liquidity equals to the liquidity
of the second price range).</p><h3 id=partially-overlapping-price-ranges>Partially Overlapping Price Ranges
<a class=anchor href=#partially-overlapping-price-ranges>#</a></h3><p><img src=/images/milestone_3/swap_partially_overlapping_price_ranges.png alt="Swap over partially overlapping price ranges"></p><ul><li><p>When buying ETH:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>testBuyETHPartiallyOverlappingPriceRanges</span>() <span style=color:#66d9ef>public</span> {
</span></span><span style=display:flex><span>    LiquidityRange[] <span style=color:#66d9ef>memory</span> liquidity <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LiquidityRange[](<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    liquidity[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> liquidityRange(<span style=color:#ae81ff>4545</span>, <span style=color:#ae81ff>5500</span>, <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>ether</span>, <span style=color:#ae81ff>5000</span> <span style=color:#66d9ef>ether</span>, <span style=color:#ae81ff>5000</span>);
</span></span><span style=display:flex><span>    liquidity[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> liquidityRange(<span style=color:#ae81ff>5001</span>, <span style=color:#ae81ff>6250</span>, <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>ether</span>, <span style=color:#ae81ff>5000</span> <span style=color:#66d9ef>ether</span>, <span style=color:#ae81ff>5000</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>int256</span> expectedAmount0Delta, <span style=color:#66d9ef>int256</span> expectedAmount1Delta) <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>        <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>.<span style=color:#ae81ff>864220641170389178</span> <span style=color:#66d9ef>ether</span>,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>10000</span> <span style=color:#66d9ef>ether</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    assertSwapState(
</span></span><span style=display:flex><span>        ExpectedStateAfterSwap({
</span></span><span style=display:flex><span>            ...
</span></span><span style=display:flex><span>            sqrtPriceX96<span style=color:#f92672>:</span> <span style=color:#ae81ff>6165345094827913637987008642386</span>, <span style=color:#75715e>// 6055.578153852725
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            tick<span style=color:#f92672>:</span> <span style=color:#ae81ff>87091</span>,
</span></span><span style=display:flex><span>            currentLiquidity<span style=color:#f92672>:</span> liquidity[<span style=color:#ae81ff>1</span>].amount
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>When buying USDC:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>testBuyUSDCPartiallyOverlappingPriceRanges</span>() <span style=color:#66d9ef>public</span> {
</span></span><span style=display:flex><span>    LiquidityRange[] <span style=color:#66d9ef>memory</span> liquidity <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LiquidityRange[](<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    liquidity[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> liquidityRange(<span style=color:#ae81ff>4545</span>, <span style=color:#ae81ff>5500</span>, <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>ether</span>, <span style=color:#ae81ff>5000</span> <span style=color:#66d9ef>ether</span>, <span style=color:#ae81ff>5000</span>);
</span></span><span style=display:flex><span>    liquidity[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> liquidityRange(<span style=color:#ae81ff>4000</span>, <span style=color:#ae81ff>4999</span>, <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>ether</span>, <span style=color:#ae81ff>5000</span> <span style=color:#66d9ef>ether</span>, <span style=color:#ae81ff>5000</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>int256</span> expectedAmount0Delta, <span style=color:#66d9ef>int256</span> expectedAmount1Delta) <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>2</span> <span style=color:#66d9ef>ether</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>-</span><span style=color:#ae81ff>9321</span>.<span style=color:#ae81ff>077831210790476918</span> <span style=color:#66d9ef>ether</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    assertSwapState(
</span></span><span style=display:flex><span>        ExpectedStateAfterSwap({
</span></span><span style=display:flex><span>            ...
</span></span><span style=display:flex><span>            sqrtPriceX96<span style=color:#f92672>:</span> <span style=color:#ae81ff>5090915820491052794734777344590</span>, <span style=color:#75715e>// 4128.883835866256
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            tick<span style=color:#f92672>:</span> <span style=color:#ae81ff>83261</span>,
</span></span><span style=display:flex><span>            currentLiquidity<span style=color:#f92672>:</span> liquidity[<span style=color:#ae81ff>1</span>].amount
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><p>This is a variation of the previous scenario, but this time the price ranges are partially overlapping. In the areas
where the price ranges overlap, there&rsquo;s deeper liquidity, which makes the price movements slower. This is similar to
providing more liquidity into the overlapping ranges.</p><p>Also notice that, in both swaps, we got more tokens than in the &ldquo;Consecutive Price Ranges&rdquo; scenarios–this is again due
to deeper liquidity in the overlapping ranges.</p><link rel=stylesheet href=/katex/katex.min.css><script>function renderKatex(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})}</script><script defer src=/katex/katex.min.js></script>
<script defer src=/katex/auto-render.min.js onload=renderKatex(document.body)></script><span>
\[ \]</span></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#cross-tick-swaps>Cross-Tick Swaps</a><ul><li><a href=#how-cross-tick-swaps-work>How Cross-Tick Swaps Work</a></li><li><a href=#updating-computeswapstep-function>Updating <code>computeSwapStep</code> Function</a></li><li><a href=#updating-swap-function>Updating <code>swap</code> Function</a></li><li><a href=#liquidity-tracking-and-ticks-crossing>Liquidity Tracking and Ticks Crossing</a></li><li><a href=#testing>Testing</a><ul><li><a href=#one-price-range>One Price Range</a></li><li><a href=#multiple-identical-and-overlapping-price-ranges>Multiple Identical and Overlapping Price Ranges</a></li><li><a href=#consecutive-price-ranges>Consecutive Price Ranges</a></li><li><a href=#partially-overlapping-price-ranges>Partially Overlapping Price Ranges</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>