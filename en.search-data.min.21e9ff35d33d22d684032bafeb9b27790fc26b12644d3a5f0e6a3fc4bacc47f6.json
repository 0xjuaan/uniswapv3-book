[{"id":0,"href":"/uniswapv3-book/docs/milestone_1/introduction/","title":"Introduction","section":"Milestone 1. First Swap","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]   You\u0026rsquo;ll find the complete code of this chapter in this Github branch.\n First Swap #  In this milestone, we\u0026rsquo;ll build a pool contract that can receive liquidity from users and make swaps within a price range. To keep it as simple as possible, we\u0026rsquo;ll provide liquidity only in one price range and we\u0026rsquo;ll make a swap only in one direction. Also, we\u0026rsquo;ll calculate all the required math manually to get better intuition before starting using mathematical libs.\nLet\u0026rsquo;s model the situation we\u0026rsquo;ll build:\n There will be an ETH-USDC pool contract. ETH will be the $x$ reserve; USDC will be the $y$ reserve. We\u0026rsquo;ll set the current price to 5000 USDC per 1 ETH. The range we\u0026rsquo;ll provide liquidity is 4545-5500 USDC per 1 ETH. We\u0026rsquo;ll buy some ETH from the pool. At this point, since we have only one price range, we want the price of the trade to stay within the price range.  Visually, this model looks like this:\n[TODO: graph the model]\nBefore getting to code, let\u0026rsquo;s figure out the math and calculate all the parameters of the model. To keep things simple, I\u0026rsquo;ll do all math calculations in Python. This will allow us to focus on the calculations without diving into the nuances of mathematical operations in Solidity. This also means that, in smart contracts, we\u0026rsquo;ll hardcode all the amounts and values. This might look like a fake, but we want to start with simple contracts that work.\nFor your convenience, I put all the Python calculations in unimath.py.\n"},{"id":1,"href":"/uniswapv3-book/docs/introduction/amm/","title":"Introduction to markets","section":"Milestone 0","content":"Introduction to markets #  How centralized exchanges work #  In this book, we\u0026rsquo;ll build a decentralized exchange (DEX) that will run on Ethereum. There\u0026rsquo;re multiple approaches to how an exchange can be designed. All centralized exchanges have an order book at their core. An order book is just a journal that stores all sell or buy orders that traders what to make. Each order in this book contains a price the order must be executed at and the amount that must be bought or sold.\n[TODO: illustration]\nFor trading to happen, there must exist liquidity, which is simply the availability of assets on a market. If you want to buy a wardrobe but no one is selling one, there\u0026rsquo;s no liquidity. If you want to sell a wardrobe but no one wants to buy it, there\u0026rsquo;s liquidity but no buyers. If there\u0026rsquo;s no liquidity, there\u0026rsquo;s nothing to buy or sell.\nOn centralized exchanges, the order book is where liquidity is accumulated. If someone places a sell order, they provide liquidity to the market. If someone places a buy order, they expected the market to have liquidity, otherwise, no trade is possible.\nSince liquidity is not always available, but markets are still interested in trades, entities called market makers were established. A market maker is a firm or an individual who provides liquidity to markets, that is someone who has a lot of money and who buys different assets to sell them on exchanges. For this job, market makers are paid by exchanges.\nHow decentralized exchanges work #  Don\u0026rsquo;t be surprised, decentralized exchanges also need liquidity. And they also need someone who provides it to traders of a wide variety of assets. However, this process cannot be handled in a centralized way. A decentralized solution must exist. There are multiple decentralized solutions and the same solutions are implemented in different ways, but our focus will be on how Uniswap solves this problem.\nAutomated Market Makers #  The evolution of on-chain markets brought us to the idea of Automated Market Makers (AMM). As the name implies, this algorithm works exactly like market makers but in an automated way. Moreover, it\u0026rsquo;s decentralized and permissionless (anyone can use them).\nWhat is an AMM? #  The core idea is pooling-different and not connected groups of people are incentivized to put their assets (tokens) into pools, which are smart contracts. Anyone else can use these pool contracts to trade, thanks to liquidity provided by the first group.\n[TODO: illustration]\nWhat makes this approach different from centralized exchanges is that the smart contracts are fully automated and not managed by anyone. There are no managers, admins, privileged users, etc. There are only liquidity providers and traders, and all the algorithms are programmed and immutable.\n"},{"id":2,"href":"/uniswapv3-book/docs/milestone_1/calculating-liquidity/","title":"Calculating Liquidity","section":"Milestone 1. First Swap","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]  Calculating liquidity #  Trading is not possible without liquidity, and to make our first swap we need to put some liquidity into the pool contract. Here\u0026rsquo;s what we need to know to add liquidity to the pool contract:\n A price range. As a liquidity provider, we want to provide liquidity at a specific price range, and it\u0026rsquo;ll only be used in this range. Amount of liquidity, which is the amounts of two tokens. We\u0026rsquo;ll need to transfer these amounts to the pool contract.  Here, we\u0026rsquo;re going to calculate these manually, but, in a later chapter, a contract will do this for us. Let\u0026rsquo;s begin with a price range.\nPrice Range Calculation #  Recall that, in Uniswap V3, the entire price range is demaracted into ticks: each tick corresponds to a price and has an index. In our first pool implementation, we\u0026rsquo;re going to buy ETH for USDC at the price of $5000 per 1 ETH. Buying ETH will remove some amount of it from the pool and will push the price slightly above $5000. We want to provide liquidity at a range that includes this price. And we want to be sure that the final price will stay within this range (we\u0026rsquo;ll do multi-range swaps in a later chapter).\nWe\u0026rsquo;ll need to find three ticks:\n The current tick will correspond to the current price (5000 USDC for 1 ETH). The lower and upper bounds of the price range we\u0026rsquo;re providing liquidity into. Let the lower price be $4500 and the upper price be $5500.  From the theoretical introduction we know that:\n$$\\sqrt{p} = \\sqrt{\\frac{y}{x}}$$\nSince we\u0026rsquo;ve agreed to use ETH as the $x$ reserve and USDC as the $y$ reserve, the prices at each of the ticks are:\n$$\\sqrt{p_c} = \\sqrt{\\frac{5000}{1}} = \\sqrt{5000} \\approx 70.71$$\n$$\\sqrt{p_l} = \\sqrt{\\frac{4545}{1}} \\approx 67.42$$\n$$\\sqrt{p_u} = \\sqrt{\\frac{5500}{1}} \\approx 74.16$$\nWhere $p_c$ is the current price, $p_l$ is the lower bound of the range, $p_u$ is the upper bound of the range.\nNow, we can find corresponding ticks. We know that prices and ticks are connected via this formula:\n$$\\sqrt{p(i)}=1.0001^{\\frac{i}{2}}$$\nThus, we can find tick $i$ via:\n$$i = log_{\\sqrt{1.0001}} \\sqrt{p(i)}$$\n The square roots in this formula cancel out, but since we\u0026rsquo;re working with $\\sqrt{p}$ we need to preserve them.\n Let\u0026rsquo;s find the ticks:\n Current tick: $i_c = log_{\\sqrt{1.0001}} 70.71 = 85176$ Lower tick: $i_l = log_{\\sqrt{1.0001}} 67.42 = 84222$ Upper tick: $i_u = log_{\\sqrt{1.0001}} 74.16 = 86129$   To calculate these, I used Python:\nimport math  def price_to_tick(p):  return math.floor(math.log(p, 1.0001))  price_to_tick(5000) \u0026gt; 85176 (Feel free using any other language.)\n That\u0026rsquo;s it for price range calculation!\nLast thing to note here is that Uniswap uses Q64.96 number to store $\\sqrt{p}$. This is a fixed point number that has 64 bits for the integer part and 96 bits for the fractional part. In our above calculations, prices are floating point numbers: 70.71, 67.42, 74.16. We need to convert them to Q64.96. Luckily, this is simple: we need to multiply the numbers by the maximum value of the fractional part of Q64.96, which is $2^{96}$. We\u0026rsquo;ll get:\n$$\\sqrt{p_c} = 5602277097478614198912276234240$$\n$$\\sqrt{p_l} = 5314786713428871004159001755648$$\n$$\\sqrt{p_u} = 5875717789736564987741329162240$$\n In Python:\nq96 = 2**96 def price_to_sqrtp(p):  return int(math.sqrt(p) * q96)  price_to_sqrtp(5000) \u0026gt; 5602277097478614198912276234240 Notice that we\u0026rsquo;re multiplying before converting to integer. Otherwise, we\u0026rsquo;ll use precision.\n Ok, we\u0026rsquo;re done here.\nToken Amounts Calculation #  Next step is to decide how many tokens we want to deposit into the pool. The answer is: as many as we want. The amounts are not strictly defined, we can deposit as much as it is enough to buy a small amount of ETH without causing the price leave the price range we put liquidity into. During development and testing we\u0026rsquo;ll be able to mint any amount of tokens, so getting the amounts we want is not a problem.\nFor our first swap, let\u0026rsquo;s deposit 1 ETH and 5000 USDC.\nLiquidity Amount Calculation #  Next, we need to calculate $L$ based on the amounts we\u0026rsquo;ll deposit.\nFrom the theoretical introduction, you remember that: $$L = \\sqrt{xy}$$\nHowever, we cannot simply multiply 1 ETH by 5000 USDC and take the square root. The reason is that the $x$ and $y$ in this formula are virtual reserves. [TODO: what are virtual reserves?]\nWe need to calculate $L$ specifically for the price range we\u0026rsquo;re going to deposit liquidity into, and it\u0026rsquo;ll be calculated based on the amounts we\u0026rsquo;re going to deposit. To find $L$, we need to look at one interesting fact: when the current price equals the lower or the upper price, one of the pool reserves is 0 and all pool\u0026rsquo;s liquidity is in the other reserve. For example, if the current price is $5500 then all ETH was bought from the pool and there\u0026rsquo;s only USDC left. And vice versa: when the current price is $4500 then all USDC was bought from the pool and there\u0026rsquo;s only ETH.\n[TODO: illustrate]\n[TODO: or maybe use the delta x and delta y formulas?] $$\\Delta x = \\frac{L}{\\sqrt{p(i_u)}} - \\frac{L}{\\sqrt{p(i_c)}} = \\frac{L(\\sqrt{p(i_u)} - \\sqrt{p(i_c)})}{\\sqrt{p(i_u)}\\sqrt{p(i_c)}}$$ $$\\Delta y = L\\sqrt{p(i_c)} - L\\sqrt{p(i_l)} = L(\\sqrt{p(i_c)} - \\sqrt{p(i_l)})$$\nKnowing this, let\u0026rsquo;s return to the trading formula of real reserves:\n$$(x + \\frac{L}{\\sqrt{p_b}})(y + L\\sqrt{p_a}) = L^{2}$$\nSo, there are two possible situations:\n $x$ can be 0 when the entire reserve of $x$ is bought from the pool. $y$ can be 0 when the entire reserve of $y$ is bought from the pool.  And these situations also serve as constraints: the amount of $L$ we deposit must satisfy both of them.\nSo, to find $L$, we need to calculate it in both of these scenarios. Let\u0026rsquo;s begin with the one where $y$ is zero. The trade function will look like so:\n$$(x+\\frac{L}{\\sqrt{p_b}})L\\sqrt{p_a} = L^{2}$$\nWhen $y$ is zero, any trade will add some $\\Delta y$ ($L\\sqrt{p_a}$) to the empty reserve of $y$, and no buying of $y$ in this situation is possible.\nNext, we can find $L$:\n$$L = x\\frac{\\sqrt{p_a}\\sqrt{p_b}}{\\sqrt{p_b}-\\sqrt{p_a}}$$\nNow, let\u0026rsquo;s find a similar formula for the situation when $x$ is zero:\n$$\\frac{L}{\\sqrt{p_b}}(y + L\\sqrt{p_a}) = L^{2}$$ $$L = \\frac{y}{\\sqrt{p_b}-\\sqrt{p_a}}$$\n[TODO: show the calculations]\nHaving these two $L\u0026rsquo;s$, we need to choose one of them and we\u0026rsquo;ll choose the smaller one. Why? The amount of liquidity we deposit must allow equally big price movements in both directions. If we pick the bigger amount, the other on won\u0026rsquo;t be enough to satisfy this requirement.\nNow, let\u0026rsquo;s plug our numbers into the formulas. For $x$, $p_a$ is the current price, and $p_b$ is the upper bound of the price range. For $y$, $p_a$ is the lower bound and $p_b$ is the current price.\n[TODO: add graph, x_real, y_real, from the whitepaper]\n$$L = x\\frac{\\sqrt{p_a}\\sqrt{p_b}}{\\sqrt{p_b}-\\sqrt{p_a}} = 1 ETH * \\frac{67.42 * 70.71}{70.71 - 67.42}$$ After converting to Q64.96, we get:\n$$L = 1519437308014769733632$$\nSolving the other $L$: $$L = \\frac{y}{\\sqrt{p_b}-\\sqrt{p_a}} = \\frac{5000USDC}{74.16-70.71}$$ $$L = 1517882343751509868544$$\n In Python:\nsqrtp_low = price_to_sqrtp(4545) sqrtp_cur = price_to_sqrtp(5000) sqrtp_upp = price_to_sqrtp(5500)  def liquidity0(amount, pa, pb):  if pa \u0026gt; pb:  pa, pb = pb, pa  return (amount * (pa * pb) / q96) / (pb - pa)  def liquidity1(amount, pa, pb):  if pa \u0026gt; pb:  pa, pb = pb, pa  return amount * q96 / (pb - pa)  liq0 = liquidity0(amount_eth, sqrtp_cur, sqrtp_upp) liq1 = liquidity1(amount_usdc, sqrtp_cur, sqrtp_low) liq = int(min(liq0, liq1)) \u0026gt; 1517882343751509868544  Of these two we\u0026rsquo;re picking the smaller one, 1517882343751509868544.\nToken Amounts Calculation, Again #  Since we choose the amounts we\u0026rsquo;re going to deposit, the amounts can be wrong. We cannot deposit any amounts at any price ranges; liquidity amounts need to aligned with the shape of curve in the price range we\u0026rsquo;re depositing into. Thus, even though users choose amounts, the contract needs to re-calculate them, and actual amounts will be slightly different (at least because of rounding). Luckily, we can re-use the formulas from the previous paragraph:\n$$L = x\\frac{\\sqrt{p_a}\\sqrt{p_b}}{\\sqrt{p_b}-\\sqrt{p_a}}$$ $$L = \\frac{y}{\\sqrt{p_b}-\\sqrt{p_a}}$$\nFrom them, we can find $x$ and $y$:\n$$ x = \\frac{L(\\sqrt{p_b}-\\sqrt{p_a})}{\\sqrt{p_b}\\sqrt{p_a}}$$ $$ y = L(\\sqrt{p_b}-\\sqrt{p_a}) $$\n In Python:\ndef calc_amount0(liq, pa, pb):  if pa \u0026gt; pb:  pa, pb = pb, pa  return int(liq * q96 * (pb - pa) / pa / pb)   def calc_amount1(liq, pa, pb):  if pa \u0026gt; pb:  pa, pb = pb, pa  return int(liq * (pb - pa) / q96)  amount0 = calc_amount0(liq, sqrtp_upp, sqrtp_cur) amount1 = calc_amount1(liq, sqrtp_low, sqrtp_cur) (amount0, amount1) \u0026gt; (998976618347425408, 5000000000000000000000) As you can see, the number are close to the amounts we want to provide, but ETH is slightly smaller.\n  Hint: use cast --from-wei AMOUNT to convert from wei to ether. For example:\ncast --from-wei 998976618347425280 will give you 0.998976618347425280.\n To sum it up, when providing liquidity, users:\n choose the price range they want to provide liquidity into, choose the amounts of tokens they want to provide.  Contracts then:\n calculate $L$ based on the amounts and the price range chosen by the user, calculate exact amounts the user needs to deposit.  The amounts users choose are upper bounds, and contracts guarantee that users won\u0026rsquo;t send more tokens than they\u0026rsquo;ve chosen. We\u0026rsquo;ll see how this works in a later milestone.\n"},{"id":3,"href":"/uniswapv3-book/docs/introduction/cfmm/","title":"Constant Function Market Makers","section":"Milestone 0","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]  Constant Function Market Makers #   This chapter retells the whitepaper of Uniswap V2. Understanding this math is crucial to build a Uniswap-like DEX, but it\u0026rsquo;s totally fine if you don\u0026rsquo;t understand everything at this stage.\n As I mentioned in the previous section, there are different approaches to building AMM. We\u0026rsquo;ll be focusing on and building one specific type of AMM–Constant Function Market Maker. Don\u0026rsquo;t be scared by the long name! At its core is a very simple mathematical formula:\n$$x * y = k$$\nThat\u0026rsquo;s it, that\u0026rsquo;s the formula.\n$x$ and $y$ are pool contract reserves–the amounts of tokens it currently holds. k is just their product, actual value doesn\u0026rsquo;t matter.\n Why there are only two reserves, x and y?\nEach Uniswap pool can hold only two tokens. We use x and y to refer to reserves of one pool, where x is the reserve of the first token and y is the reserve of the other token, and the order doesn\u0026rsquo;t matter.\n The constant function formula says: after each trade, k must remain unchanged. When traders make trades, they put some amount of one token into a pool (token they want to sell) and remove some amount of the other token from the pool (token they want to buy). This changes the reserves of the pool, and the constant function formula says that the product of reserves must not change. As we will see many times in this book, this simple requirement is the core algorithm of the exchange we\u0026rsquo;re building.\nThe trade function #  Now that we know what pools are, let\u0026rsquo;s write the formula of how trading happens in a pool:\n$$(x + r\\Delta x)(y - \\Delta y) = k$$\n[TODO: illustration]\n There\u0026rsquo;s a pool with some amount of token X ($x$) and some amount of token Y ($y$). When we buy token Y for token X, we give some amount of token X to the pool ($\\Delta x$). The pool gives us some amount of token Y in exchange ($\\Delta y$). The pool also takes a small fee from the amount of token X we gave ($r$). The reserve of token X changes ($x + r \\Delta x$), and the reserve of token Y changes as well ($y - \\Delta y$). The product of updated reserves must still equal $k$.  The order of tokens in the formula doesn\u0026rsquo;t matter: Uniswap pools allow swapping tokens in both directions.\nPricing #  How do we calculate the prices of tokens in a pool?\nSince Uniswap pools are separate smart contracts, tokens in a pool are priced in terms of each other. For example: in USDC-ETH pool, ETH is priced in terms of USDC and USDC is priced in terms of ETH. If 1 ETH costs 1000 USDC, then 1 USDC costs 0.001 ETH. The same is true for any other pool, whether it\u0026rsquo;s a stablecoin pair or not. And actual token prices are simply relations of reserves:\n$$P_x = \\frac{y}{x}, \\quad P_y=\\frac{x}{y}$$\nWhere $P_x$ and $P_y$ are prices of tokens in terms of the other token. Such prices are called spot prices and they only reflect current market prices. However, the actual price of a trade is calculated differently. Let\u0026rsquo;s return to the trade function and try to come up with some conclusions about how an actual trade price is calculated:\n$$(x + r\\Delta x)(y - \\Delta y) = k$$\nSuppose we want to find the price of token X (its reserve is $x$ in the formula) when swapping it for token Y (its reserve is $y$ in the formula). We\u0026rsquo;re trading in some amount of token X ($\\Delta x$) in exchange for some amount of token Y ($\\Delta y$). This means that the actual price of the trade will be the relation of the amounts. Not the reserves, but the amounts we give and get.\nLet\u0026rsquo;s rewrite the trade function to find out trade amounts:\n First, we write $k$ as the product of reserves before a trade: $$(x + r\\Delta x)(y - \\Delta y) = xy$$ On the left side, is the product of updated reserves (after a swap). On the right side, is the product of current reserves (before a swap). Then, we can find $\\Delta y$ using simple algebraic operations: $$\\Delta y = \\frac{yr\\Delta x}{x + r\\Delta x}$$ [TODO: explain] Similarly, we can express $\\Delta x$ in terms of $\\Delta y$: $$\\Delta x = \\frac{x \\Delta y}{r(y - \\Delta y)}$$ [TODO: explain]  Having these functions, we don\u0026rsquo;t need to calculate prices because we can calculate amounts instead! If we know how many tokens we want to sell, we can calculate the amount we\u0026rsquo;ll get without calculating the price. And vice versa: if we want to buy a specific amount of tokens, we can calculate the amount we need to sell right away, without calculating the price.\nLast thing to notice here is that the trade function can be rewritten using geometric means. So this formula: $$(x + r\\Delta x)(y - \\Delta y) = xy$$\nBecomes this: $$\\sqrt[n]{\\prod_{i=1}^n X_i\u0026rsquo;} = \\sqrt[n]{\\prod_{i=1}^n X_i}$$\nWhere: $n=2$ (since we have only two tokens in a pool), $X_i$ is current reserves ($X_1 = x, X_2=y$), $X_i\u0026rsquo;$ is updated reserves. This is a general representation of the trade function, Uniswap\u0026rsquo;s implementation is a special case of this formula.\nThe Curve #  The above calculations might seem too abstract and dry. Let\u0026rsquo;s visualize the constant product function to better understand how it works\nWhen plotted, the constant product function is a quadratic hyperbola:\n[TODO: add graph]\nWhere axes are reserves. Every trade starts at the point on the curve that corresponds to the current ratio of reserves. To calculate the output amount, we need to find a new point on the curve, which has the $x$ coordinate of $x+\\Delta x$, i.e. current reserve of token X + the amount we\u0026rsquo;re selling. The change in $y$ is the number of tokens B we\u0026rsquo;ll get.\nLet\u0026rsquo;s look at a concrete example:\n[TODO: add graph]\n Start price ($P_x = \\frac{y}{x}$) is 4: 1 X = 4 Y. We\u0026rsquo;re selling 42 X. If we use only the start price, we expect to get 42 * 4 = 168 Y. However, the execution price is 2.173, so we get only 91.304 Y!   To build a better intuition of how it works, try making up several scenario and plot them on the graph. Try different X amount relative to the reserve of X, see how output amount changes hen $\\Delta x$ is small relative to $x$.\n  This wonderful chart was created by Dan Robinson, one of the creators of Uniswap. Massive kudos!\n I bet you\u0026rsquo;re wondering why using such a curve? It might seem like it punishes you for trading big amounts. This is true, and this is a desirable property! The law of supply and demand tells us that when demand is high (and supply is constant) the price is also high. And when demand is low, the price is also lower. This is how markets work. And, magically, the constant product function implements this mechanism! Demand is defined by the amount you want to buy, and supply is the pool reserves. When you want to buy a big amount relative to pool reserves the price is higher than when you want to buy a smaller amount. Such a simple formula guarantees such a powerful mechanism!\nEven though Uniswap doesn\u0026rsquo;t calculate trade prices, we can still see them on the curve. Surprisingly, there are multiple prices when making a trade:\n[TODO: tell about prices on the curve, tangent lines]\n Before a trade, there\u0026rsquo;s a spot price. It\u0026rsquo;s equal to the relation of reserves, $y/x$ or $x/y$ depending on the order of the trade. This price is also the slope of the tangent line at the starting point. After a trade, there\u0026rsquo;s a new spot price, at a different point on the curve. And it\u0026rsquo;s the slope of the tangent line at this new point. The actual price of the trade is the slope of the line connecting the two points!  And that\u0026rsquo;s the whole math of Uniswap! Phew!\nWell, this is the math of Uniswap V2, and we\u0026rsquo;re studying Uniswap V3. So in the next part, we\u0026rsquo;ll see how the mathematics of Uniswap V3 is different.\n"},{"id":4,"href":"/uniswapv3-book/docs/milestone_1/providing-liquidity/","title":"Providing Liquidity","section":"Milestone 1. First Swap","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]  Providing Liquidity #  Enough of theory, let\u0026rsquo;s start coding!\nCreate a new folder (mine is called uniswapv3-code), and run forge init --vscode in it–this will initialize a Forge project. The --vscode flag tells Forge to configure the Solidity extension for Forge projects.\nNext, remove the default contract and its test:\n script/Contract.s.sol src/Contract.sol test/Contract.t.sol  And that\u0026rsquo;s it! Let\u0026rsquo;s create our first contract!\nPool Contract #  As you\u0026rsquo;ve learned from the introduction, Uniswap deploys multiple Pool contracts, each of which is an exchange market of a pair of tokens. Uniswap groups all its contract into two categories:\n core contracts, and periphery contracts.  Core contracts are, as the name implies, the contracts that implement core logic. These are minimal, user-unfriendly, low-level contracts. Their purpose is to do one thing. In Uniswap V3, there are 2 such contracts:\n Pool contract, which implements the core logic of a decentralized exchange. Factory contract, which serves as a registry of Pool contracts and a contract that makes deployment of pools easier.  We\u0026rsquo;ll begin with the pool contract. Create src/UniswapV3Pool.sol:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.14;  contract UniswapV3Pool {} Let\u0026rsquo;s think about what data the contract will store:\n Since every pool contract is an exchange market of two tokens, we need to track the two token addresses. And these addresses will be static, set once and forever during contract initialization. Each pool contract is a set of liquidity positions, a data structure to manage positions identified by: liquidity provider\u0026rsquo;s address, and upper and lower bounds of the position. Each pool contract will also need to maintain a ticks registry and information about each tick–the amount of liquidity provided by each tick. Since the tick range is limited, we need to store the limits in the contract, as constants. And as we discussed in the introduction, pool contracts store the amount of liquidity, $L$, and $\\sqrt{P}$ instead of token reserves. So we\u0026rsquo;ll need to store them in the contract as well.  Here\u0026rsquo;s what our pool contract with all the state variables:\ncontract UniswapV3Pool {  using Tick for mapping(int24 =\u0026gt; Tick.Info);  using Position for mapping(bytes32 =\u0026gt; Position.Info);  using Position for Position.Info;   int24 internal constant MIN_TICK = -887272;  int24 internal constant MAX_TICK = -MIN_TICK;   // Pool tokens, immutable  address public immutable token0;  address public immutable token1;   // First slot will contain essential data  struct Slot0 {  // Current sqrt(P)  uint160 sqrtPriceX96;  // Current tick  int24 tick;  }  Slot0 public slot0;   // Amount of liquidity, L.  uint128 public liquidity;   // Ticks info  mapping(int24 =\u0026gt; Tick.Info) public ticks;  // Positions info  mapping(bytes32 =\u0026gt; Position.Info) public positions;   ... Uniswap V3 uses many helper contracts and Tick and Position are two of them. using A for B is a feature of Solidity that lets you extend type B with functions from library contract A. This simplifies managing complex data structures.\n For brevity, I\u0026rsquo;ll omit detailed explanation of Solidity syntax and features. Solidity has great documentation, don\u0026rsquo;t hesitate referring to it if something is not clear!\n We\u0026rsquo;ll then initialize them in the constructor:\n constructor(  address token0_,  address token1_,  uint160 sqrtPriceX96,  int24 tick  ) {  token0 = token0_;  token1 = token1_;   slot0 = Slot0({sqrtPriceX96: sqrtPriceX96, tick: tick});  } } Notice that we\u0026rsquo;re passing $\\sqrt{P}$ and the current tick index without providing liquidity–this sets the current price.\n We\u0026rsquo;re setting both $\\sqrt{P}$ and tick index in the constructor for simplicity. Later on, we\u0026rsquo;ll implement the conversion between $\\sqrt{P}$ and tick indexes.\n This is our starting point, and our goal in this chapter is to make our first swap.\nMinting #  The process of providing liquidity in Uniswap V2 is called minting. The reason is that the V2 pool contract mints tokens (LP-tokens) in exchange for liquidity. V3 doesn\u0026rsquo;t do that, but it still uses the same name for the function. Let\u0026rsquo;s use it as well:\nfunction mint(  address owner,  int24 lowerTick,  int24 upperTick,  uint128 amount ) external returns (uint256 amount0, uint256 amount1) {  ... Our mint function will take:\n Owner\u0026rsquo;s address, to track the owner of the liquidity. Upper and lower ticks, to set the bounds of a price range. The amount of liquidity we have provided.  When adding initial liquidity to a pool, this function adds a new tick and a position.\nWe begin with checking the ticks:\nif (  lowerTick \u0026gt;= upperTick ||  lowerTick \u0026lt; MIN_TICK ||  upperTick \u0026gt; MAX_TICK ) revert InvalidTickRange(); And ensuring that some amount of liquidity is provided:\nif (amount == 0) revert ZeroLiquidity(); Then, add a tick and a position:\nticks.update(lowerTick, amount); ticks.update(upperTick, amount);  Position.Info storage position = positions.get(  owner,  lowerTick,  upperTick ); position.update(amount); The ticks.update function is:\n// src/libs/Tick.sol ... function update(  mapping(int24 =\u0026gt; Tick.Info) storage self,  int24 tick,  uint128 liquidityDelta ) internal {  Tick.Info storage tickInfo = self[tick];  uint128 liquidityBefore = tickInfo.liquidity;  uint128 liquidityAfter = liquidityBefore + liquidityDelta;   if (liquidityBefore == 0) {  tickInfo.initialized = true;  }   tickInfo.liquidity = liquidityAfter; } ... It initialized a tick if it has 0 liquidity before and adds new liquidity to it. As you can see, we\u0026rsquo;re calling this function on both lower and upper ticks, thus liquidity is added to both of them–we\u0026rsquo;ll see why later on.\nThe position.update function is:\n// src/libs/Position.sol function update(Info storage self, uint128 liquidityDelta) internal {  uint128 liquidityBefore = self.liquidity;  uint128 liquidityAfter = liquidityBefore + liquidityDelta;   self.liquidity = liquidityAfter; } Similar to the tick update function, it adds liquidity to a specific position. And to get a position we call:\n// src/libs/Position.sol ... function get(  mapping(bytes32 =\u0026gt; Info) storage self,  address owner,  int24 lowerTick,  int24 upperTick ) internal view returns (Position.Info storage position) {  position = self[  keccak256(abi.encodePacked(owner, lowerTick, upperTick))  ]; } ... Each position is uniquely identified by three keys: owner address, lower tick index, and upper tick index. We\u0026rsquo;re storing positions in a bytes32 =\u0026gt; Info map and are using hashes of concatenated owner address, lower tick, and upper tick as keys. This is cheaper than storing three nested maps.\nWe\u0026rsquo;re not done yet! Next, we need to calculate the amounts that the user must deposit. Luckily, we have already figured out the formulas and calculated the exact amounts in the previous part. So, we\u0026rsquo;re going to hardcode the amounts:\namount0 = 0.998976618347425280 ether; amount1 = 5000 ether;  We\u0026rsquo;ll replace these with actual calculations in a later chapter.\n Now, we\u0026rsquo;re ready to take tokens from the user. This is done via a callback:\nuint256 balance0Before; uint256 balance1Before; if (amount0 \u0026gt; 0) balance0Before = balance0(); if (amount1 \u0026gt; 0) balance1Before = balance1(); IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(  amount0,  amount1 ); if (amount0 \u0026gt; 0 \u0026amp;\u0026amp; balance0Before + amount0 \u0026gt; balance0())  revert InsufficientInputAmount(); if (amount1 \u0026gt; 0 \u0026amp;\u0026amp; balance1Before + amount1 \u0026gt; balance1())  revert InsufficientInputAmount(); First, we record current token balances (if either of them is deposited). Then we call uniswapV3MintCallback method on the caller–this is the callback. It\u0026rsquo;s expected that the caller (whoever executes mint) is a contract because non-contract addresses cannot implement functions in Ethereum. There are two reason doing this like that:\n Pool contract is a core contract, and core contracts are user-unfriendly. It\u0026rsquo;s expected that core contracts are only user by other contracts which make interaction with a pool easier. We don\u0026rsquo;t want to calculate the square root of reserves in the contract because it\u0026rsquo;s an expensive operation. But we still need to be sure that the liquidity deposited by user is correct. To achieve this, we calculate $\\Delta x$ and $\\Delta y$, which doesn\u0026rsquo;t require calculating square roots. But this approach forces us to use a callback to let the caller know the actual amounts they need to deposit.  In production, Pool contracts are called from the Router contract, which handles all the nuances. We\u0026rsquo;ll implement it in a later chapter.\nFinally, we\u0026rsquo;re firing a Mint event:\nemit Mint(msg.sender, owner, lowerTick, upperTick, amount, amount0, amount1); Events is how contract data is indexed in Ethereum for later search. It\u0026rsquo;s a good practice to fire an event whenever contract\u0026rsquo;s state is changed to let blockchain explorer know when this happened. Events also carry useful information. In our case it\u0026rsquo;s: caller\u0026rsquo;s address, liquidity position owner\u0026rsquo;s address, upper and lower ticks, new liquidity, and token amounts. This information will be stored as a log, and anyone else will be able to collect all contract events and reproduce activity of the contract without traversing and analyzing all blocks and transactions.\nAnd we\u0026rsquo;re done! Phew! Now, let\u0026rsquo;s test minting.\nTesting #  At this point we don\u0026rsquo;t know if everything works correctly. Before deploying our contract anywhere we\u0026rsquo;re going to write a bunch of tests to ensure the contract works correctly. Luckily to us, Forge is a great testing framework and it\u0026rsquo;ll make testing a breeze.\nCreate a new test file:\n//test/UniswapV3Pool.t.sol // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.14;  import \u0026#34;forge-std/Test.sol\u0026#34;;  contract UniswapV3PoolTest is Test {  function setUp() public {}   function testExample() public {  assertTrue(true);  } } Let\u0026rsquo;s run it:\n$ forge test Running 1 test for test/UniswapV3Pool.t.sol:UniswapV3PoolTest [PASS] testExample() (gas: 279) Test result: ok. 1 passed; 0 failed; finished in 5.07ms It passes! Of course it is! So far, our test only checks that true is true!\nTest contract are just contract that inherit from forge-std/Test.sol. This contract is a set of testing utilities, we\u0026rsquo;ll get acquainted with them step by step. If you don\u0026rsquo;t want wait, open lib/forge-std/src/Test.sol and skim through it!\nTest contracts follow a specific convention:\n setUp function is used to set up test cases. In each test cases, we want to have configured environment, like deployed contracts, minted tokens, initialized pools–we\u0026rsquo;ll do all this in setUp. Every test case starts with test prefix, e.g. testMint(). This will let Forge distinguish test cases from helper functions (we can add any function we want).  Let\u0026rsquo;s test minting!\nTest Tokens #  To test minting we need tokens. This is not a problem because we can deploy any contract in tests! Moreover, Forge can install open-source contracts as dependencies. Specifically, we need an ERC20 contract with minting functionality. We\u0026rsquo;ll use the ERC20 contract from solmate, a collection of gas-optimized contracts (however, we don\u0026rsquo;t care about gas optimization at this moment) and we\u0026rsquo;ll extend it in a contract that allows public minting.\nLet\u0026rsquo;s install solmate:\n$ forge install rari-capital/solmate Then, let\u0026rsquo;s create ERC20Mintable.sol contract in test folder (we\u0026rsquo;ll use the contract only in tests):\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.14;  import \u0026#34;solmate/tokens/ERC20.sol\u0026#34;;  contract ERC20Mintable is ERC20 {  constructor(  string memory _name,  string memory _symbol,  uint8 _decimals  ) ERC20(_name, _symbol, _decimals) {}   function mint(address to, uint256 amount) public {  _mint(to, amount);  } } Our ERC20Mintable inherits all functionality from solmate/tokens/ERC20.sol and we additionally implement public mint method which will allow us to mint any number of tokens.\nMinting #  Now, we\u0026rsquo;re ready to test minting.\nFirst, let\u0026rsquo;s deploy all the required contracts:\n// test/UniswapV3Pool.t.sol ... import \u0026#34;./ERC20Mintable.sol\u0026#34;; import \u0026#34;../src/UniswapV3Pool.sol\u0026#34;;  contract UniswapV3PoolTest is Test {  ERC20Mintable token0;  ERC20Mintable token1;  UniswapV3Pool pool;   function setUp() public {  token0 = new ERC20Mintable(\u0026#34;Ether\u0026#34;, \u0026#34;ETH\u0026#34;, 18);  token1 = new ERC20Mintable(\u0026#34;USDC\u0026#34;, \u0026#34;USDC\u0026#34;, 18);  }   ... In the setUp function, we do things that are required for all our test cases–tokens deployment. We\u0026rsquo;ll need the two tokens in every future test case (and we\u0026rsquo;ll add more tokens later on). However, we\u0026rsquo;re not going to deploy the pool here because each test case will need a pool with different parameters.\nTo make pool setting up cleaner and simpler, we\u0026rsquo;ll do this in a separate function, setupTestCase, that takes a set of test case parameters. In our first test case, we\u0026rsquo;ll test successful liquidity minting. This is what the test case parameters look like:\nfunction testMintSuccess() public {  TestCaseParams memory params = TestCaseParams({  wethBalance: 1 ether,  usdcBalance: 5000 ether,  currentTick: 85176,  lowerTick: 84222,  upperTick: 86129,  liquidity: 1517882343751509868544,  currentSqrtP: 5602277097478614198912276234240,  shouldTransferInCallback: true,  mintLiqudity: true  });  (uint256 poolBalance0, uint256 poolBalance1) = setupTestCase(params);  We\u0026rsquo;re planning to deposit 1 ETH and 5000 USDC into the pool. We want the current tick to be 85176, and lower and upper ticks being 84222 and 86129 respectively. We\u0026rsquo;re specifying the precalculated liquidity and current $\\sqrt{P}$. We also want to deposit liquidity (mintLiquidity parameter) and transfer tokens when requested by the pool contract (shouldTransferInCallback). We don\u0026rsquo;t want to do this in each test case, so we want this to be optional.  Next, we\u0026rsquo;re calling setupTestCase with the above parameters:\nfunction setupTestCase(TestCaseParams memory params)  internal  returns (uint256 poolBalance0, uint256 poolBalance1) {  token0.mint(address(this), params.wethBalance);  token1.mint(address(this), params.usdcBalance);   pool = new UniswapV3Pool(  address(token0),  address(token1),  params.currentSqrtP,  params.currentTick  );   if (params.mintLiqudity) {  (poolBalance0, poolBalance1) = pool.mint(  address(this),  params.lowerTick,  params.upperTick,  params.liquidity  );  }   shouldTransferInCallback = params.shouldTransferInCallback; } In this function, we\u0026rsquo;re minting tokens and deploying a pool (unconditionally), as well as providing liquidity when mintLiquidity is set and setting shouldTransferInCallback flag. We\u0026rsquo;ll then check the flag in the mint callback:\nfunction uniswapV3MintCallback(uint256 amount0, uint256 amount1) public {  if (shouldTransferInCallback) {  token0.transfer(msg.sender, amount0);  token1.transfer(msg.sender, amount1);  } } Recall that test contracts act as users. Thus, this test contract must implement uniswapV3MintCallback so it could call the mint function.\nSetting up test cases like that is not mandatory, you can do it however feels most comfortable to you. Test contracts are just contracts. You can implement whatever helper functions you want.\nIn testMintSuccess, we want to test that the pool contract:\n takes the correct amounts of tokens from us; creates a position with correct key and liquidity; initializes the upper and lower ticks we\u0026rsquo;ve specified; has proper current $\\sqrt{P}$ and $L$.  Let\u0026rsquo;s do this.\nMinting happens in setupTestCase, so we don\u0026rsquo;t need to do this again. The function also returns the amounts we have provided, so let\u0026rsquo;s check them:\nuint256 expectedAmount0 = 0.998976618347425280 ether; uint256 expectedAmount1 = 5000 ether; assertEq(  poolBalance0,  expectedAmount0,  \u0026#34;incorrect token0 deposited amount\u0026#34; ); assertEq(  poolBalance1,  expectedAmount1,  \u0026#34;incorrect token1 deposited amount\u0026#34; ); We expect specific pre-calculated amounts. And we can also check that these amounts were actually transferred to the pool:\nassertEq(token0.balanceOf(address(pool)), expectedAmount0); assertEq(token1.balanceOf(address(pool)), expectedAmount1); Next, we need to check the position the pool created for us. Remember that the key in positions mapping is a hash? We need to calculate it manually and then get our position from the contract:\nbytes32 positionKey = keccak256(  abi.encodePacked(address(this), params.lowerTick, params.upperTick) ); uint128 posLiquidity = pool.positions(positionKey); assertEq(posLiquidity, params.liquidity);  Since Position.Info is a struct, it gets destructured when fetched: each field gets fetched separately.\n [TODO: double-check]\nNext come the ticks. Again, it\u0026rsquo;s straightforward:\n(bool tickInitialized, uint128 tickLiquidity) = pool.ticks(  params.lowerTick ); assertTrue(tickInitialized); assertEq(tickLiquidity, params.liquidity);  (tickInitialized, tickLiquidity) = pool.ticks(params.upperTick); assertTrue(tickInitialized); assertEq(tickLiquidity, params.liquidity); And finally $\\sqrt{P}$ and $L$:\n(uint160 sqrtPriceX96, int24 tick) = pool.slot0(); assertEq(  sqrtPriceX96,  5602277097478614198912276234240,  \u0026#34;invalid current sqrtP\u0026#34; ); assertEq(tick, 85176, \u0026#34;invalid current tick\u0026#34;); assertEq(  pool.liquidity(),  1517882343751509868544,  \u0026#34;invalid current liquidity\u0026#34; ); As you can see, writing tests in Solidity is not hard!\nFailures #  Of course, testing only successful scenarios is not enough. We also need to test failing cases. What can go wrong when providing liquidity? Here are a couple of hints:\n Upper and lower ticks are too big or too low. Zero liquidity is provided. Liquidity provider doesn\u0026rsquo;t have enough of tokens.  I\u0026rsquo;ll leave it for you to implement these scenarios! Feel free peeking at the code in the repo.\n"},{"id":5,"href":"/uniswapv3-book/docs/introduction/uniswap-v3/","title":"Uniswap V3","section":"Milestone 0","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]  Introduction to Uniswap V3 #   This chapter retells the whitepaper of Uniswap V3. Again, it\u0026rsquo;s totally ok if you don\u0026rsquo;t understand all the concepts. They will be clearer when converted to code.\n To better understand the innovations Uniswap V3 brings, let\u0026rsquo;s first look at the imperfections of Uniswap V2.\nUniswap V2 is a general exchange that implements one AMM algorithm. However, not all trading pairs are equal. Pairs can be grouped by price volatility:\n Tokens with medium and high price volatility. This group includes most tokens since most tokens don\u0026rsquo;t have their prices pegged to something and are subject to market fluctuations. Tokens with low volatility. This group includes pegged tokens, mainly stablecoins: USDC-USDT, USDC-DAI, USDT-DAI, etc. Also: ETH-stETH, ETH-rETH.  These groups require different, let\u0026rsquo;s call them, pool configurations. The main difference is that pegged tokens require high liquidity to reduce the demand effect (we learned about it in the previous chapter) on big trades. The prices of USDC and USDT must stay close to 1, no matter how big the number of tokens we want to buy and sell. Since Uniswap V2\u0026rsquo;s general AMM algorithm is not very well suited for stablecoin trading, alternative AMMs (mainly Curve) were more popular for stablecoin trading.\nWhat caused this problem is that liquidity in Uniswap V2 pools is distributed infinitely–pool liquidity allows trades at any price, from 0 to infinity:\n[TODO: add illustration]\nThis might not seem like a bad thing, but this reduces capital efficiency. Historical prices of an asset stay within some defined range, whether it\u0026rsquo;s narrow or wide. For example, the historical price range of ETH is from $0.75 to $4,800 (according to CoinMarketCap). Today (June 2022, 1 ETH costs $1,1800), no one would buy 1 ether at $5000, so it makes no sense to provide liquidity at this price. Thus, a lot of liquidity in V2 pools cannot and won\u0026rsquo;t be used, ever. And this can be improved.\nConcentrated Liquidity #  Uniswap V3 introduces concentrated liquidity–liquidity providers can now choose the price range they want to provide liquidity into. This improves capital efficiency by allowing to put more liquidity into a narrow price range, which makes Uniswap more diverse: it can now have pools configured for pairs with different volatility. This fixes the problem of Uniswap V2 we discussed above.\nIn a nutshell, Uniswap V3 is many small Uniswap V2s. The main difference between V2 and V3 is that, in V3, there are many pools, not one. Each of these smaller pools exists only within a certain price range and each of them has finite reserves–we\u0026rsquo;ll call them real reserves. The entire price range (from 0 to infinity) is can be filled with these discrete pools, which provide liquidity within certain price ranges–this is the main feature of Uniswap V3.\n[TODO: add illustration, compare liquidity distributions]\nTo set a price range, we need to pick two price points on the curve, $a$ and $b$:\n[TODO: add curve with price a, b, and x_real, y_real]\nAs we saw in the previous chapter, buying or selling tokens moves the prices along the curve. A price range limits the movement of the price. When the price moves to either of the points, the pool becomes depleted: one of the token reserves will be 0 and buying this token won\u0026rsquo;t be possible.\nLet\u0026rsquo;s look closely at the chart above:\n The current price is the ratio of current reserves. To get to point $a$ we need to buy all available $Y$; to get to point $b$ we need to buy all available $X$. Real pool reserves are $x_real$ and $y_real$. These amounts define the current price and also allow to move the price to one of the edge prices.  Since reserves can be depleted, this curve better illustrates the price ranges:\n[TODO: add virtual reserves -\u0026gt; real reserves transition graph]\nThis is the original curve shifted in a way that makes it limited by the axes: the curve crosses the axes at the points corresponding to the price range. This chart also better illustrated pool reserves: amounts required to move the price of either of the tokens to one of the bounds of the price range.\nWhat happens when the current price range gets depleted? The price slips into the next price range (if it exists, of course). If the next price range doesn\u0026rsquo;t exist, a trade is not possible. We\u0026rsquo;ll see how this works later in the book.\nTo handle transitioning between price ranges, simplify liquidity management, and avoid rounding errors, Uniswap V3 uses these new concepts:\n$$L = \\sqrt{xy}$$\n$$\\sqrt{P} = \\sqrt{\\frac{y}{x}}$$\n$L$ can be seen as the amount of liquidity. In the previous chapter, we saw that the trade function can be rewritten as a comparison of geometric means of reserves before and after a swap.\n$\\frac{y}{x}$ is the price of token X in terms of Y. Since token prices in a pool are reciprocals of each other, we can use only one of them in calculations. The price of token Y in terms of token X is simply $\\frac{1}{y/x}=\\frac{x}{y}$. Similarly, $\\frac{1}{\\sqrt{P}} = \\frac{1}{\\sqrt{y/x}} = \\sqrt{\\frac{x}{y}}$.\n$L$ times price gives us the amount of liquidity. The curve of virtual reserves is shifted: along $x$ by the reserves of token X; along $y$ by the reserves of token Y. The real reserves curve crosses the axes in the coordinates equal to the amounts of reserves, that\u0026rsquo;s why reserves can be depleted.\nWhy using $\\sqrt{p}$ instead of $p$? There are two reasons:\n  Square root calculation is not precise and causes rounding errors. Thus, it\u0026rsquo;s easier to store the square root without calculating it in the contracts.\n  $\\sqrt{P}$ has an interesting connection to $L$: $L$ is also the relation between the change in output amount and the change in $\\sqrt{P}$.\n$$L = \\frac{\\Delta y}{\\Delta\\sqrt{P}}$$\n  [TODO: prove this]\nPricing #  Pool reserves in Uniswap V3 are defined as:\n$$x = \\frac{L}{\\sqrt{P}}$$ $$y = L \\sqrt{P}$$\nHowever, we\u0026rsquo;ll never need to calculate them because $L$ and $\\sqrt{P}$ allow us to find trade amounts without knowing $x$ and $y$. Let\u0026rsquo;s return to this formula:\n$$L = \\frac{\\Delta y}{\\Delta\\sqrt{P}}$$\nWe can find $\\Delta y$ from it:\n$$\\Delta y = \\Delta \\sqrt{P} L$$\nAs we discussed above, prices in a pool are reciprocals of each other. Thus, $\\Delta x$ is:\n$$\\Delta x = \\Delta \\frac{1}{\\sqrt{P}} L$$\n$L$ and $\\sqrt{P}$ allow us to not store and update pool reserves. Also, we don\u0026rsquo;t need to calculate $\\sqrt{P}$ each time because we can always find $\\Delta \\sqrt{P}$ and its reciprocal.\nTicks #  Uniswap V3, however, doesn\u0026rsquo;t allow us to select arbitrary prices when providing liquidity. Instead, it implements a scale and we choose certain marks on it.\nThe entire price range is demarcated by evenly distributed discrete ticks. Each tick has an index and corresponds to a certain price:\n$$p(i) = 1.0001^i$$\nWhere $p(i)$ is the price at tick $i$. Taking powers of 1.0001 has a desirable property: the difference between two adjacent ticks is 0.01% or 1 basis point.\n Basis point (1/100th of 1%, or 0.01%, or 0.0001) is a unit of measure of percentages in finance. You could\u0026rsquo;ve heard about basis point when central banks announced changes in interest rates.\n As we discussed above, Uniswap V3 stores $\\sqrt{P}$, not $P$. Thus, the formula is in fact:\n$$\\sqrt{p(i)} = \\sqrt{1.0001}^i = 1.0001 ^{\\frac{i}{2}}$$\nSo, we get values like: $\\sqrt{p(0)} = 1$, $\\sqrt{p(1)} = \\sqrt{1.0001} \\approx 1.00005$, $\\sqrt{p(-1)} \\approx 0.99995$.\nTicks are integers that can be positive and negative and, of course, they\u0026rsquo;re not infinite. Ticks are mapped to prices, thus they\u0026rsquo;re limited by the price range. Uniswap V3 stores $\\sqrt{P}$ as a fixed point Q64.96 number, which is a rational number that uses 64 bits for the integer part and 96 bits for the fraction part. It\u0026rsquo;s stored in an uint160 variable and it supports prices between $2^{-128}$ and $2^{128}$. Thus, the tick range is:\n$$[log_{1.0001}2^{-128}, log_{1.0001}{2^{128}}] = [-887272, 887272]$$\n"},{"id":6,"href":"/uniswapv3-book/docs/introduction/dev-environment/","title":"Development Environment","section":"Milestone 0","content":"Development environment #  We\u0026rsquo;re going to build two applications:\n An on-chain one–a set of smart contracts deployed on Ethereum. An off-chain one–a front-end application that will interact with the smart contracts.  While the front-end application development is part of this book, it won\u0026rsquo;t be our main focus. We will build it solely to demonstrate how smart contracts are integrated with front-end applications. You won\u0026rsquo;t need to build it from scratch, I\u0026rsquo;ll provide a template.\nQuick Introduction to Ethereum #  Ethereum is a blockchain that allows anyone to run applications on it. It might look like a cloud provider, but there are multiple differences:\n You don\u0026rsquo;t pay for hosting your application. But you pay for deployment. Your application will be small and it will be able to interact only with other contracts and the internal blockchain storage. Your application is immutable. That is: you won\u0026rsquo;t be able to modify it after it\u0026rsquo;s deployed.  To better understand these moments, let\u0026rsquo;s see what Ethereum is made of.\nAt the core of Ethereum (and any other blockchain) is a database. The most valuable data in Ethereum\u0026rsquo;s database is the state of accounts. An account is an Ethereum address with associated data:\n Balance: account\u0026rsquo;s ether balance. Code: bytecode of the smart contract deployed at this address. Storage: space used by smart contracts to store data. Nonce: a serial integer that\u0026rsquo;s used to protect against replay attacks.  Ethereum\u0026rsquo;s main job is building and maintaining this data in a secure way that doesn\u0026rsquo;t allow unauthorized access.\nEthereum is also a network, a network of computers that build and maintain the state independently of each other. The main goal of the network is to decentralize access to the database: there must be no single authority that\u0026rsquo;s allowed to modify anything in the database unilaterally. This is achieved by a means of consensus, which is a set of rules all the nodes in the network follow. If one party decides to abuse a rule, it\u0026rsquo;ll be excluded from the network.\n Fun fact: blockchain can use MySQL! Nothing prevents this besides performance. In its turn, Ethereum uses LevelDB, a fast key-value database.\n Every Ethereum node also runs EVM, Ethereum Virtual Machine. A virtual machine is a program that can run other programs, and EVM is a program that executes smart contracts. Users interact with contracts through transactions: besides simply sending ether, transactions can contain smart contract call data. It includes:\n An encoded contract function name. Function parameters.  Transactions are packed in blocks and blocks then mined by miners. Each participant of the network can validate any transaction and any block.\nIn a sense, smart contracts are similar to JSON APIs but instead of endpoints you call smart contract functions and you pass function parameters. Similar to API backends, smart contracts execute programmed logic, which can optionally modify smart contract storage. Unlike JSON API, you need to send a transaction to mutate blockchain state, and you\u0026rsquo;ll need to pay for each transaction you\u0026rsquo;re sending.\nFinally, Ethereum nodes expose a JSON-RPC API. Through this API, we can get account balance, estimate gas costs, get blocks and transactions, send transactions, and execute contract calls without sending transactions (this is used to read data from smart contracts). Here you can find the full list of available endpoints.\nLocal Development Environment #  We\u0026rsquo;re going to build smart contracts and run them on Ethereum, which means we need a node. And this is what smart contracts development looked like until recently. Today, we don\u0026rsquo;t need to run a node, which makes development much faster and allows us to iterate quicker.\nLet\u0026rsquo;s review the tools we\u0026rsquo;re going to use.\nFoundry #  Foundry is a set of tools for Ethereum applications development. Specifically, we\u0026rsquo;re going to use:\n Forge, a testing framework for Solidity. Anvil, a local Ethereum node designed for development with Forge.  [TODO: maybe Cast?]\nForge makes smart contracts developer\u0026rsquo;s life so much easier. With Forge, we don\u0026rsquo;t need to run a local node to test contracts. Instead, Forge will run our smart contracts on its internal EVM, which is much faster and doesn\u0026rsquo;t require sending transactions and mining blocks.\nForge allows us to write tests in Solidity! Before Forge, smart contract tests were written in JavaScript and this required running a node, writing interactions with the node in JS, sending transactions, and mining blocks. Forge also makes it easier to simulate blockchain state: we can easily fake our ether or token balance, execute contracts from other addresses, deploy any contracts at any address, etc.\nHowever, we\u0026rsquo;ll still need a local node to deploy our contract to. For that, we\u0026rsquo;ll use Anvil.\nEthers.js #  Ethers.js is a set of Ethereum utilities written in JavaScript. This is one of the two (the other one is web3.js) JavaScript libraries that are used in decentralized applications development. These libraries allow us to interact with an Ethereum node via the JSON-API, and they come with multiple utility functions that make developer\u0026rsquo;s life easier.\nMetaMask #  MetaMask is an Ethereum wallet in your browser. It\u0026rsquo;s a browser extension that creates and securely stores Ethereum private keys. MetaMask is the main Ethereum wallet application used by millions of users. We\u0026rsquo;ll use it to sign transactions that we\u0026rsquo;ll send to our local node.\nReact #  React is a well-known JavaScript library for building front-end applications. You don\u0026rsquo;t need to know React, I\u0026rsquo;ll provide a template application.\n"},{"id":7,"href":"/uniswapv3-book/docs/milestone_1/first-swap/","title":"First Swap","section":"Milestone 1. First Swap","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]  First Swap #  Now that we have liquidity, we can make our first swap!\nCalculating Swap Amounts #  First step, of course, is to figure out how to calculate swap amounts. And, again, let\u0026rsquo;s pick and hardcode some amount of USDC we\u0026rsquo;re going to trade in for ETH. Let it be 42! We\u0026rsquo;re going to buy ETH for 42 USDC.\nAfter deciding how many tokens we want to sell, we need to calculate how many tokens we\u0026rsquo;ll get in exchange. There are multiple ways of doing this. In Uniswap V2, we would\u0026rsquo;ve used current pool reserves, but in Uniswap V3 we have $L$ and $\\sqrt{P}$ and we know the fact that, when swapping within a price range, only $\\sqrt{P}$ changes and $L$ remains unchanged. We also know that: $$L = \\frac{\\Delta y}{\\Delta \\sqrt{P}}$$\nAnd\u0026hellip; we know $\\Delta y$! This is the 42 USDC we\u0026rsquo;re going to trade in! Thus, we can find how selling 42 USDC will affect the current $\\sqrt{P}$ given the $L$:\n$$\\Delta \\sqrt{P} = \\frac{\\Delta y}{L}$$\nIn Uniswap V3, we choose the price we want our trade to lead to (recall that swapping changes the current price, i.e. it moves the current price along the curve). Knowing the target price, the contract will calculate the amount of input token it needs to take from us and the respective amount of output token it\u0026rsquo;ll give us.\nLet\u0026rsquo;s plug in our numbers into the above formula:\n$$\\Delta \\sqrt{P} = \\frac{42 \\enspace USDC}{1517882343751509868544} = 2192253463713690532467206957$$\nAfter adding this to the current $\\sqrt{P}$, we\u0026rsquo;ll get the target price:\n$$\\sqrt{P_{target}} = \\sqrt{P_{current}} + \\Delta \\sqrt{P}$$\n$$\\sqrt{P_{target}} = 5604469350942327889444743441197$$\n To calculate the target price in Python:\namount_in = 42 * eth price_diff = (amount_in * q96) // liq price_next = sqrtp_cur + price_diff print(\u0026#34;New price:\u0026#34;, (price_next / q96) ** 2) print(\u0026#34;New sqrtP:\u0026#34;, price_next) print(\u0026#34;New tick:\u0026#34;, price_to_tick((price_next / q96) ** 2)) # New price: 5003.913912782393 # New sqrtP: 5604469350942327889444743441197 # New tick: 85184  After finding the target price, we can calculate token amounts using the amounts calculation functions from a previous chapter:\n$$ x = \\frac{L(\\sqrt{p_b}-\\sqrt{p_a})}{\\sqrt{p_b}\\sqrt{p_a}}$$ $$ y = L(\\sqrt{p_b}-\\sqrt{p_a}) $$\n In Python:\namount_in = calc_amount1(liq, price_next, sqrtp_cur) amount_out = calc_amount0(liq, price_next, sqrtp_cur)  print(\u0026#34;USDC in:\u0026#34;, amount_in / eth) print(\u0026#34;ETH out:\u0026#34;, amount_out / eth) # USDC in: 42.0 # ETH out: 0.008396714242162444  To verify the amounts, let\u0026rsquo;s recall another formula:\n$$\\Delta x = \\Delta \\frac{1}{\\sqrt{P}} L$$\nUsing this formula, we can find the amount of ETH we\u0026rsquo;re buying, $\\Delta x$, knowing the price change, $\\Delta\\frac{1}{\\sqrt{P}}$, and liquidity $L$. Be careful though: $\\Delta \\frac{1}{\\sqrt{P}}$ is not $\\frac{1}{\\Delta \\sqrt{P}}$! The former is the change of the price of ETH, and it can be found using this expression:\n$$\\Delta \\frac{1}{\\sqrt{P}} = \\frac{1}{\\sqrt{P_{target}}} - \\frac{1}{\\sqrt{P_{current}}}$$\nLuckily, we already know all the values, so we can plug them in right away (this might not fit on your screen!):\n$$\\Delta \\frac{1}{\\sqrt{P}} = \\frac{1}{5604469350942327889444743441197} - \\frac{1}{5602277097478614198912276234240}$$\n$$\\Delta \\frac{1}{\\sqrt{P}} = -0.00000553186106731426$$\nNow, let\u0026rsquo;s find $\\Delta x$:\n$$\\Delta x = -0.00000553186106731426 * 1517882343751509868544 = -8396714242162698 $$\nWhich is 0.008396714242162698 ETH, and it\u0026rsquo;s very close to the amount we found above! Notice that this amount is negative since we\u0026rsquo;re removing it from the pool.\nImplementing a Swap #  Swapping is implemented in swap function:\nfunction swap(address recipient)  public  returns (int256 amount0, int256 amount1) {  ... At this moment, it only takes a recipient, who is a receiver of tokens.\nFirst, we need to find the target price and tick, as well as calculate the token amounts. Again, we\u0026rsquo;ll simply hardcode the values we calculated earlier to keep things as simple as possible:\n... int24 nextTick = 85184; uint160 nextPrice = 5604469350942327889444743441197;  amount0 = -0.008396714242162444 ether; amount1 = 42 ether; ... Next, we need to update the current tick and sqrtP since trading affects the current price:\n... (slot0.tick, slot0.sqrtPriceX96) = (nextTick, nextPrice); ... Next, the contract sends tokens to the recipient and lets the caller transfer the input amount into the contract:\n... IERC20(token0).transfer(recipient, uint256(-amount0));  uint256 balance1Before = balance1(); IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(  amount0,  amount1 ); if (balance1Before + uint256(amount1) \u0026lt; balance1())  revert InsufficientInputAmount(); ... Again, we\u0026rsquo;re using a callback to pass the control to the caller and let it transfer the tokens. After that, we\u0026rsquo;re checking that pool\u0026rsquo;s balance is correct and includes the input amount.\nFinally, the contract emits a Swap event to make the swap discoverable. The event includes all the information about the swap:\n... emit Swap(  msg.sender,  recipient,  amount0,  amount1,  slot0.sqrtPriceX96,  liquidity,  slot0.tick ); And that\u0026rsquo;s it! The function simply sends some amount of tokens to the specified recipient address and expects a certain number of the other token in exchange. Throughout this book, the function will get much more complicated.\nTesting Swapping #  Now, we can test the swap function. In the same test file, create testSwapBuyEth function and set up the test case. This test case uses the same parameters as testMintSuccess:\nfunction testSwapBuyEth() public {  TestCaseParams memory params = TestCaseParams({  wethBalance: 1 ether,  usdcBalance: 5000 ether,  currentTick: 85176,  lowerTick: 84222,  upperTick: 86129,  liquidity: 1517882343751509868544,  currentSqrtP: 5602277097478614198912276234240,  shouldTransferInCallback: true,  mintLiqudity: true  });  (uint256 poolBalance0, uint256 poolBalance1) = setupTestCase(params);   ... Next steps will be different, however.\n We\u0026rsquo;re not going to test that liquidity has been correctly added to the pool since we tested this functionality in the other test cases.\n To make the test swap, we need 42 USDC:\ntoken1.mint(address(this), 42 ether); Before making the swap, we need to ensure we can transfer tokens to the pool contract when it requests them:\nfunction uniswapV3SwapCallback(int256 amount0, int256 amount1) public {  if (amount0 \u0026gt; 0) {  token0.transfer(msg.sender, uint256(amount0));  }   if (amount1 \u0026gt; 0) {  token1.transfer(msg.sender, uint256(amount1));  } } Since amounts during a swap can be positive (the amount that\u0026rsquo;s sent to the pool) and negative (the amount that\u0026rsquo;s taken from the pool), in the callback, we only want to send the positive amount, i.e. the amount we\u0026rsquo;re trading in.\nNow, we can call swap:\n(int256 amount0Delta, int256 amount1Delta) = pool.swap(address(this)); The function returns token amounts used in the swap, and we can check them right away:\nassertEq(amount0Delta, -0.008396714242162444 ether, \u0026#34;invalid ETH out\u0026#34;); assertEq(amount1Delta, 42 ether, \u0026#34;invalid USDC in\u0026#34;); Then, we need to ensure that tokens were actually transferred from the caller:\nassertEq(  token0.balanceOf(address(this)),  uint256(userBalance0Before - amount0Delta),  \u0026#34;invalid user ETH balance\u0026#34; ); assertEq(  token1.balanceOf(address(this)),  0,  \u0026#34;invalid user USDC balance\u0026#34; ); And sent to the pool contract:\nassertEq(  token0.balanceOf(address(pool)),  uint256(int256(poolBalance0) + amount0Delta),  \u0026#34;invalid pool ETH balance\u0026#34; ); assertEq(  token1.balanceOf(address(pool)),  uint256(int256(poolBalance1) + amount1Delta),  \u0026#34;invalid pool USDC balance\u0026#34; ); Finally, we\u0026rsquo;re checking that the pool state was updated correctly:\n(uint160 sqrtPriceX96, int24 tick) = pool.slot0(); assertEq(  sqrtPriceX96,  5604469350942327889444743441197,  \u0026#34;invalid current sqrtP\u0026#34; ); assertEq(tick, 85184, \u0026#34;invalid current tick\u0026#34;); assertEq(  pool.liquidity(),  1517882343751509868544,  \u0026#34;invalid current liquidity\u0026#34; ); Notice that swapping doesn\u0026rsquo;t change the current liquidity–in a later chapter, we\u0026rsquo;ll see when it does change it.\nHomework #  Write a test that fails with InsufficientInputAmount error.\n"}]