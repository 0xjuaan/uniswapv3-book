<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Uniswap V3 Development Book</title><link>https://uniswapv3book.com/</link><description>Recent content in Introduction on Uniswap V3 Development Book</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://uniswapv3book.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction</title><link>https://uniswapv3book.com/docs/milestone_1/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/introduction/</guid><description>First Swap # In this milestone, we&amp;rsquo;ll build a pool contract that can receive liquidity from users and make swaps within a price range. To keep it as simple as possible, we&amp;rsquo;ll provide liquidity only in one price range and we&amp;rsquo;ll allow to make swaps only in one direction. Also, we&amp;rsquo;ll calculate all the required math manually to get better intuition before starting using mathematical libs in Solidity.
Let&amp;rsquo;s model the situation we&amp;rsquo;ll build:</description></item><item><title>Introduction</title><link>https://uniswapv3book.com/docs/milestone_2/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/introduction/</guid><description>Second Swap # Alright, this is where it gets real. So far, our implementation has been looking too synthetic and static. We have calculated and hard coded all the amounts to make the learning curve less steep, and now we&amp;rsquo;re ready to make it dynamic. We&amp;rsquo;re going to implement the second swap, that is a swap in the opposite direction: sell ETH to buy USDC. To do this, we&amp;rsquo;re going to improve our smart contracts significantly:</description></item><item><title>Introduction</title><link>https://uniswapv3book.com/docs/milestone_3/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_3/introduction/</guid><description>Cross-tick Swaps # We have made a great progress so far and our Uniswap V3 implementation is quite close to the original one! However, our implementation only supports swaps within a price range–and this is what we&amp;rsquo;re going to improve in this milestone.
In this milestone, we&amp;rsquo;ll:
update mint function to provide liquidity in different price ranges; update swap function to cross price ranges when there&amp;rsquo;s not enough liquidity in the current price range; learn how to calculate liquidity in smart contracts; implement slippage protection in mint and swap functions; update the UI application to allow to add liquidity at different price ranges; learn a little bit more about fixed-point numbers.</description></item><item><title>Introduction</title><link>https://uniswapv3book.com/docs/milestone_4/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_4/introduction/</guid><description>Multi-pool Swaps # After implementing cross-tick swaps, we&amp;rsquo;ve got really close to real Uniswap V3 swaps. One significant limitation of our implementation is that it allows only swaps within a pool–if there&amp;rsquo;s no pool for a pair of tokens, then swapping between these tokens is not possible. This is not so in Uniswap since it allows multi-pool swaps. In this chapter, we&amp;rsquo;re going to add multi-pool swaps to our implementation.</description></item><item><title>Introduction</title><link>https://uniswapv3book.com/docs/milestone_5/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_5/introduction/</guid><description>Fees and Price Oracle # In this milestone, we&amp;rsquo;re going to add two new features to our Uniswap implementation. They share one similarity: they work on top of what we have already built–that&amp;rsquo;s why we&amp;rsquo;ve delayed them until this milestone. However, they&amp;rsquo;re not equally important.
We&amp;rsquo;re going to add swap fees and a price oracle:
Swap fees is a crucial mechanism of the DEX design we&amp;rsquo;re implementing. They&amp;rsquo;re the glue that makes things stick together.</description></item><item><title>Introduction</title><link>https://uniswapv3book.com/docs/milestone_6/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_6/introduction/</guid><description>NFT Positions # This is the cherry on the cake of this book. In this milestone, we&amp;rsquo;re going to learn how Uniswap contract can be extended and integrated into third-party protocols. This possibility is a direct consequence of having core contracts with only crucial functions, which allows to integrate them into other contracts without the need of adding new features to core contracts.
A bonus feature of Uniswap V3 was the ability to turn liquidity positions into NFT tokens.</description></item><item><title>Introduction to markets</title><link>https://uniswapv3book.com/docs/introduction/introduction-to-markets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/introduction/introduction-to-markets/</guid><description>Introduction to markets # How centralized exchanges work # In this book, we&amp;rsquo;ll build a decentralized exchange (DEX) that will run on Ethereum. There&amp;rsquo;re multiple approaches to how an exchange can be designed. All centralized exchanges have an order book at their core. An order book is just a journal that stores all sell and buy orders that traders want to make. Each order in this book contains a price the order must be executed at and the amount that must be bought or sold.</description></item><item><title>Calculating Liquidity</title><link>https://uniswapv3book.com/docs/milestone_1/calculating-liquidity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/calculating-liquidity/</guid><description>Calculating liquidity # Trading is not possible without liquidity, and to make our first swap we need to put some liquidity into the pool contract. Here&amp;rsquo;s what we need to know to add liquidity to the pool contract:
A price range. As a liquidity provider, we want to provide liquidity at a specific price range, and it&amp;rsquo;ll only be used in this range. Amount of liquidity, which is the amounts of two tokens.</description></item><item><title>Constant Function Market Makers</title><link>https://uniswapv3book.com/docs/introduction/constant-function-market-maker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/introduction/constant-function-market-maker/</guid><description>Constant Function Market Makers # This chapter retells the whitepaper of Uniswap V2. Understanding this math is crucial to build a Uniswap-like DEX, but it&amp;rsquo;s totally fine if you don&amp;rsquo;t understand everything at this stage.
As I mentioned in the previous section, there are different approaches to building AMM. We&amp;rsquo;ll be focusing on and building one specific type of AMM–Constant Function Market Maker. Don&amp;rsquo;t be scared by the long name!</description></item><item><title>Different Price Ranges</title><link>https://uniswapv3book.com/docs/milestone_3/different-ranges/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_3/different-ranges/</guid><description>Different Price Ranges # The way we implemented it, our Pool contract creates only price ranges that include the current price:
// src/UniswapV3Pool.sol function mint( ... amount0 = Math.calcAmount0Delta( slot0_.sqrtPriceX96, TickMath.getSqrtRatioAtTick(upperTick), amount ); amount1 = Math.calcAmount1Delta( slot0_.sqrtPriceX96, TickMath.getSqrtRatioAtTick(lowerTick), amount ); liquidity += uint128(amount); ... } From this piece you can also see that we always update the liquidity tracker (which tracks only currently available liquidity, i.</description></item><item><title>ERC721 Overview</title><link>https://uniswapv3book.com/docs/milestone_6/erc721-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_6/erc721-overview/</guid><description>ERC721 Overview # Let&amp;rsquo;s begin with an overview of EIP-721, the standard that defines NFT contracts.
ERC721 is a variant of ERC20. The main difference between them is that ERC721 tokens are non-fungible, that is: one token is not identical to another. To distinguish ERC721 tokens, each of them has a unique ID, which is almost always the counter at which a token was minted. ERC721 tokens also have an extended concept of ownership: owner of each token is tracked and stored in the contract.</description></item><item><title>Factory Contract</title><link>https://uniswapv3book.com/docs/milestone_4/factory-contract/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_4/factory-contract/</guid><description>Factory Contract # Uniswap is designed in a way that assumes many discrete Pool contracts, with each pool handling swaps of one token pair. This looks problematic when we want to swap between two tokens that don&amp;rsquo;t have a pool–is there&amp;rsquo;s no pool, no swaps are possible. However, we can still do intermediate swaps: first swap to a token that has pairs with either of the tokens and then swap this token to the target token.</description></item><item><title>Output Amount Calculation</title><link>https://uniswapv3book.com/docs/milestone_2/output-amount-calculation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/output-amount-calculation/</guid><description>Output Amount Calculation # Our collection of Uniswap math formulas lacks a final piece: the formula of calculating the output amount when selling ETH (that is: selling token $x$). In the previous milestone, we had an analogous formula for the scenario when ETH is bought (buying token $x$):
$$\Delta \sqrt{P} = \frac{\Delta y}{L}$$
This formula finds the change in the price when selling token $y$. We then added this change to the current price to find the target price:</description></item><item><title>Swap Fees</title><link>https://uniswapv3book.com/docs/milestone_5/swap-fees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_5/swap-fees/</guid><description>Swap Fees # As I mentioned in the introduction, swap fees is a core mechanism of Uniswap. Liquidity providers need to get paid for the liquidity they provide, otherwise they&amp;rsquo;ll just use it somewhere else. To incentivize them, trades pay a small fee during each swap. These fees then distributed among all liquidity providers pro rata (proportionally to their share in total pool liquidity).
To better understand the mechanism of fees collection and distribution, let&amp;rsquo;s see how they work.</description></item><item><title>Cross-Tick Swaps</title><link>https://uniswapv3book.com/docs/milestone_3/cross-tick-swaps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_3/cross-tick-swaps/</guid><description>Cross-Tick Swaps # Cross-tick swaps is probably the most advanced feature of Uniswap V3. Luckily, we have already implemented almost everything we need to make cross-tick swaps. Let&amp;rsquo;s see how cross-tick swaps work before implementing them.
How Cross-Tick Swaps Work # A common Uniswap V3 pool is a pool with many overlapping (and outstanding) price ranges. Each pool tracks current $\sqrt{P}$ and tick. When users swap tokens they move current price and tick to the left or to the right, depending on swap direction.</description></item><item><title>Flash Loan Fees</title><link>https://uniswapv3book.com/docs/milestone_5/flash-loan-fees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_5/flash-loan-fees/</guid><description>Flash Loan Fees # In a previous chapter we implemented flash loans and made them free. However, Uniswap collects swap fees on flash loans, and we&amp;rsquo;re going to add this to our implementation: the amounts repaid by flash loan borrowers must include a fee.
Here&amp;rsquo;s what the updated flash function looks like:
function flash( uint256 amount0, uint256 amount1, bytes calldata data ) public { uint256 fee0 = Math.</description></item><item><title>Math in Solidity</title><link>https://uniswapv3book.com/docs/milestone_2/math-in-solidity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/math-in-solidity/</guid><description>Math in Solidity # Due to Solidity not supporting numbers with th fractional part, math in Solidity is somewhat complicated. Solidity gives us integer and unsigned integer types, which are not enough for for more or less complex math calculations.
Another difficulty is gas consumption: the more complex an algorithm, the more gas it consumes. Thus, if we need to have advanced math operations (like exp, ln, sqrt), we want them to be as gas efficient as possible.</description></item><item><title>NFT Manager</title><link>https://uniswapv3book.com/docs/milestone_6/nft-manager/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_6/nft-manager/</guid><description>NFT Manager Contract # Obviously, we&amp;rsquo;re not going to add NFT-related functionality to the pool contract–we need a separate contract that will merge NFTs and liquidity positions. Recall that, while working on our implementation, we built the UniswapV3Manager contract to facilitate interaction with pool contracts (to make some calculations simpler and to enable multi-pool swaps). This contract was a good demonstration of how core Uniswap contracts can be extended. And we&amp;rsquo;re going to push this idea a little bit further.</description></item><item><title>Providing Liquidity</title><link>https://uniswapv3book.com/docs/milestone_1/providing-liquidity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/providing-liquidity/</guid><description>Providing Liquidity # Enough of theory, let&amp;rsquo;s start coding!
Create a new folder (mine is called uniswapv3-code), and run forge init --vscode in it–this will initialize a Forge project. The --vscode flag tells Forge to configure the Solidity extension for Forge projects.
Next, remove the default contract and its test:
script/Contract.s.sol src/Contract.sol test/Contract.t.sol And that&amp;rsquo;s it! Let&amp;rsquo;s create our first contract!
Pool Contract # As you&amp;rsquo;ve learned from the introduction, Uniswap deploys multiple Pool contracts, each of which is an exchange market of a pair of tokens.</description></item><item><title>Swap Path</title><link>https://uniswapv3book.com/docs/milestone_4/path/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_4/path/</guid><description>Swap Path # Let&amp;rsquo;s imagine that we have only these pools: WETH/USDC, USDC/USDT, WBTC/USDT. If we want to swap WETH for WBTC, we&amp;rsquo;ll need to make multiple swaps (WETH→USDC→USDT→WBTC) since there&amp;rsquo;s no WETH/WBTC pool. We can do this manually or we can improve our contracts to handle such chained, or multi-pool, swaps. Of course, we&amp;rsquo;ll do the latter!
When doing multi-pool swaps, we&amp;rsquo;re sending output of a previous swap to the input of the next one.</description></item><item><title>Uniswap V3</title><link>https://uniswapv3book.com/docs/introduction/uniswap-v3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/introduction/uniswap-v3/</guid><description>Introduction to Uniswap V3 # This chapter retells the whitepaper of Uniswap V3. Again, it&amp;rsquo;s totally ok if you don&amp;rsquo;t understand all the concepts. They will be clearer when converted to code.
To better understand the innovations Uniswap V3 brings, let&amp;rsquo;s first look at the imperfections of Uniswap V2.
Uniswap V2 is a general exchange that implements one AMM algorithm. However, not all trading pairs are equal. Pairs can be grouped by price volatility:</description></item><item><title>Development Environment</title><link>https://uniswapv3book.com/docs/introduction/dev-environment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/introduction/dev-environment/</guid><description>Development environment # We&amp;rsquo;re going to build two applications:
An on-chain one: a set of smart contracts deployed on Ethereum. An off-chain one: a front-end application that will interact with the smart contracts. While the front-end application development is part of this book, it won&amp;rsquo;t be our main focus. We will build it solely to demonstrate how smart contracts are integrated with front-end applications. Thus, the front-end application is optional, but I&amp;rsquo;ll still provide the code.</description></item><item><title>First Swap</title><link>https://uniswapv3book.com/docs/milestone_1/first-swap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/first-swap/</guid><description>First Swap # Now that we have liquidity, we can make our first swap!
Calculating Swap Amounts # First step, of course, is to figure out how to calculate swap amounts. And, again, let&amp;rsquo;s pick and hardcode some amount of USDC we&amp;rsquo;re going to trade in for ETH. Let it be 42! We&amp;rsquo;re going to buy ETH for 42 USDC.
After deciding how many tokens we want to sell, we need to calculate how many tokens we&amp;rsquo;ll get in exchange.</description></item><item><title>Multi-pool Swaps</title><link>https://uniswapv3book.com/docs/milestone_4/multi-pool-swaps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_4/multi-pool-swaps/</guid><description>Multi-pool Swaps # We&amp;rsquo;re now proceeding to the core of this milestone–implementing multi-pool swaps in our contracts. We won&amp;rsquo;t touch Pool contract in this milestone because it&amp;rsquo;s a core contract that should implement only core features. Multi-pool swaps is a utility feature, and we&amp;rsquo;ll implement it in Manager and Quoter contracts.
Updating Manager Contract # Single-pool and Multi-pool Swaps # In our current implementation, swap function in Manager contract supports only single-pool swaps and takes pool address in parameters:</description></item><item><title>NFT Renderer</title><link>https://uniswapv3book.com/docs/milestone_6/nft-renderer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_6/nft-renderer/</guid><description>NFT Renderer # Now we need to build an NFT renderer: a library that will handle calls to tokenURI in the NFT manager contract. It will render JSON metadata and an SVG for each minted token. As we discussed earlier, we&amp;rsquo;ll use the data URI format, which requires base64 encoding–this means we&amp;rsquo;ll need a base64 encoder in Solidity. But first, let&amp;rsquo;s look at what our tokens will look like.</description></item><item><title>Protocol Fees</title><link>https://uniswapv3book.com/docs/milestone_5/protocol-fees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_5/protocol-fees/</guid><description>Protocol Fees # While working on the Uniswap implementation, you&amp;rsquo;ve probably asked yourself, &amp;ldquo;How does Uniswap make money?&amp;rdquo; Well, it doesn&amp;rsquo;t (at least as of September 2022).
In the implementation we&amp;rsquo;ve built so far, traders pay liquidity providers for providing liquidity, and Uniswap Labs, as the company that developed the DEX, is not part of this process. Neither traders, nor liquidity providers pay Uniswap Labs for using the Uniswap DEX.</description></item><item><title>Slippage Protection</title><link>https://uniswapv3book.com/docs/milestone_3/slippage-protection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_3/slippage-protection/</guid><description>Slippage Protection # Slippage is a very important issued in decentralized exchanges. Slippage simply means the difference between the price that you see on the screen when initialing a transaction and the actual price the swap is executed at. This difference appears because there&amp;rsquo;s a short (and sometimes long, depending on network congestion and gas costs) delay between when you send a transaction and when it gets mined. In more technical terms, blockchain state changes every block and there&amp;rsquo;s no guarantee that your transaction will be applied at a specific block.</description></item><item><title>Tick Bitmap Index</title><link>https://uniswapv3book.com/docs/milestone_2/tick-bitmap-index/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/tick-bitmap-index/</guid><description>Tick Bitmap Index # As the first step towards dynamic swaps, we need to implement an index of ticks. In the previous milestone, we used to calculate the target tick when making a swap:
function swap(address recipient, bytes calldata data) public returns (int256 amount0, int256 amount1) { int24 nextTick = 85184; ... } When there&amp;rsquo;s liquidity provided in different price ranges, we cannot simply calculate the target tick.</description></item><item><title>Generalize Minting</title><link>https://uniswapv3book.com/docs/milestone_2/generalize-minting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/generalize-minting/</guid><description>Generalize Minting # Now, we&amp;rsquo;re ready to update mint function so we don&amp;rsquo;t need to hard code values anymore and can calculate them instead.
Indexing Initialized Ticks # Recall that, in the mint function, we update the TickInfo mapping to store information about available liquidity at ticks. Now, we also need to index newly initialized ticks in the bitmap index–we&amp;rsquo;ll later use this index to find next initialized tick during swapping.</description></item><item><title>Liquidity Calculation</title><link>https://uniswapv3book.com/docs/milestone_3/liquidity-calculation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_3/liquidity-calculation/</guid><description>Liquidity Calculation # Of the whole math of Uniswap V3, what we haven&amp;rsquo;t yet implemented in Solidity is liquidity calculation. In the Python script, we have these functions:
def liquidity0(amount, pa, pb): if pa &amp;gt; pb: pa, pb = pb, pa return (amount * (pa * pb) / q96) / (pb - pa) def liquidity1(amount, pa, pb): if pa &amp;gt; pb: pa, pb = pb, pa return amount * q96 / (pb - pa) Let&amp;rsquo;s implement them in Solidity so we could calculate liquidity in the Manager.</description></item><item><title>Manager Contract</title><link>https://uniswapv3book.com/docs/milestone_1/manager-contract/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/manager-contract/</guid><description>Manager Contract # Before deploying our pool contract, we need to solve one problem. As you remember, Uniswap V3 contracts are split into two categories:
Core contracts that implement the core functions and don&amp;rsquo;t provide user-friendly interfaces. Periphery contracts that implement user-friendly interfaces for the core contracts. The pool contract is a core contract, it&amp;rsquo;s not supposed to be user-friendly and flexible. It expects the caller to do all the calculations (prices, amounts) and to provide proper call parameters.</description></item><item><title>Price Oracle</title><link>https://uniswapv3book.com/docs/milestone_5/price-oracle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_5/price-oracle/</guid><description>Price Oracle # The final mechanism we&amp;rsquo;re going to add to our DEX is a price oracle. Even though it&amp;rsquo;s not essential to a DEX (there are DEXes that don&amp;rsquo;t implement a price oracle), it&amp;rsquo;s still an important feature of Uniswap and something that&amp;rsquo;s interesting to learn about.
What is Price Oracle? # Price oracle is a mechanism that provides asset prices to blockchain. Since blockchains are isolated ecosystems, there&amp;rsquo;s no direct way of querying external data, e.</description></item><item><title>User Interface</title><link>https://uniswapv3book.com/docs/milestone_4/user-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_4/user-interface/</guid><description>User Interface # After introducing swap paths, we can significantly simplify the internals of our web app. First of all, every swap now uses a path since path doesn&amp;rsquo;t have to contain multiple pools. Second, it&amp;rsquo;s now easier to change the direction of swap: we can simply reverse the path. And, thanks to the unified pool address generation via CREATE2 and unique salts, we no longer need to store pool addresses and care about tokens order.</description></item><item><title>A Little Bit More on Fixed-point Numbers</title><link>https://uniswapv3book.com/docs/milestone_3/more-on-fixed-point-numbers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_3/more-on-fixed-point-numbers/</guid><description>A Little Bit More on Fixed-point Numbers # In this bonus chapter, I&amp;rsquo;d like to show you how to convert prices to ticks in Solidity. We don&amp;rsquo;t need to do this in the main contracts, but it&amp;rsquo;s helpful to have such function in tests so we don&amp;rsquo;t hardcode ticks and could write something like tick(5000)–this makes code easier to read because it&amp;rsquo;s more convenient for us to think in prices, not tick indexes.</description></item><item><title>Deployment</title><link>https://uniswapv3book.com/docs/milestone_1/deployment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/deployment/</guid><description>Deployment # Alright, our pool contract is done. Now, let&amp;rsquo;s see how we can deploy it to a local Ethereum network so we could use it from a front-end app later on.
Choosing Local Blockchain Network # Smart contracts development requires running a local network, where you deploy your contracts during development and testing. This is what we want from such a network:
Real blockchain. It must be a real Ethereum network, not an emulation.</description></item><item><title>Generalize Swapping</title><link>https://uniswapv3book.com/docs/milestone_2/generalize-swapping/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/generalize-swapping/</guid><description>Generalize Swapping # This will be the hardest chapter of this milestone. Before updating the code, we need to understand how the algorithm of swapping in Uniswap V3 works.
You can think of a swap as of filling of an order: a user submits an order to buy a specified amount of tokens from a pool. The pool will use the available liquidity to &amp;ldquo;convert&amp;rdquo; the input amount into an output amount of the other token.</description></item><item><title>Tick Rounding</title><link>https://uniswapv3book.com/docs/milestone_4/tick-rounding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_4/tick-rounding/</guid><description>Tick Rounding # Let&amp;rsquo;s review some other changes we need to make to support different tick spacings.
Tick spacing greater than 1 won&amp;rsquo;t allow users to select arbitrary price ranges: tick indexes must be multiples of a tick spacing. For example, for tick spacing 60 we can have ticks: 0, 60, 120, 180, etc. Thus, when user picks a range, we need to &amp;ldquo;round&amp;rdquo; it so its boundaries are multiples of pool&amp;rsquo;s tick spacing.</description></item><item><title>User Interface</title><link>https://uniswapv3book.com/docs/milestone_5/user-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_5/user-interface/</guid><description>User Interface # In this milestone, we&amp;rsquo;ve added the ability to remove liquidity from a pool and collect accumulated fees. Thus, we need to reflect these changes in the user interface to allow users to remove liquidity.
Fetching Positions # To let user choose how much liquidity to remove, we first need to fetch user&amp;rsquo;s positions from a pool. To makes this easier, we can add a helper function to the Manager contract, which will return user position in a specific pool:</description></item><item><title>Flash Loans</title><link>https://uniswapv3book.com/docs/milestone_3/flash-loans/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_3/flash-loans/</guid><description>Flash Loans # Both Uniswap V2 and V3 implement flash loans: unlimited and uncollateralized loans that must be repaid in the same transaction. Pools basically give users arbitrary amounts of tokens that they request, but, by the end of the call, the amounts must be repaid, with a small fee on top.
The fact that flash loans must be repaid in the same transaction means that flash loans cannot be taken by regular users: as a user, you cannot program custom logic in transactions.</description></item><item><title>Quoter Contract</title><link>https://uniswapv3book.com/docs/milestone_2/quoter-contract/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/quoter-contract/</guid><description>Quoter Contract # To integrate our updated Pool contract into the front end app, we need a way to calculate swap amounts without making a swap. Users will type in the amount they want to sell, and we want to calculate and show them the amount they&amp;rsquo;ll get in exchange. We&amp;rsquo;ll do this through Quoter contract.
Since liquidity in Uniswap V3 is scattered over multiple price ranges, we cannot calculate swap amounts with a formula (which was possible in Uniswap V2).</description></item><item><title>User Interface</title><link>https://uniswapv3book.com/docs/milestone_1/user-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/user-interface/</guid><description>User Interface # Finally, we made it to the final stop of this milestone–building a user interface!
Since building a front-end app is not the main goal of this book, I won&amp;rsquo;t show how to build such an app from scratch. Instead, I&amp;rsquo;ll show how to use MetaMask to interact with smart contracts.
If you want to experiment with the app and run it locally, you can fund it in the ui folder in the code repo.</description></item><item><title>User Interface</title><link>https://uniswapv3book.com/docs/milestone_2/user-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/user-interface/</guid><description>User Interface # Let&amp;rsquo;s make our web app work more like a real DEX. We can now remove hardcoded swap amounts and let users type arbitrary amounts. Moreover, we can now let users swap in both direction, so we also need a button to swap the token inputs. After updating, the swap form will look like:
&amp;lt;form className=&amp;#34;SwapForm&amp;#34;&amp;gt; &amp;lt;SwapInput amount={zeroForOne ? amount0 : amount1} disabled={!enabled || loading} readOnly={false} setAmount={setAmount_(zeroForOne ?</description></item><item><title>User Interface</title><link>https://uniswapv3book.com/docs/milestone_3/user-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_3/user-interface/</guid><description>User Interface # We&amp;rsquo;re now ready to update the UI with the changes we made in this milestone. We&amp;rsquo;ll add two new features:
Add Liquidity dialog window; slippage tolerance in swapping. Add Liquidity Dialog # This change will finally remove hard coded liquidity amounts from our code and will allow use to add liquidity at arbitrary ranges.
The dialog is a simple component with a couple of inputs.</description></item></channel></rss>