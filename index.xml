<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Uniswap V3 Development Book</title><link>https://uniswapv3book.com/</link><description>Recent content in Introduction on Uniswap V3 Development Book</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://uniswapv3book.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction</title><link>https://uniswapv3book.com/docs/milestone_1/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/introduction/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] You&amp;rsquo;ll find the complete code of this chapter in this Github branch.
First Swap # In this milestone, we&amp;rsquo;ll build a pool contract that can receive liquidity from users and make swaps within a price range.</description></item><item><title>Introduction</title><link>https://uniswapv3book.com/docs/milestone_2/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/introduction/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] You&amp;rsquo;ll find the complete code of this chapter in this Github branch.
This milestone introduces a lot of code changes in existing contracts.</description></item><item><title>Introduction</title><link>https://uniswapv3book.com/docs/milestone_3/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_3/introduction/</guid><description>You&amp;rsquo;ll find the complete code of this chapter in this Github branch.
This milestone introduces a lot of code changes in existing contracts. Here you can see all changes since the last milestone
Cross-tick Swaps # We have made a great progress so far and our Uniswap V3 implementation is quote close to the original one! However, our implementation only supports swaps within a price range–and this is what we&amp;rsquo;re going to improve in this milestone.</description></item><item><title>Introduction</title><link>https://uniswapv3book.com/docs/milestone_4/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_4/introduction/</guid><description>Multi-pool Swaps # After implementing cross-tick swaps, we&amp;rsquo;ve got really close to real Uniswap V3 swaps. One significant limitation of our implementation is that it allows only swaps within a pool–if there&amp;rsquo;s no pool for a swap of tokens, then swapping between these tokens is not possible. This is not so in Uniswap since it allows multi-pool swaps. In this chapter, we&amp;rsquo;re going to add multi-pool swaps to our implementation.</description></item><item><title>Introduction</title><link>https://uniswapv3book.com/docs/milestone_5/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_5/introduction/</guid><description>Fees and Price Oracle # In this milestone, we&amp;rsquo;re going to add two new features to our Uniswap implementation. They share one similarity: they work on top of what we have already built–that&amp;rsquo;s why we&amp;rsquo;ve delayed them until this milestone. However, they&amp;rsquo;re not equally important.
We&amp;rsquo;re going to add swap fees and a price oracle:
Swap fees is a crucial mechanism of the DEX design we&amp;rsquo;re implementing. They&amp;rsquo;re the glue that makes things stick together.</description></item><item><title>Introduction to markets</title><link>https://uniswapv3book.com/docs/introduction/amm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/introduction/amm/</guid><description>Introduction to markets # How centralized exchanges work # In this book, we&amp;rsquo;ll build a decentralized exchange (DEX) that will run on Ethereum. There&amp;rsquo;re multiple approaches to how an exchange can be designed. All centralized exchanges have an order book at their core. An order book is just a journal that stores all sell or buy orders that traders what to make. Each order in this book contains a price the order must be executed at and the amount that must be bought or sold.</description></item><item><title>Calculating Liquidity</title><link>https://uniswapv3book.com/docs/milestone_1/calculating-liquidity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/calculating-liquidity/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Calculating liquidity # Trading is not possible without liquidity, and to make our first swap we need to put some liquidity into the pool contract.</description></item><item><title>Constant Function Market Makers</title><link>https://uniswapv3book.com/docs/introduction/cfmm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/introduction/cfmm/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Constant Function Market Makers # This chapter retells the whitepaper of Uniswap V2. Understanding this math is crucial to build a Uniswap-like DEX, but it&amp;rsquo;s totally fine if you don&amp;rsquo;t understand everything at this stage.</description></item><item><title>Different Price Ranges</title><link>https://uniswapv3book.com/docs/milestone_3/different-ranges/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_3/different-ranges/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Different Price Ranges # The way we implemented it, our Pool contract creates only price ranges that include the current price:</description></item><item><title>Factory Contract</title><link>https://uniswapv3book.com/docs/milestone_4/factory-contract/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_4/factory-contract/</guid><description>Factory Contract # Uniswap is designed in a way that assumes many discrete Pool contracts, with each pool handling swaps of one token pair. This looks problematic when we want to swap between two tokens that don&amp;rsquo;t have a pool–is there&amp;rsquo;s no pool, no swaps are possible. However, we can still do intermediate swaps: first swap to a token that has pairs with either of the tokens and then swap this token to the target token.</description></item><item><title>Output Amount Calculation</title><link>https://uniswapv3book.com/docs/milestone_2/output-amount-calculation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/output-amount-calculation/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Output Amount Calculation # Our collection of Uniswap math formulas lacks a final piece: the formula of calculating the output amount when selling ETH (that is: selling token $X$).</description></item><item><title>Swap Fees</title><link>https://uniswapv3book.com/docs/milestone_5/swap-fees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_5/swap-fees/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Swap Fees # As a mentioned in the introduction, swap fees is a core mechanism of Uniswap. Liquidity providers need to get paid for the liquidity they provide, otherwise they&amp;rsquo;ll just use it somewhere else.</description></item><item><title>Cross-Tick Swaps</title><link>https://uniswapv3book.com/docs/milestone_3/cross-tick-swaps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_3/cross-tick-swaps/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Cross-Tick Swaps # Cross-tick swaps is probably the most advanced feature of Uniswap V3. Luckily, we have already implemented almost everything we need to make cross-tick swaps.</description></item><item><title>Math in Solidity</title><link>https://uniswapv3book.com/docs/milestone_2/math-in-solidity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/math-in-solidity/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Math in Solidity # Due to Solidity not supporting float-point and fixed-point numbers, math in Solidity is somewhat complicated.</description></item><item><title>Providing Liquidity</title><link>https://uniswapv3book.com/docs/milestone_1/providing-liquidity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/providing-liquidity/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Providing Liquidity # Enough of theory, let&amp;rsquo;s start coding!
Create a new folder (mine is called uniswapv3-code), and run forge init --vscode in it–this will initialize a Forge project.</description></item><item><title>Swap Path</title><link>https://uniswapv3book.com/docs/milestone_4/path/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_4/path/</guid><description>Swap Path # Let&amp;rsquo;s imagine that we have only these pools: WETH/USDC, USDC/USDT, WBTC/USDT. If we want to swap WETH for WBTC, we&amp;rsquo;ll need to make multiple swaps (WETH→USDC→USDT→WBTC) since there&amp;rsquo;s no WETH/WBTC pool. We can do this manually or we can improve our contracts to handle such chained, or multi-pool, swaps. Of course, we&amp;rsquo;ll do the latter!
When doing multi-pool swaps, we&amp;rsquo;re sending output of a previous swap to the input of the next one.</description></item><item><title>Uniswap V3</title><link>https://uniswapv3book.com/docs/introduction/uniswap-v3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/introduction/uniswap-v3/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Introduction to Uniswap V3 # This chapter retells the whitepaper of Uniswap V3. Again, it&amp;rsquo;s totally ok if you don&amp;rsquo;t understand all the concepts.</description></item><item><title>Development Environment</title><link>https://uniswapv3book.com/docs/introduction/dev-environment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/introduction/dev-environment/</guid><description>Development environment # We&amp;rsquo;re going to build two applications:
An on-chain one–a set of smart contracts deployed on Ethereum. An off-chain one–a front-end application that will interact with the smart contracts. While the front-end application development is part of this book, it won&amp;rsquo;t be our main focus. We will build it solely to demonstrate how smart contracts are integrated with front-end applications. You won&amp;rsquo;t need to build it from scratch, I&amp;rsquo;ll provide a template.</description></item><item><title>First Swap</title><link>https://uniswapv3book.com/docs/milestone_1/first-swap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/first-swap/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] First Swap # Now that we have liquidity, we can make our first swap!
Calculating Swap Amounts # First step, of course, is to figure out how to calculate swap amounts.</description></item><item><title>Multi-pool Swaps</title><link>https://uniswapv3book.com/docs/milestone_4/multi-pool-swaps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_4/multi-pool-swaps/</guid><description>Multi-pool Swaps # We&amp;rsquo;re now proceeding to the core of this milestone–implementing multi-pool swaps in our contracts. We won&amp;rsquo;t touch Pool contract in this milestone because it&amp;rsquo;s a core contract that should implement only core features. Multi-pool swaps is a utility feature, and we&amp;rsquo;ll implement it in Manager and Quoter contracts.
Updating Manager Contract # Single-pool and Multi-pool Swaps # In our current implementation, swap function in Manager contract supports only single-pool swaps and takes pool address in parameters:</description></item><item><title>Slippage Protection</title><link>https://uniswapv3book.com/docs/milestone_3/slippage-protection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_3/slippage-protection/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Slippage Protection # Slippage is a very important issued in decentralized exchanges. Slippage simply means the difference between the price that you see on the screen when initialing a transaction and the actual price the swap is executed at.</description></item><item><title>Tick Bitmap Index</title><link>https://uniswapv3book.com/docs/milestone_2/tick-bitmap-index/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/tick-bitmap-index/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Tick Bitmap Index # As the first step towards dynamic swaps, we need to implement an index of ticks.</description></item><item><title>Generalize Minting</title><link>https://uniswapv3book.com/docs/milestone_2/generalize-minting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/generalize-minting/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Generalize Minting # Now, we&amp;rsquo;re ready to update mint function so it calculates the amounts of tokens instead of hard coding them.</description></item><item><title>Liquidity Calculation</title><link>https://uniswapv3book.com/docs/milestone_3/liquidity-calculation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_3/liquidity-calculation/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Liquidity Calculation # Of the whole math of Uniswap V3, what we haven&amp;rsquo;t yet implemented in Solidity is liquidity calculation.</description></item><item><title>Manager Contract</title><link>https://uniswapv3book.com/docs/milestone_1/manager-contract/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/manager-contract/</guid><description>Manager Contract # Before deploying our pool contract, we need to solve one problem. As you remember, Uniswap V3 contracts are split into two categories:
Core contracts that implement the core functions and don&amp;rsquo;t provide user-friendly interfaces. Periphery contracts that implement user-friendly interfaces for the core contracts. The pool contract is a core contract, it&amp;rsquo;s not supposed to be user-friendly and flexible. It expects the caller to do all the calculations (prices, amounts) and to provide proper call parameters.</description></item><item><title>User Interface</title><link>https://uniswapv3book.com/docs/milestone_4/user-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_4/user-interface/</guid><description>User Interface # After introducing swap paths, we can significantly simplify the internal of our web app. First of all, every swap now uses a path since path doesn&amp;rsquo;t have to contain multiple pools. Second, it&amp;rsquo;s now easier to change the direction of swap: we can simply reverse the path. And, thanks to the unified pool address generation via CREATE2 and unique salts, we no longer need to store pool addresses and care about tokens order.</description></item><item><title>A Little Bit More on Fixed-point Numbers</title><link>https://uniswapv3book.com/docs/milestone_3/more-on-fixed-point-numbers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_3/more-on-fixed-point-numbers/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] A Little Bit More on Fixed-point Numbers # In this bonus chapter, I&amp;rsquo;d like to show you how to convert prices to ticks in Solidity.</description></item><item><title>Deployment</title><link>https://uniswapv3book.com/docs/milestone_1/deployment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/deployment/</guid><description>Deployment # Alright, our contract is done. Now, let&amp;rsquo;s see how we can deploy it to a local Ethereum network so we could use it from a front-end app later on.
Choosing Local Blockchain Network # Smart contracts development requires running a local network, where you deploy your contracts during development and testing. This is what we want from such a network:
Real blockchain. It must be a real Ethereum network, not an emulation.</description></item><item><title>Generalize Swapping</title><link>https://uniswapv3book.com/docs/milestone_2/generalize-swapping/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/generalize-swapping/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Generalize Swapping # This will be the hardest chapter of this milestone. Before updating the code, we need to understand how the algorithm of swapping in Uniswap V3 works.</description></item><item><title>Tick Rounding</title><link>https://uniswapv3book.com/docs/milestone_4/tick-rounding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_4/tick-rounding/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Tick Rounding # Let&amp;rsquo;s review some other changes we need to make to support different tick spacings.</description></item><item><title>Quoter Contract</title><link>https://uniswapv3book.com/docs/milestone_2/quoter-contract/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/quoter-contract/</guid><description>Quoter Contract # To integrate our updated Pool contract into the front end app, we need a way to calculate swap amounts without making a swap. Users will type in the amount they want to sell, and we want to calculate and show them the amount they&amp;rsquo;ll get in exchange. We&amp;rsquo;ll do this through Quoter contract.
Since liquidity in Uniswap V3 is scattered over multiple price ranges, we cannot calculate swap amounts with a formula (which was possible in Uniswap V2).</description></item><item><title>User Interface</title><link>https://uniswapv3book.com/docs/milestone_1/user-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/user-interface/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] User Interface # Finally, we made it to the final stop of this milestone–building a user interface!</description></item><item><title>User Interface</title><link>https://uniswapv3book.com/docs/milestone_3/user-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_3/user-interface/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] User Interface # We&amp;rsquo;re now ready to update the UI with the changes we made in this milestone.</description></item><item><title>User Interface</title><link>https://uniswapv3book.com/docs/milestone_2/user-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/user-interface/</guid><description>User Interface # Let&amp;rsquo;s make our web app work more like a real DEX. We can now remove hardcoded swap amounts and let users type arbitrary amounts. Moreover, we can now let users swap in the both direction, so we also need a button to swap the token inputs. After updating, the swap form will look like:
&amp;lt;form className=&amp;#34;SwapForm&amp;#34;&amp;gt; &amp;lt;SwapInput amount={zeroForOne ? amount0 : amount1} disabled={!enabled || loading} readOnly={false} setAmount={setAmount_(zeroForOne ?</description></item></channel></rss>