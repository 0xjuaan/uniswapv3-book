[{"id":0,"href":"/docs/milestone_1/introduction/","title":"Introduction","section":"Milestone 1. First Swap","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]   You\u0026rsquo;ll find the complete code of this chapter in this Github branch.\n First Swap #  In this milestone, we\u0026rsquo;ll build a pool contract that can receive liquidity from users and make swaps within a price range. To keep it as simple as possible, we\u0026rsquo;ll provide liquidity only in one price range and we\u0026rsquo;ll make a swap only in one direction. Also, we\u0026rsquo;ll calculate all the required math manually to get better intuition before starting using mathematical libs.\nLet\u0026rsquo;s model the situation we\u0026rsquo;ll build:\n There will be an ETH-USDC pool contract. ETH will be the $x$ reserve; USDC will be the $y$ reserve. We\u0026rsquo;ll set the current price to 5000 USDC per 1 ETH. The range we\u0026rsquo;ll provide liquidity is 4545-5500 USDC per 1 ETH. We\u0026rsquo;ll buy some ETH from the pool. At this point, since we have only one price range, we want the price of the trade to stay within the price range.  Visually, this model looks like this:\n[TODO: graph the model]\nBefore getting to code, let\u0026rsquo;s figure out the math and calculate all the parameters of the model. To keep things simple, I\u0026rsquo;ll do all math calculations in Python. This will allow us to focus on the calculations without diving into the nuances of mathematical operations in Solidity. This also means that, in smart contracts, we\u0026rsquo;ll hardcode all the amounts and values. This might look like a fake, but we want to start with simple contracts that work.\nFor your convenience, I put all the Python calculations in unimath.py.\n"},{"id":1,"href":"/docs/milestone_2/introduction/","title":"Introduction","section":"Milestone 2. Second Swap","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]   You\u0026rsquo;ll find the complete code of this chapter in this Github branch.\nThis milestone introduces a lot of code changes in existing contracts. Here you can see all changes since the last milestone\n Second Swap #  Alright, this is where it gets real. So far, our implementation has been looking too synthetic and static. We have calculated and hard coded all the amounts to make the learning curve less steep, and now we\u0026rsquo;re ready to make it dynamic. We\u0026rsquo;re going to implement the second swap, that is a swap in the opposite direction: sell ETH to buy USDC. To do this, we\u0026rsquo;re going to improve our smart contracts significantly:\n We need to implement math calculations in Solidity. However, since implementing math in Solidity is tricky due to Solidity supporting only integer division, we\u0026rsquo;ll use third-party libraries. We\u0026rsquo;ll need to let users choose a swap direction, and the pool contract will need to support swapping in either direction. We\u0026rsquo;ll improve the contract and will bring it closer to multi-range swaps, which we\u0026rsquo;ll implement in the next milestone. Finally, we\u0026rsquo;ll update the UI to support swaps in both directions AND out amount calculation! This will require us implementing another contract, Quoter.  In the end of this milestone, we\u0026rsquo;ll have an app that works almost like a real DEX!\nLet\u0026rsquo;s begin!\n"},{"id":2,"href":"/docs/milestone_3/introduction/","title":"Introduction","section":"Milestone 3. Cross-tick Swaps","content":" You\u0026rsquo;ll find the complete code of this chapter in this Github branch.\nThis milestone introduces a lot of code changes in existing contracts. Here you can see all changes since the last milestone\n Cross-tick Swaps #  We have made a great progress so far and our Uniswap V3 implementation is quote close to the original one! However, our implementation only supports swaps within a price range–and this is what we\u0026rsquo;re going to improve in this milestone.\nIn this milestone, we\u0026rsquo;ll:\n update mint function to provide liquidity in different price ranges; update swap function to cross price ranges when there\u0026rsquo;s not enough liquidity in the current price range; learn how to calculate liquidity in smart contracts; implement slippage protection in mint and swap functions; update the UI application to allow to add liquidity at different price ranges; learn a little bit more about fixed-point numbers.  In this milestone, we\u0026rsquo;ll complete swapping, the core functionality of Uniswap!\nLet\u0026rsquo;s begin!\n"},{"id":3,"href":"/docs/milestone_4/introduction/","title":"Introduction","section":"Milestone 4. Multi-pool Swaps","content":"Multi-pool Swaps #  After implementing cross-tick swaps, we\u0026rsquo;ve got really close to real Uniswap V3 swaps. One significant limitation of our implementation is that it allows only swaps within a pool–if there\u0026rsquo;s no pool for a swap of tokens, then swapping between these tokens is not possible. This is not so in Uniswap since it allows multi-pool swaps. In this chapter, we\u0026rsquo;re going to add multi-pool swaps to our implementation. Here\u0026rsquo;s the plan:\n First, we\u0026rsquo;ll learn about and implement Factory contract. Then, we\u0026rsquo;ll see how chained or multi-pool swaps work and implement Path library. Then, we\u0026rsquo;ll update the front-end app to support multi-pool swaps. At this step we\u0026rsquo;ll implement a basic router that finds a path between two tokens. After finishing this chapter, our implementation will be able to handle multi-pool swaps, for example, swapping WBTC for WETH via different stablecoins: WETH → USDC → USDT → WBTC.  Let\u0026rsquo;s begin!\n You\u0026rsquo;ll find the complete code of this chapter in this Github branch.\nThis milestone introduces a lot of code changes in existing contracts. Here you can see all changes since the last milestone\n "},{"id":4,"href":"/docs/introduction/amm/","title":"Introduction to markets","section":"Milestone 0","content":"Introduction to markets #  How centralized exchanges work #  In this book, we\u0026rsquo;ll build a decentralized exchange (DEX) that will run on Ethereum. There\u0026rsquo;re multiple approaches to how an exchange can be designed. All centralized exchanges have an order book at their core. An order book is just a journal that stores all sell or buy orders that traders what to make. Each order in this book contains a price the order must be executed at and the amount that must be bought or sold.\n[TODO: illustration]\nFor trading to happen, there must exist liquidity, which is simply the availability of assets on a market. If you want to buy a wardrobe but no one is selling one, there\u0026rsquo;s no liquidity. If you want to sell a wardrobe but no one wants to buy it, there\u0026rsquo;s liquidity but no buyers. If there\u0026rsquo;s no liquidity, there\u0026rsquo;s nothing to buy or sell.\nOn centralized exchanges, the order book is where liquidity is accumulated. If someone places a sell order, they provide liquidity to the market. If someone places a buy order, they expected the market to have liquidity, otherwise, no trade is possible.\nSince liquidity is not always available, but markets are still interested in trades, entities called market makers were established. A market maker is a firm or an individual who provides liquidity to markets, that is someone who has a lot of money and who buys different assets to sell them on exchanges. For this job, market makers are paid by exchanges.\nHow decentralized exchanges work #  Don\u0026rsquo;t be surprised, decentralized exchanges also need liquidity. And they also need someone who provides it to traders of a wide variety of assets. However, this process cannot be handled in a centralized way. A decentralized solution must exist. There are multiple decentralized solutions and the same solutions are implemented in different ways, but our focus will be on how Uniswap solves this problem.\nAutomated Market Makers #  The evolution of on-chain markets brought us to the idea of Automated Market Makers (AMM). As the name implies, this algorithm works exactly like market makers but in an automated way. Moreover, it\u0026rsquo;s decentralized and permissionless (anyone can use them).\nWhat is an AMM? #  The core idea is pooling-different and not connected groups of people are incentivized to put their assets (tokens) into pools, which are smart contracts. Anyone else can use these pool contracts to trade, thanks to liquidity provided by the first group.\n[TODO: illustration]\nWhat makes this approach different from centralized exchanges is that the smart contracts are fully automated and not managed by anyone. There are no managers, admins, privileged users, etc. There are only liquidity providers and traders, and all the algorithms are programmed and immutable.\n"},{"id":5,"href":"/docs/milestone_1/calculating-liquidity/","title":"Calculating Liquidity","section":"Milestone 1. First Swap","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]  Calculating liquidity #  Trading is not possible without liquidity, and to make our first swap we need to put some liquidity into the pool contract. Here\u0026rsquo;s what we need to know to add liquidity to the pool contract:\n A price range. As a liquidity provider, we want to provide liquidity at a specific price range, and it\u0026rsquo;ll only be used in this range. Amount of liquidity, which is the amounts of two tokens. We\u0026rsquo;ll need to transfer these amounts to the pool contract.  Here, we\u0026rsquo;re going to calculate these manually, but, in a later chapter, a contract will do this for us. Let\u0026rsquo;s begin with a price range.\nPrice Range Calculation #  Recall that, in Uniswap V3, the entire price range is demaracted into ticks: each tick corresponds to a price and has an index. In our first pool implementation, we\u0026rsquo;re going to buy ETH for USDC at the price of $5000 per 1 ETH. Buying ETH will remove some amount of it from the pool and will push the price slightly above $5000. We want to provide liquidity at a range that includes this price. And we want to be sure that the final price will stay within this range (we\u0026rsquo;ll do multi-range swaps in a later chapter).\nWe\u0026rsquo;ll need to find three ticks:\n The current tick will correspond to the current price (5000 USDC for 1 ETH). The lower and upper bounds of the price range we\u0026rsquo;re providing liquidity into. Let the lower price be $4500 and the upper price be $5500.  From the theoretical introduction we know that:\n$$\\sqrt{p} = \\sqrt{\\frac{y}{x}}$$\nSince we\u0026rsquo;ve agreed to use ETH as the $x$ reserve and USDC as the $y$ reserve, the prices at each of the ticks are:\n$$\\sqrt{p_c} = \\sqrt{\\frac{5000}{1}} = \\sqrt{5000} \\approx 70.71$$\n$$\\sqrt{p_l} = \\sqrt{\\frac{4545}{1}} \\approx 67.42$$\n$$\\sqrt{p_u} = \\sqrt{\\frac{5500}{1}} \\approx 74.16$$\nWhere $p_c$ is the current price, $p_l$ is the lower bound of the range, $p_u$ is the upper bound of the range.\nNow, we can find corresponding ticks. We know that prices and ticks are connected via this formula:\n$$\\sqrt{p(i)}=1.0001^{\\frac{i}{2}}$$\nThus, we can find tick $i$ via:\n$$i = log_{\\sqrt{1.0001}} \\sqrt{p(i)}$$\n The square roots in this formula cancel out, but since we\u0026rsquo;re working with $\\sqrt{p}$ we need to preserve them.\n Let\u0026rsquo;s find the ticks:\n Current tick: $i_c = log_{\\sqrt{1.0001}} 70.71 = 85176$ Lower tick: $i_l = log_{\\sqrt{1.0001}} 67.42 = 84222$ Upper tick: $i_u = log_{\\sqrt{1.0001}} 74.16 = 86129$   To calculate these, I used Python:\nimport math  def price_to_tick(p):  return math.floor(math.log(p, 1.0001))  price_to_tick(5000) \u0026gt; 85176 (Feel free using any other language.)\n That\u0026rsquo;s it for price range calculation!\nLast thing to note here is that Uniswap uses Q64.96 number to store $\\sqrt{p}$. This is a fixed point number that has 64 bits for the integer part and 96 bits for the fractional part. In our above calculations, prices are floating point numbers: 70.71, 67.42, 74.16. We need to convert them to Q64.96. Luckily, this is simple: we need to multiply the numbers by the maximum value of the fractional part of Q64.96, which is $2^{96}$. We\u0026rsquo;ll get:\n$$\\sqrt{p_c} = 5602277097478614198912276234240$$\n$$\\sqrt{p_l} = 5314786713428871004159001755648$$\n$$\\sqrt{p_u} = 5875717789736564987741329162240$$\n In Python:\nq96 = 2**96 def price_to_sqrtp(p):  return int(math.sqrt(p) * q96)  price_to_sqrtp(5000) \u0026gt; 5602277097478614198912276234240 Notice that we\u0026rsquo;re multiplying before converting to integer. Otherwise, we\u0026rsquo;ll use precision.\n Ok, we\u0026rsquo;re done here.\nToken Amounts Calculation #  Next step is to decide how many tokens we want to deposit into the pool. The answer is: as many as we want. The amounts are not strictly defined, we can deposit as much as it is enough to buy a small amount of ETH without causing the price leave the price range we put liquidity into. During development and testing we\u0026rsquo;ll be able to mint any amount of tokens, so getting the amounts we want is not a problem.\nFor our first swap, let\u0026rsquo;s deposit 1 ETH and 5000 USDC.\nLiquidity Amount Calculation #  Next, we need to calculate $L$ based on the amounts we\u0026rsquo;ll deposit.\nFrom the theoretical introduction, you remember that: $$L = \\sqrt{xy}$$\nHowever, we cannot simply multiply 1 ETH by 5000 USDC and take the square root. The reason is that the $x$ and $y$ in this formula are virtual reserves. [TODO: what are virtual reserves?]\nWe need to calculate $L$ specifically for the price range we\u0026rsquo;re going to deposit liquidity into, and it\u0026rsquo;ll be calculated based on the amounts we\u0026rsquo;re going to deposit. To find $L$, we need to look at one interesting fact: when the current price equals the lower or the upper price, one of the pool reserves is 0 and all pool\u0026rsquo;s liquidity is in the other reserve. For example, if the current price is $5500 then all ETH was bought from the pool and there\u0026rsquo;s only USDC left. And vice versa: when the current price is $4500 then all USDC was bought from the pool and there\u0026rsquo;s only ETH.\n[TODO: illustrate]\n[TODO: or maybe use the delta x and delta y formulas?] $$\\Delta x = \\frac{L}{\\sqrt{p(i_u)}} - \\frac{L}{\\sqrt{p(i_c)}} = \\frac{L(\\sqrt{p(i_u)} - \\sqrt{p(i_c)})}{\\sqrt{p(i_u)}\\sqrt{p(i_c)}}$$ $$\\Delta y = L\\sqrt{p(i_c)} - L\\sqrt{p(i_l)} = L(\\sqrt{p(i_c)} - \\sqrt{p(i_l)})$$\nKnowing this, let\u0026rsquo;s return to the trading formula of real reserves:\n$$(x + \\frac{L}{\\sqrt{p_b}})(y + L\\sqrt{p_a}) = L^{2}$$\nSo, there are two possible situations:\n $x$ can be 0 when the entire reserve of $x$ is bought from the pool. $y$ can be 0 when the entire reserve of $y$ is bought from the pool.  And these situations also serve as constraints: the amount of $L$ we deposit must satisfy both of them.\nSo, to find $L$, we need to calculate it in both of these scenarios. Let\u0026rsquo;s begin with the one where $y$ is zero. The trade function will look like so:\n$$(x+\\frac{L}{\\sqrt{p_b}})L\\sqrt{p_a} = L^{2}$$\nWhen $y$ is zero, any trade will add some $\\Delta y$ ($L\\sqrt{p_a}$) to the empty reserve of $y$, and no buying of $y$ in this situation is possible.\nNext, we can find $L$:\n$$L = x\\frac{\\sqrt{p_a}\\sqrt{p_b}}{\\sqrt{p_b}-\\sqrt{p_a}}$$\nNow, let\u0026rsquo;s find a similar formula for the situation when $x$ is zero:\n$$\\frac{L}{\\sqrt{p_b}}(y + L\\sqrt{p_a}) = L^{2}$$ $$L = \\frac{y}{\\sqrt{p_b}-\\sqrt{p_a}}$$\n[TODO: show the calculations]\nHaving these two $L\u0026rsquo;s$, we need to choose one of them and we\u0026rsquo;ll choose the smaller one. Why? The amount of liquidity we deposit must allow equally big price movements in both directions. If we pick the bigger amount, the other on won\u0026rsquo;t be enough to satisfy this requirement.\nNow, let\u0026rsquo;s plug our numbers into the formulas. For $x$, $p_a$ is the current price, and $p_b$ is the upper bound of the price range. For $y$, $p_a$ is the lower bound and $p_b$ is the current price.\n[TODO: add graph, x_real, y_real, from the whitepaper]\n$$L = x\\frac{\\sqrt{p_a}\\sqrt{p_b}}{\\sqrt{p_b}-\\sqrt{p_a}} = 1 ETH * \\frac{67.42 * 70.71}{70.71 - 67.42}$$ After converting to Q64.96, we get:\n$$L = 1519437308014769733632$$\nSolving the other $L$: $$L = \\frac{y}{\\sqrt{p_b}-\\sqrt{p_a}} = \\frac{5000USDC}{74.16-70.71}$$ $$L = 1517882343751509868544$$\n In Python:\nsqrtp_low = price_to_sqrtp(4545) sqrtp_cur = price_to_sqrtp(5000) sqrtp_upp = price_to_sqrtp(5500)  def liquidity0(amount, pa, pb):  if pa \u0026gt; pb:  pa, pb = pb, pa  return (amount * (pa * pb) / q96) / (pb - pa)  def liquidity1(amount, pa, pb):  if pa \u0026gt; pb:  pa, pb = pb, pa  return amount * q96 / (pb - pa)  liq0 = liquidity0(amount_eth, sqrtp_cur, sqrtp_upp) liq1 = liquidity1(amount_usdc, sqrtp_cur, sqrtp_low) liq = int(min(liq0, liq1)) \u0026gt; 1517882343751509868544  Of these two we\u0026rsquo;re picking the smaller one, 1517882343751509868544.\nToken Amounts Calculation, Again #  Since we choose the amounts we\u0026rsquo;re going to deposit, the amounts can be wrong. We cannot deposit any amounts at any price ranges; liquidity amounts need to aligned with the shape of curve in the price range we\u0026rsquo;re depositing into. Thus, even though users choose amounts, the contract needs to re-calculate them, and actual amounts will be slightly different (at least because of rounding). Luckily, we can re-use the formulas from the previous paragraph:\n$$L = x\\frac{\\sqrt{p_a}\\sqrt{p_b}}{\\sqrt{p_b}-\\sqrt{p_a}}$$ $$L = \\frac{y}{\\sqrt{p_b}-\\sqrt{p_a}}$$\nFrom them, we can find $x$ and $y$:\n$$ x = \\frac{L(\\sqrt{p_b}-\\sqrt{p_a})}{\\sqrt{p_b}\\sqrt{p_a}}$$ $$ y = L(\\sqrt{p_b}-\\sqrt{p_a}) $$\n In Python:\ndef calc_amount0(liq, pa, pb):  if pa \u0026gt; pb:  pa, pb = pb, pa  return int(liq * q96 * (pb - pa) / pa / pb)   def calc_amount1(liq, pa, pb):  if pa \u0026gt; pb:  pa, pb = pb, pa  return int(liq * (pb - pa) / q96)  amount0 = calc_amount0(liq, sqrtp_upp, sqrtp_cur) amount1 = calc_amount1(liq, sqrtp_low, sqrtp_cur) (amount0, amount1) \u0026gt; (998976618347425408, 5000000000000000000000) As you can see, the number are close to the amounts we want to provide, but ETH is slightly smaller.\n  Hint: use cast --from-wei AMOUNT to convert from wei to ether. For example:\ncast --from-wei 998976618347425280 will give you 0.998976618347425280.\n To sum it up, when providing liquidity, users:\n choose the price range they want to provide liquidity into, choose the amounts of tokens they want to provide.  Contracts then:\n calculate $L$ based on the amounts and the price range chosen by the user, calculate exact amounts the user needs to deposit.  The amounts users choose are upper bounds, and contracts guarantee that users won\u0026rsquo;t send more tokens than they\u0026rsquo;ve chosen. We\u0026rsquo;ll see how this works in a later milestone.\n"},{"id":6,"href":"/docs/introduction/cfmm/","title":"Constant Function Market Makers","section":"Milestone 0","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]  Constant Function Market Makers #   This chapter retells the whitepaper of Uniswap V2. Understanding this math is crucial to build a Uniswap-like DEX, but it\u0026rsquo;s totally fine if you don\u0026rsquo;t understand everything at this stage.\n As I mentioned in the previous section, there are different approaches to building AMM. We\u0026rsquo;ll be focusing on and building one specific type of AMM–Constant Function Market Maker. Don\u0026rsquo;t be scared by the long name! At its core is a very simple mathematical formula:\n$$x * y = k$$\nThat\u0026rsquo;s it, that\u0026rsquo;s the formula.\n$x$ and $y$ are pool contract reserves–the amounts of tokens it currently holds. k is just their product, actual value doesn\u0026rsquo;t matter.\n Why there are only two reserves, x and y?\nEach Uniswap pool can hold only two tokens. We use x and y to refer to reserves of one pool, where x is the reserve of the first token and y is the reserve of the other token, and the order doesn\u0026rsquo;t matter.\n The constant function formula says: after each trade, k must remain unchanged. When traders make trades, they put some amount of one token into a pool (token they want to sell) and remove some amount of the other token from the pool (token they want to buy). This changes the reserves of the pool, and the constant function formula says that the product of reserves must not change. As we will see many times in this book, this simple requirement is the core algorithm of the exchange we\u0026rsquo;re building.\nThe trade function #  Now that we know what pools are, let\u0026rsquo;s write the formula of how trading happens in a pool:\n$$(x + r\\Delta x)(y - \\Delta y) = k$$\n[TODO: illustration]\n There\u0026rsquo;s a pool with some amount of token X ($x$) and some amount of token Y ($y$). When we buy token Y for token X, we give some amount of token X to the pool ($\\Delta x$). The pool gives us some amount of token Y in exchange ($\\Delta y$). The pool also takes a small fee from the amount of token X we gave ($r$). The reserve of token X changes ($x + r \\Delta x$), and the reserve of token Y changes as well ($y - \\Delta y$). The product of updated reserves must still equal $k$.  The order of tokens in the formula doesn\u0026rsquo;t matter: Uniswap pools allow swapping tokens in both directions.\nPricing #  How do we calculate the prices of tokens in a pool?\nSince Uniswap pools are separate smart contracts, tokens in a pool are priced in terms of each other. For example: in USDC-ETH pool, ETH is priced in terms of USDC and USDC is priced in terms of ETH. If 1 ETH costs 1000 USDC, then 1 USDC costs 0.001 ETH. The same is true for any other pool, whether it\u0026rsquo;s a stablecoin pair or not. And actual token prices are simply relations of reserves:\n$$P_x = \\frac{y}{x}, \\quad P_y=\\frac{x}{y}$$\nWhere $P_x$ and $P_y$ are prices of tokens in terms of the other token. Such prices are called spot prices and they only reflect current market prices. However, the actual price of a trade is calculated differently. Let\u0026rsquo;s return to the trade function and try to come up with some conclusions about how an actual trade price is calculated:\n$$(x + r\\Delta x)(y - \\Delta y) = k$$\nSuppose we want to find the price of token X (its reserve is $x$ in the formula) when swapping it for token Y (its reserve is $y$ in the formula). We\u0026rsquo;re trading in some amount of token X ($\\Delta x$) in exchange for some amount of token Y ($\\Delta y$). This means that the actual price of the trade will be the relation of the amounts. Not the reserves, but the amounts we give and get.\nLet\u0026rsquo;s rewrite the trade function to find out trade amounts:\n First, we write $k$ as the product of reserves before a trade: $$(x + r\\Delta x)(y - \\Delta y) = xy$$ On the left side, is the product of updated reserves (after a swap). On the right side, is the product of current reserves (before a swap). Then, we can find $\\Delta y$ using simple algebraic operations: $$\\Delta y = \\frac{yr\\Delta x}{x + r\\Delta x}$$ [TODO: explain] Similarly, we can express $\\Delta x$ in terms of $\\Delta y$: $$\\Delta x = \\frac{x \\Delta y}{r(y - \\Delta y)}$$ [TODO: explain]  Having these functions, we don\u0026rsquo;t need to calculate prices because we can calculate amounts instead! If we know how many tokens we want to sell, we can calculate the amount we\u0026rsquo;ll get without calculating the price. And vice versa: if we want to buy a specific amount of tokens, we can calculate the amount we need to sell right away, without calculating the price.\nLast thing to notice here is that the trade function can be rewritten using geometric means. So this formula: $$(x + r\\Delta x)(y - \\Delta y) = xy$$\nBecomes this: $$\\sqrt[n]{\\prod_{i=1}^n X_i\u0026rsquo;} = \\sqrt[n]{\\prod_{i=1}^n X_i}$$\nWhere: $n=2$ (since we have only two tokens in a pool), $X_i$ is current reserves ($X_1 = x, X_2=y$), $X_i\u0026rsquo;$ is updated reserves. This is a general representation of the trade function, Uniswap\u0026rsquo;s implementation is a special case of this formula.\nThe Curve #  The above calculations might seem too abstract and dry. Let\u0026rsquo;s visualize the constant product function to better understand how it works\nWhen plotted, the constant product function is a quadratic hyperbola:\n[TODO: add graph]\nWhere axes are reserves. Every trade starts at the point on the curve that corresponds to the current ratio of reserves. To calculate the output amount, we need to find a new point on the curve, which has the $x$ coordinate of $x+\\Delta x$, i.e. current reserve of token X + the amount we\u0026rsquo;re selling. The change in $y$ is the number of tokens B we\u0026rsquo;ll get.\nLet\u0026rsquo;s look at a concrete example:\n[TODO: add graph]\n Start price ($P_x = \\frac{y}{x}$) is 4: 1 X = 4 Y. We\u0026rsquo;re selling 42 X. If we use only the start price, we expect to get 42 * 4 = 168 Y. However, the execution price is 2.173, so we get only 91.304 Y!   To build a better intuition of how it works, try making up several scenario and plot them on the graph. Try different X amount relative to the reserve of X, see how output amount changes hen $\\Delta x$ is small relative to $x$.\n  This wonderful chart was created by Dan Robinson, one of the creators of Uniswap. Massive kudos!\n I bet you\u0026rsquo;re wondering why using such a curve? It might seem like it punishes you for trading big amounts. This is true, and this is a desirable property! The law of supply and demand tells us that when demand is high (and supply is constant) the price is also high. And when demand is low, the price is also lower. This is how markets work. And, magically, the constant product function implements this mechanism! Demand is defined by the amount you want to buy, and supply is the pool reserves. When you want to buy a big amount relative to pool reserves the price is higher than when you want to buy a smaller amount. Such a simple formula guarantees such a powerful mechanism!\nEven though Uniswap doesn\u0026rsquo;t calculate trade prices, we can still see them on the curve. Surprisingly, there are multiple prices when making a trade:\n[TODO: tell about prices on the curve, tangent lines]\n Before a trade, there\u0026rsquo;s a spot price. It\u0026rsquo;s equal to the relation of reserves, $y/x$ or $x/y$ depending on the order of the trade. This price is also the slope of the tangent line at the starting point. After a trade, there\u0026rsquo;s a new spot price, at a different point on the curve. And it\u0026rsquo;s the slope of the tangent line at this new point. The actual price of the trade is the slope of the line connecting the two points!  And that\u0026rsquo;s the whole math of Uniswap! Phew!\nWell, this is the math of Uniswap V2, and we\u0026rsquo;re studying Uniswap V3. So in the next part, we\u0026rsquo;ll see how the mathematics of Uniswap V3 is different.\n"},{"id":7,"href":"/docs/milestone_3/different-ranges/","title":"Different Price Ranges","section":"Milestone 3. Cross-tick Swaps","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]  Different Price Ranges #  The way we implemented it, our Pool contract creates only price ranges that include the current price:\n// src/UniswapV3Pool.sol function mint(  ...  amount0 = Math.calcAmount0Delta(  TickMath.getSqrtRatioAtTick(slot0_.tick),  TickMath.getSqrtRatioAtTick(upperTick),  amount  );   amount1 = Math.calcAmount1Delta(  TickMath.getSqrtRatioAtTick(slot0_.tick),  TickMath.getSqrtRatioAtTick(lowerTick),  amount  );   liquidity += uint128(amount);  ... } From this piece you can also see that we always update the liquidity tracker (which tracks only currently available liquidity, i.e. liquidity available at the current price).\nHowever, in reality, price ranges can also be created below or above the current price. That\u0026rsquo;s it: the design of Uniswap V3 allows liquidity provider to provide liquidity that doesn\u0026rsquo;t get immediately used; such liquidity gets \u0026ldquo;injected\u0026rdquo; when current price gets into the \u0026ldquo;sleeping\u0026rdquo; price ranges.\nThese are kinds of price ranges that can exist:\n Active price range, i.e. one that includes current price. Price range placed below current price. The upper tick of this range is below the current tick. Price range placed above current price. The lower tick of this range is above the current tick.  Limit Orders #  An interesting fact about inactive liquidity (i.e. liquidity not provided at current price) is that it acts as limit orders.\nIn trading, limit orders are orders that get executed when price crosses a level chosen by trader. For example, you can place a limit order that buys 1 ETH when its price drops to $1000. Similarly, you can use limit order to sell assets. With Uniswap V3, you can get similar behavior by placing liquidity at ranges that are below or above current price. Let\u0026rsquo;s see how this works:\n[TODO: illustrate liquidity to the left and to the right of the current price]\nIf you provide liquidity below current price (i.e. the price range you chose lays entirely below the current price) or above it, then your whole liquidity will be composed of only one asset–the asset will be the cheapest one of the two. In our example, we\u0026rsquo;re building a pool with ETH being token $X$ and USDC being token $Y$, and we define the price as:\n$$P = \\frac{y}{x}$$\nIf we put liquidity below current price, then the liquidity will be composed of USDC solely because, where we added the liquidity, the price of USDC is lower than the current price. Likewise, when we put liquidity above current price, then the liquidity will be composed of ETH because ETH is cheaper in that range.\nIf this sounds confusing, let\u0026rsquo;s look at one price range in isolation:\n[TODO: illustrate a price range, curve with current/lower/upper prices]\nIf we buy all available amount of token $X$ from this range, the range will contain only the other token, token $Y$, and the price will move to the left of the curve. The price, as we defined it, will increase. If there\u0026rsquo;s a price range to the left of this one, it needs to have $X$ liquidity, and only $X$, not $Y$: it needs to provide $Y$ for our swap. If we keep buying and rising the price, we might \u0026ldquo;drain\u0026rdquo; this price as well, which means buying all its $X$ tokens and selling $Y$ tokens. Again, the price range ends up having only $Y$ token and current price moves outside of it.\nSimilarly, if we\u0026rsquo;re buying $Y$ token, we move the price to the right and removing $Y$ tokens from the pool. The next price range will only contain $Y$ tokens to satisfy our demand, and, similarly to the above scenario, will contain only $X$ tokens if we buy all $Y$ tokens from it.\nNote the interesting fact: when crossing an entire price range, it\u0026rsquo;s liquidity is swapped from one token to another. And if we set a very narrow price range, one that gets crossed quickly during a price move, we get a limit order! For example, if you want to buy ETH at a lower price, you need to place a price range containing only USDC at the lower price and wait for current price to cross it. After that, you\u0026rsquo;ll need to remove your liquidity and get it whole converted to ETH!\nI hope this didn\u0026rsquo;t confuse you! Let\u0026rsquo;s get to code.\nUpdating mint Function #  To support all the kings of price ranges, we need to current price is below, inside, or above the price range specified by user and calculate token amounts accordingly. If the price range is above the current price, we want the liquidity to be composed of token $X$:\n// src/UniswapV3Pool.sol function mint(  ...  if (slot0_.tick \u0026lt; lowerTick) {  amount0 = Math.calcAmount0Delta(  TickMath.getSqrtRatioAtTick(lowerTick),  TickMath.getSqrtRatioAtTick(upperTick),  amount  );  ... When the price range includes the current price, we want both tokens in amounts proportional to the price (this is the scenario we implemented earlier):\n} else if (slot0_.tick \u0026lt; upperTick) {  amount0 = Math.calcAmount0Delta(  TickMath.getSqrtRatioAtTick(slot0_.tick),  TickMath.getSqrtRatioAtTick(upperTick),  amount  );   amount1 = Math.calcAmount1Delta(  TickMath.getSqrtRatioAtTick(slot0_.tick),  TickMath.getSqrtRatioAtTick(lowerTick),  amount  );   liquidity = LiquidityMath.addLiquidity(liquidity, int128(amount)); Notice that this is the only scenario where we want to update liquidity since the variable tracks liquidity that\u0026rsquo;s available immediately.\nIn all other cases, when the price range is below the current price, we want the range to contain only token $Y$:\n} else {  amount1 = Math.calcAmount1Delta(  TickMath.getSqrtRatioAtTick(lowerTick),  TickMath.getSqrtRatioAtTick(upperTick),  amount  ); } And that\u0026rsquo;s it!\n"},{"id":8,"href":"/docs/milestone_2/output-amount-calculation/","title":"Output Amount Calculation","section":"Milestone 2. Second Swap","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]  Output Amount Calculation #  Our collection of Uniswap math formulas lacks a final piece: the formula of calculating the output amount when selling ETH (that is: selling token $X$). In the previous milestone, we had an analogous formula for the scenario when ETH is bought (buying token $X$):\n$$\\Delta \\sqrt{P} = \\frac{\\Delta y}{L}$$\nThis formula finds the change in the price when selling token $Y$. We then added this change to the current price to find the target price:\n$$\\sqrt{P_{target}} = \\sqrt{P_{current}} + \\Delta \\sqrt{P}$$\nNow, we need a similar formula to find the target price when selling token $X$ (ETH in our case) and buying token $Y$ (USDC in our case).\nRecall that the change in token $X$ can be calculated as:\n$$\\Delta x = \\Delta \\frac{1}{\\sqrt{P}}L$$\nFrom this formula, we can find the target price:\n$$\\Delta x = (\\frac{1}{\\sqrt{P_{target}}} - \\frac{1}{\\sqrt{P_{current}}}) L$$ $$= \\frac{L}{\\sqrt{P_{target}}} - \\frac{L}{\\sqrt{P_{current}}}$$\nFrom this, we can find $\\sqrt{P_{target}}$ using basic algebraic transformations:\n$$\\sqrt{P_{target}} = \\frac{\\sqrt{P}L}{\\Delta x \\sqrt{P} + L}$$\nKnowing the target price, we can find the output amount similarly to how we found it in the previous milestone.\nLet\u0026rsquo;s update our Python script with the new formula:\n# Swap ETH for USDC amount_in = 0.01337 * eth  print(f\u0026#34;\\nSelling {amount_in/eth}ETH\u0026#34;)  price_next = int((liq * q96 * sqrtp_cur) // (liq * q96 + amount_in * sqrtp_cur))  print(\u0026#34;New price:\u0026#34;, (price_next / q96) ** 2) print(\u0026#34;New sqrtP:\u0026#34;, price_next) print(\u0026#34;New tick:\u0026#34;, price_to_tick((price_next / q96) ** 2))  amount_in = calc_amount0(liq, price_next, sqrtp_cur) amount_out = calc_amount1(liq, price_next, sqrtp_cur)  print(\u0026#34;ETH in:\u0026#34;, amount_in / eth) print(\u0026#34;USDC out:\u0026#34;, amount_out / eth) Its output:\nSelling 0.01337 ETH New price: 4993.777388290041 New sqrtP: 5598789932670289186088059666432 New tick: 85163 ETH in: 0.013369999999998142 USDC out: 66.80838889019013 Which means that we\u0026rsquo;ll get 66.8 USDC when selling 0.01337 ETH using the liquidity we provided in the previous step.\n Now, we\u0026rsquo;going to implement all the mathematical formulas in Solidity.\n"},{"id":9,"href":"/docs/milestone_3/cross-tick-swaps/","title":"Cross-Tick Swaps","section":"Milestone 3. Cross-tick Swaps","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]  Cross-Tick Swaps #  Cross-tick swaps is probably the most advanced feature of Uniswap V3. Luckily, we have already implemented almost everything we need to make cross-tick swaps. Let\u0026rsquo;s review how swapping works in our current implementation.\nHow Cross-Tick Swaps Work #  Let\u0026rsquo;s recap how cross-tick swaps work before getting down to code.\n[TODO: illustrate a pool with multiple price ranges]\nA common Uniswap V3 pool is a pool with many overlapping (and outstanding) price ranges. Each pool tracks current $\\sqrt{P}$ and tick. When users swap tokens they move current price and tick to the left or to the right of the current ones, depending on swap direction. These movements are caused by liquidity being added and removed from pools during swaps.\nPools also track $L$ (liquidity variable in our code), which is the sum of liquidity provided by all price ranges that include current price. It\u0026rsquo;s expected that, during big price moves, current price moves outside of price ranges. When this happens, such price ranges become inactive and their liquidity gets subtracted from $L$. On the other hand, when current price enters a price range, $L$ is increased and the price range gets activated.\nOur current implementation doesn\u0026rsquo;t support such fluidity: we only allow swaps within one active price range. This is what we\u0026rsquo;re going to fix.\nUpdating computeSwapStep Function #  In swap function, we\u0026rsquo;re iterating over initialized ticks (that is, ticks with liquidity) to fill the amount user has requested. In each iteration, we:\n find next initialized tick using tickBitmap.nextInitializedTickWithinOneWord; swapping in the range between the current price and the next initialized tick (using SwapMath.computeSwapStep); always expect that current liquidity is enough to satisfy the swap (i.e. the price after swap is between the current price and the next initialized tick).  But what happens if the third step is not true? We have this scenario covered in tests:\n// test/UniswapV3Pool.t.sol function testSwapBuyEthNotEnoughLiquidity() public {  ...   uint256 swapAmount = 5300 ether;   ...   vm.expectRevert(stdError.arithmeticError);  pool.swap(address(this), false, swapAmount, extra); } The \u0026ldquo;Arithmetic over/underflow\u0026rdquo; happens when trying to transfer an amount that\u0026rsquo;s too big (not approved by user). This happens because, when calculating a swap step, we always expect that next initialized tick always have enough liquidity to satisfy the swap:\n// src/lib/SwapMath.sol function computeSwapStep(...) {  ...   sqrtPriceNextX96 = Math.getNextSqrtPriceFromInput(  sqrtPriceCurrentX96,  liquidity,  amountRemaining,  zeroForOne  );   amountIn = ...  amountOut = ... } To fix this, we need to pre-calculate the output amount and compare it with the amount requested (amountRemaining): if it\u0026rsquo;s smaller, then the next initialized tick doesn\u0026rsquo;t have enough liquidity. If it\u0026rsquo;s equal to amountRemaining, then it\u0026rsquo;s safe to assume that the next initialized tick has enough liquidity.\nHere\u0026rsquo;s how to fix it:\n// src/lib/SwapMath.sol function computeSwapStep(...) {  ...  amountIn = zeroForOne  ? Math.calcAmount0Delta(  sqrtPriceCurrentX96,  sqrtPriceTargetX96,  liquidity  )  : Math.calcAmount1Delta(  sqrtPriceCurrentX96,  sqrtPriceTargetX96,  liquidity  );   if (amountRemaining \u0026gt;= amountIn) sqrtPriceNextX96 = sqrtPriceTargetX96;  else  sqrtPriceNextX96 = Math.getNextSqrtPriceFromInput(  sqrtPriceCurrentX96,  liquidity,  amountRemaining,  zeroForOne  );   amountIn = Math.calcAmount0Delta(  sqrtPriceCurrentX96,  sqrtPriceNextX96,  liquidity  );  amountOut = Math.calcAmount1Delta(  sqrtPriceCurrentX96,  sqrtPriceNextX96,  liquidity  ); } We first pre-calculate amountIn depending on swap direction. Then, we check if this amount is enough to satisfy the swap: if so, we\u0026rsquo;re calculating $\\sqrt{P}$ of the new price; if not, we\u0026rsquo;re calculating only the amounts that can be provided by this price range–on the next iteration, we\u0026rsquo;ll try to fill the remaining amount.\nI hope this makes sense!\nUpdating swap Function #  Now, in swap function, we need to handle the case we introduced in the previous part: when swap price reaches a boundary of a price range. When this happens, we want to deactivate the price range we\u0026rsquo;re leaving and active the next price range. We also want to start the next iteration of the loop with the initialized tick we found in this loop.\nHere\u0026rsquo;s what we need to add to the end of the loop:\nif (state.sqrtPriceX96 == step.sqrtPriceNextX96) {  int128 liquidityDelta = ticks.cross(step.nextTick);   if (zeroForOne) liquidityDelta = -liquidityDelta;   state.liquidity = LiquidityMath.addLiquidity(  state.liquidity,  liquidityDelta  );   if (state.liquidity == 0) revert NotEnoughLiquidity();   state.tick = zeroForOne ? step.nextTick - 1 : step.nextTick; } else {  state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96); } The second branch is what we had before–it handles the case when current price stays within the range. So let\u0026rsquo;s focus on the first one.\nstate.sqrtPriceX96 is updated current price, i.e. the price that will be set after the current swap; step.sqrtPriceNextX96 is the price at the next initialized tick. If these are equal, we have reached a price range boundary. As discussed above, when this happens, we want to update $L$ (add or remove liquidity) and continue the swap using the boundary tick as the current tick.\nFor convenience, crossing a tick means crossing it from left to right. Thus, lower ticks always add liquidity and upper ticks always remove it. However, when zeroForOne is true, we negate the sign: when price goes down (token $X$ is being sold), upper ticks add liquidity and lower ticks remove it.\nWhen updating state.tick, if price moves down (zeroForOne is true), we need to subtract 1 to step out of the price range. When moving up (zeroForOne is false), current tick is always excluded in TickBitmap.nextInitializedTickWithinOneWord.\nAnother small, but very important, change that we need to make is to update $L$ when swapping caused ticks crossing:\nif (liquidity_ != state.liquidity) liquidity = state.liquidity; We do this after the loop.\nLiquidity Tracking and Ticks Crossing #  Let\u0026rsquo;s now look at updated Tick library.\nFirst change is in Tick.Info structure: we now have two variables to track tick liquidity:\nstruct Info {  bool initialized;  // total liquidity at tick  uint128 liquidityGross;  // amount of liqudiity added or subtracted when tick is crossed  int128 liquidityNet; } liquidityGross tracks the absolute liquidity amount of a tick. It\u0026rsquo;s needed to find if tick was flipped or not. liquidityNet, on the other hand, is a signed integer–it tracks the amount of liquidity added (in case of lower tick) or removed (in case of upper tick) when a tick is crossed.\nliquidityNet is set in update function:\nfunction update(  mapping(int24 =\u0026gt; Tick.Info) storage self,  int24 tick,  int128 liquidityDelta,  bool upper ) internal returns (bool flipped) {  ...   tickInfo.liquidityNet = upper  ? int128(int256(tickInfo.liquidityNet) - liquidityDelta)  : int128(int256(tickInfo.liquidityNet) + liquidityDelta); } The cross function we saw above simply returns liquidityNet:\nfunction cross(mapping(int24 =\u0026gt; Tick.Info) storage self, int24 tick)  internal  view  returns (int128 liquidityDelta) {  Tick.Info storage info = self[tick];  liquidityDelta = info.liquidityNet; } Testing #  Let\u0026rsquo;s review different liquidity setups and test them to ensure our pool implementation can handle them correctly.\nOne Price Range #  [TODO: illustrate one price range with current price]\nThis is the scenario we had earlier. After we have updated the code, we need to ensure old functionality keeps working correctly.\n For brevity, I\u0026rsquo;ll show only most important parts of the tests. You can find full tests in the code repo.\n  When buying ETH: function testBuyETHOnePriceRange() public {  LiquidityRange[] memory liquidity = new LiquidityRange[](1);  liquidity[0] = liquidityRange(4545, 5500, 1 ether, 5000 ether, 5000);   ...   (int256 expectedAmount0Delta, int256 expectedAmount1Delta) = (  -0.008396874645169943 ether,  42 ether  );   assertSwapState(  ExpectedStateAfterSwap({  ...  sqrtPriceX96: 5604415652688968742392013927525, // 5003.8180249710795  tick: 85183,  currentLiquidity: liquidity[0].amount  })  ); }  When buying USDC: function testBuyUSDCOnePriceRange() public {  LiquidityRange[] memory liquidity = new LiquidityRange[](1);  liquidity[0] = liquidityRange(4545, 5500, 1 ether, 5000 ether, 5000);   ...   (int256 expectedAmount0Delta, int256 expectedAmount1Delta) = (  0.01337 ether,  -66.807123823853842027 ether  );   assertSwapState(  ExpectedStateAfterSwap({  ...  sqrtPriceX96: 5598737223630966236662554421688, // 4993.683362269102  tick: 85163,  currentLiquidity: liquidity[0].amount  })  ); }   In both of these scenario we buy a small amount of EHT or USDC–it needs to be small enough for the price to not leave the only price range we created. Key values after swapping is done:\n sqrtPriceX96 is slightly above or below the initial price and stays within the price rage; currentLiquidity remains unchanged.   In the theoretical Uniswap V3 introduction, we discussed that $L$ doesn\u0026rsquo;t change when swapping happens within a price range. We now can see this in practice.\n Multiple Identical and Overlapping Price Ranges #  [TODO: illustrate]\n  When buying ETH:\nfunction testBuyETHTwoEqualPriceRanges() public {  LiquidityRange memory range = liquidityRange(  4545,  5500,  1 ether,  5000 ether,  5000  );  LiquidityRange[] memory liquidity = new LiquidityRange[](2);  liquidity[0] = range;  liquidity[1] = range;   ...   (int256 expectedAmount0Delta, int256 expectedAmount1Delta) = (  -0.008398516982770993 ether,  42 ether  );   assertSwapState(  ExpectedStateAfterSwap({  ...  sqrtPriceX96: 5603319704133145322707074461607, // 5001.861214026131  tick: 85179,  currentLiquidity: liquidity[0].amount + liquidity[1].amount  })  ); }   When buying USDC:\nfunction testBuyUSDCTwoEqualPriceRanges() public {  LiquidityRange memory range = liquidityRange(  4545,  5500,  1 ether,  5000 ether,  5000  );  LiquidityRange[] memory liquidity = new LiquidityRange[](2);  liquidity[0] = range;  liquidity[1] = range;   ...   (int256 expectedAmount0Delta, int256 expectedAmount1Delta) = (  0.01337 ether,  -66.827918929906650442 ether  );   assertSwapState(  ExpectedStateAfterSwap({  ...  sqrtPriceX96: 5600479946976371527693873969480, // 4996.792621611429  tick: 85169,  currentLiquidity: liquidity[0].amount + liquidity[1].amount  })  ); }   This scenario is similar to the previous one but this time we create two identical price ranges. Two moments are important here:\n Price impact is lower than in the previous scenario. The more liquidity the lower the price range. Current liquidity is the sum of the two price ranges. This is because both of them include the current price.  Also, we get slightly more tokens thanks to deeper liquidity.\nConsecutive Price Ranges #  [TODO: illustrate both scenarios]\n When buying ETH: function testBuyETHConsecutivePriceRanges() public {  LiquidityRange[] memory liquidity = new LiquidityRange[](2);  liquidity[0] = liquidityRange(4545, 5500, 1 ether, 5000 ether, 5000);  liquidity[1] = liquidityRange(5500, 6250, 1 ether, 5000 ether, 5000);   ...   (int256 expectedAmount0Delta, int256 expectedAmount1Delta) = (  -1.820694594787485635 ether,  10000 ether  );   assertSwapState(  ExpectedStateAfterSwap({  ...  sqrtPriceX96: 6190476002219365604851182401841, // 6105.045728033458  tick: 87173,  currentLiquidity: liquidity[1].amount  })  ); }  When buying USDC: function testBuyUSDCConsecutivePriceRanges() public {  LiquidityRange[] memory liquidity = new LiquidityRange[](2);  liquidity[0] = liquidityRange(4545, 5500, 1 ether, 5000 ether, 5000);  liquidity[1] = liquidityRange(4000, 4545, 1 ether, 5000 ether, 5000);   ...   (int256 expectedAmount0Delta, int256 expectedAmount1Delta) = (  2 ether,  -9103.264925902176327184 ether  );   assertSwapState(  ExpectedStateAfterSwap({  ...  sqrtPriceX96: 5069962753257045266417033265661, // 4094.9666586581643  tick: 83179,  currentLiquidity: liquidity[1].amount  })  ); }   In these scenarios, we make big swaps that cause price to move outside of a price range. As a result, the second price range gets activated and provides enough liquidity to satisfy the swap. In both scenarios, we can see that price lands outside of the shorted price range and that the short price range gets deactivated (current liquidity equals to the liquidity of the second price range).\nPartially Overlapping Price Ranges #  [TODO: illustrate both scenarios]\n  When buying ETH:\nfunction testBuyETHPartiallyOverlappingPriceRanges() public {  LiquidityRange[] memory liquidity = new LiquidityRange[](2);  liquidity[0] = liquidityRange(4545, 5500, 1 ether, 5000 ether, 5000);  liquidity[1] = liquidityRange(5001, 6250, 1 ether, 5000 ether, 5000);   ...   (int256 expectedAmount0Delta, int256 expectedAmount1Delta) = (  -1.864220641170389178 ether,  10000 ether  );   assertSwapState(  ExpectedStateAfterSwap({  ...  sqrtPriceX96: 6165345094827913637987008642386, // 6055.578153852725  tick: 87091,  currentLiquidity: liquidity[1].amount  })  ); }   When buying USDC:\nfunction testBuyUSDCPartiallyOverlappingPriceRanges() public {  LiquidityRange[] memory liquidity = new LiquidityRange[](2);  liquidity[0] = liquidityRange(4545, 5500, 1 ether, 5000 ether, 5000);  liquidity[1] = liquidityRange(4000, 4999, 1 ether, 5000 ether, 5000);   ...   (int256 expectedAmount0Delta, int256 expectedAmount1Delta) = (  2 ether,  -9321.077831210790476918 ether  );   assertSwapState(  ExpectedStateAfterSwap({  ...  sqrtPriceX96: 5090915820491052794734777344590, // 4128.883835866256  tick: 83261,  currentLiquidity: liquidity[1].amount  })  ); }   This is a variation of the previous scenario, but this time the price ranges are partially overlapping. In this scenario, I used the same amounts, and, as a result of deeper liquidity in the overlapping area, price impact was lower: we got more paying less, and the price changes were smaller.\n"},{"id":10,"href":"/docs/milestone_2/math-in-solidity/","title":"Math in Solidity","section":"Milestone 2. Second Swap","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]  Math in Solidity #  Due to Solidity not supporting float-point and fixed-point numbers, math in Solidity is somewhat complicated. Solidity gives us integer and unsigned integer types, which are not enough for for more or less complex math calculations.\nAnother difficulty is gas consumption: the more complex an algorithm, the more gas it consumes. Thus, if we need to have advanced math operations (like exp, ln, sqrt), we want them to be as gas efficient as possible.\nAnd another big problem is the possibility of under/overflow. When multiplying uint256 numbers, there\u0026rsquo;s a risk of an overflow: the result number might be so big that it won\u0026rsquo;t fit into 256 bits.\nAll these difficulties force us to use third-party math libraries that implement advanced math operations and, ideally, optimize their gas consumption. In the case when there\u0026rsquo;s no library for an algorithm we need, we\u0026rsquo;ll have to implement it ourselves, and will need to know all the ins and outs of the math algorithm.\nRe-using Math Contracts #  In our Uniswap V3 implementation, we\u0026rsquo;re going to use two third-party math contracts:\n PRBMath, which is a great library of advanced fixed-point math algorithms. We\u0026rsquo;ll use mulDiv function to handle overflows when multiplying and then dividing integer numbers. TickMath from the original Uniswap V3 repo. This contract implements two functions, getSqrtRatioAtTick and getTickAtSqrtRatio, which convert between ticks and corresponding $\\sqrt{P}$.  Let\u0026rsquo;s focus on the latter.\nIn our contracts, we\u0026rsquo;ll need to convert ticks to corresponding $\\sqrt{P}$ and back. The formulas of finding $\\sqrt{P}$ at tick $i$ and vice versa:\n$$\\sqrt{P(i)} = \\sqrt{1.0001^i} = 1.0001^{\\frac{i}{2}}$$\n$$i = log_{\\sqrt{1.0001}}\\sqrt{P(i)}$$\nThe first formula takes square root of a number with a fractional part. The second one takes a logarithm of a similar number. These are advanced mathematical operations that are not implemented in Solidity. Moreover, these formulas are specific to Uniswap V3: they\u0026rsquo;re both based on taking square roots of powers of 1.0001. This means that we can implement a specific function finds only those that are based on powers of 1.0001 and not all logarithms and square root. Moreover, we know that tick indices are limited ($[−887272,887272]$), and this means our implementation doesn\u0026rsquo;t need to calculate them outside of the range.\nThis leads us to a conclusion: we need to implement our own mathematical function. Well, two of them.\nIf you look at the original code of getSqrtRatioAtTick and getTickAtSqrtRatio you\u0026rsquo;ll see that they\u0026rsquo;re quite complex: there\u0026rsquo;re a lot of magic numbers (like 0xfffcb933bd6fad37aa2d162d1a594001), multiplication, and bitwise operations. At this point, we\u0026rsquo;re not going to analyze the code or re-implement it since this is a very advanced and somewhat different topic. We\u0026rsquo;ll use the contract as is.\nThe only thing you need to know about these functions is that they\u0026rsquo;re approximations of the above formulas on the tick indices range. One of them approximates $\\sqrt{P(i)} = \\sqrt{1.0001^i}$ and the other approximates $i = log_{\\sqrt{1.0001}}\\sqrt{P(i)}$.\n"},{"id":11,"href":"/docs/milestone_1/providing-liquidity/","title":"Providing Liquidity","section":"Milestone 1. First Swap","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]  Providing Liquidity #  Enough of theory, let\u0026rsquo;s start coding!\nCreate a new folder (mine is called uniswapv3-code), and run forge init --vscode in it–this will initialize a Forge project. The --vscode flag tells Forge to configure the Solidity extension for Forge projects.\nNext, remove the default contract and its test:\n script/Contract.s.sol src/Contract.sol test/Contract.t.sol  And that\u0026rsquo;s it! Let\u0026rsquo;s create our first contract!\nPool Contract #  As you\u0026rsquo;ve learned from the introduction, Uniswap deploys multiple Pool contracts, each of which is an exchange market of a pair of tokens. Uniswap groups all its contract into two categories:\n core contracts, and periphery contracts.  Core contracts are, as the name implies, the contracts that implement core logic. These are minimal, user-unfriendly, low-level contracts. Their purpose is to do one thing. In Uniswap V3, there are 2 such contracts:\n Pool contract, which implements the core logic of a decentralized exchange. Factory contract, which serves as a registry of Pool contracts and a contract that makes deployment of pools easier.  We\u0026rsquo;ll begin with the pool contract. Create src/UniswapV3Pool.sol:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.14;  contract UniswapV3Pool {} Let\u0026rsquo;s think about what data the contract will store:\n Since every pool contract is an exchange market of two tokens, we need to track the two token addresses. And these addresses will be static, set once and forever during contract initialization. Each pool contract is a set of liquidity positions, a data structure to manage positions identified by: liquidity provider\u0026rsquo;s address, and upper and lower bounds of the position. Each pool contract will also need to maintain a ticks registry and information about each tick–the amount of liquidity provided by each tick. Since the tick range is limited, we need to store the limits in the contract, as constants. And as we discussed in the introduction, pool contracts store the amount of liquidity, $L$, and $\\sqrt{P}$ instead of token reserves. So we\u0026rsquo;ll need to store them in the contract as well.  Here\u0026rsquo;s what our pool contract with all the state variables:\ncontract UniswapV3Pool {  using Tick for mapping(int24 =\u0026gt; Tick.Info);  using Position for mapping(bytes32 =\u0026gt; Position.Info);  using Position for Position.Info;   int24 internal constant MIN_TICK = -887272;  int24 internal constant MAX_TICK = -MIN_TICK;   // Pool tokens, immutable  address public immutable token0;  address public immutable token1;   // First slot will contain essential data  struct Slot0 {  // Current sqrt(P)  uint160 sqrtPriceX96;  // Current tick  int24 tick;  }  Slot0 public slot0;   // Amount of liquidity, L.  uint128 public liquidity;   // Ticks info  mapping(int24 =\u0026gt; Tick.Info) public ticks;  // Positions info  mapping(bytes32 =\u0026gt; Position.Info) public positions;   ... Uniswap V3 uses many helper contracts and Tick and Position are two of them. using A for B is a feature of Solidity that lets you extend type B with functions from library contract A. This simplifies managing complex data structures.\n For brevity, I\u0026rsquo;ll omit detailed explanation of Solidity syntax and features. Solidity has great documentation, don\u0026rsquo;t hesitate referring to it if something is not clear!\n We\u0026rsquo;ll then initialize them in the constructor:\n constructor(  address token0_,  address token1_,  uint160 sqrtPriceX96,  int24 tick  ) {  token0 = token0_;  token1 = token1_;   slot0 = Slot0({sqrtPriceX96: sqrtPriceX96, tick: tick});  } } Notice that we\u0026rsquo;re passing $\\sqrt{P}$ and the current tick index without providing liquidity–this sets the current price.\n We\u0026rsquo;re setting both $\\sqrt{P}$ and tick index in the constructor for simplicity. Later on, we\u0026rsquo;ll implement the conversion between $\\sqrt{P}$ and tick indexes.\n This is our starting point, and our goal in this chapter is to make our first swap.\nMinting #  The process of providing liquidity in Uniswap V2 is called minting. The reason is that the V2 pool contract mints tokens (LP-tokens) in exchange for liquidity. V3 doesn\u0026rsquo;t do that, but it still uses the same name for the function. Let\u0026rsquo;s use it as well:\nfunction mint(  address owner,  int24 lowerTick,  int24 upperTick,  uint128 amount ) external returns (uint256 amount0, uint256 amount1) {  ... Our mint function will take:\n Owner\u0026rsquo;s address, to track the owner of the liquidity. Upper and lower ticks, to set the bounds of a price range. The amount of liquidity we have provided.  When adding initial liquidity to a pool, this function adds a new tick and a position.\nWe begin with checking the ticks:\nif (  lowerTick \u0026gt;= upperTick ||  lowerTick \u0026lt; MIN_TICK ||  upperTick \u0026gt; MAX_TICK ) revert InvalidTickRange(); And ensuring that some amount of liquidity is provided:\nif (amount == 0) revert ZeroLiquidity(); Then, add a tick and a position:\nticks.update(lowerTick, amount); ticks.update(upperTick, amount);  Position.Info storage position = positions.get(  owner,  lowerTick,  upperTick ); position.update(amount); The ticks.update function is:\n// src/libs/Tick.sol ... function update(  mapping(int24 =\u0026gt; Tick.Info) storage self,  int24 tick,  uint128 liquidityDelta ) internal {  Tick.Info storage tickInfo = self[tick];  uint128 liquidityBefore = tickInfo.liquidity;  uint128 liquidityAfter = liquidityBefore + liquidityDelta;   if (liquidityBefore == 0) {  tickInfo.initialized = true;  }   tickInfo.liquidity = liquidityAfter; } ... It initialized a tick if it has 0 liquidity before and adds new liquidity to it. As you can see, we\u0026rsquo;re calling this function on both lower and upper ticks, thus liquidity is added to both of them–we\u0026rsquo;ll see why later on.\nThe position.update function is:\n// src/libs/Position.sol function update(Info storage self, uint128 liquidityDelta) internal {  uint128 liquidityBefore = self.liquidity;  uint128 liquidityAfter = liquidityBefore + liquidityDelta;   self.liquidity = liquidityAfter; } Similar to the tick update function, it adds liquidity to a specific position. And to get a position we call:\n// src/libs/Position.sol ... function get(  mapping(bytes32 =\u0026gt; Info) storage self,  address owner,  int24 lowerTick,  int24 upperTick ) internal view returns (Position.Info storage position) {  position = self[  keccak256(abi.encodePacked(owner, lowerTick, upperTick))  ]; } ... Each position is uniquely identified by three keys: owner address, lower tick index, and upper tick index. We\u0026rsquo;re storing positions in a bytes32 =\u0026gt; Info map and are using hashes of concatenated owner address, lower tick, and upper tick as keys. This is cheaper than storing three nested maps.\nWe\u0026rsquo;re not done yet! Next, we need to calculate the amounts that the user must deposit. Luckily, we have already figured out the formulas and calculated the exact amounts in the previous part. So, we\u0026rsquo;re going to hardcode the amounts:\namount0 = 0.998976618347425280 ether; amount1 = 5000 ether;  We\u0026rsquo;ll replace these with actual calculations in a later chapter.\n Now, we\u0026rsquo;re ready to take tokens from the user. This is done via a callback:\nuint256 balance0Before; uint256 balance1Before; if (amount0 \u0026gt; 0) balance0Before = balance0(); if (amount1 \u0026gt; 0) balance1Before = balance1(); IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(  amount0,  amount1 ); if (amount0 \u0026gt; 0 \u0026amp;\u0026amp; balance0Before + amount0 \u0026gt; balance0())  revert InsufficientInputAmount(); if (amount1 \u0026gt; 0 \u0026amp;\u0026amp; balance1Before + amount1 \u0026gt; balance1())  revert InsufficientInputAmount(); First, we record current token balances (if either of them is deposited). Then we call uniswapV3MintCallback method on the caller–this is the callback. It\u0026rsquo;s expected that the caller (whoever executes mint) is a contract because non-contract addresses cannot implement functions in Ethereum. There are two reason doing this like that:\n Pool contract is a core contract, and core contracts are user-unfriendly. It\u0026rsquo;s expected that core contracts are only user by other contracts which make interaction with a pool easier. We don\u0026rsquo;t want to calculate the square root of reserves in the contract because it\u0026rsquo;s an expensive operation. But we still need to be sure that the liquidity deposited by user is correct. To achieve this, we calculate $\\Delta x$ and $\\Delta y$, which doesn\u0026rsquo;t require calculating square roots. But this approach forces us to use a callback to let the caller know the actual amounts they need to deposit.  In production, Pool contracts are called from the Router contract, which handles all the nuances. We\u0026rsquo;ll implement it in a later chapter.\nFinally, we\u0026rsquo;re firing a Mint event:\nemit Mint(msg.sender, owner, lowerTick, upperTick, amount, amount0, amount1); Events is how contract data is indexed in Ethereum for later search. It\u0026rsquo;s a good practice to fire an event whenever contract\u0026rsquo;s state is changed to let blockchain explorer know when this happened. Events also carry useful information. In our case it\u0026rsquo;s: caller\u0026rsquo;s address, liquidity position owner\u0026rsquo;s address, upper and lower ticks, new liquidity, and token amounts. This information will be stored as a log, and anyone else will be able to collect all contract events and reproduce activity of the contract without traversing and analyzing all blocks and transactions.\nAnd we\u0026rsquo;re done! Phew! Now, let\u0026rsquo;s test minting.\nTesting #  At this point we don\u0026rsquo;t know if everything works correctly. Before deploying our contract anywhere we\u0026rsquo;re going to write a bunch of tests to ensure the contract works correctly. Luckily to us, Forge is a great testing framework and it\u0026rsquo;ll make testing a breeze.\nCreate a new test file:\n//test/UniswapV3Pool.t.sol // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.14;  import \u0026#34;forge-std/Test.sol\u0026#34;;  contract UniswapV3PoolTest is Test {  function setUp() public {}   function testExample() public {  assertTrue(true);  } } Let\u0026rsquo;s run it:\n$ forge test Running 1 test for test/UniswapV3Pool.t.sol:UniswapV3PoolTest [PASS] testExample() (gas: 279) Test result: ok. 1 passed; 0 failed; finished in 5.07ms It passes! Of course it is! So far, our test only checks that true is true!\nTest contract are just contract that inherit from forge-std/Test.sol. This contract is a set of testing utilities, we\u0026rsquo;ll get acquainted with them step by step. If you don\u0026rsquo;t want wait, open lib/forge-std/src/Test.sol and skim through it!\nTest contracts follow a specific convention:\n setUp function is used to set up test cases. In each test cases, we want to have configured environment, like deployed contracts, minted tokens, initialized pools–we\u0026rsquo;ll do all this in setUp. Every test case starts with test prefix, e.g. testMint(). This will let Forge distinguish test cases from helper functions (we can add any function we want).  Let\u0026rsquo;s test minting!\nTest Tokens #  To test minting we need tokens. This is not a problem because we can deploy any contract in tests! Moreover, Forge can install open-source contracts as dependencies. Specifically, we need an ERC20 contract with minting functionality. We\u0026rsquo;ll use the ERC20 contract from solmate, a collection of gas-optimized contracts (however, we don\u0026rsquo;t care about gas optimization at this moment) and we\u0026rsquo;ll extend it in a contract that allows public minting.\nLet\u0026rsquo;s install solmate:\n$ forge install rari-capital/solmate Then, let\u0026rsquo;s create ERC20Mintable.sol contract in test folder (we\u0026rsquo;ll use the contract only in tests):\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.14;  import \u0026#34;solmate/tokens/ERC20.sol\u0026#34;;  contract ERC20Mintable is ERC20 {  constructor(  string memory _name,  string memory _symbol,  uint8 _decimals  ) ERC20(_name, _symbol, _decimals) {}   function mint(address to, uint256 amount) public {  _mint(to, amount);  } } Our ERC20Mintable inherits all functionality from solmate/tokens/ERC20.sol and we additionally implement public mint method which will allow us to mint any number of tokens.\nMinting #  Now, we\u0026rsquo;re ready to test minting.\nFirst, let\u0026rsquo;s deploy all the required contracts:\n// test/UniswapV3Pool.t.sol ... import \u0026#34;./ERC20Mintable.sol\u0026#34;; import \u0026#34;../src/UniswapV3Pool.sol\u0026#34;;  contract UniswapV3PoolTest is Test {  ERC20Mintable token0;  ERC20Mintable token1;  UniswapV3Pool pool;   function setUp() public {  token0 = new ERC20Mintable(\u0026#34;Ether\u0026#34;, \u0026#34;ETH\u0026#34;, 18);  token1 = new ERC20Mintable(\u0026#34;USDC\u0026#34;, \u0026#34;USDC\u0026#34;, 18);  }   ... In the setUp function, we do things that are required for all our test cases–tokens deployment. We\u0026rsquo;ll need the two tokens in every future test case (and we\u0026rsquo;ll add more tokens later on). However, we\u0026rsquo;re not going to deploy the pool here because each test case will need a pool with different parameters.\nTo make pool setting up cleaner and simpler, we\u0026rsquo;ll do this in a separate function, setupTestCase, that takes a set of test case parameters. In our first test case, we\u0026rsquo;ll test successful liquidity minting. This is what the test case parameters look like:\nfunction testMintSuccess() public {  TestCaseParams memory params = TestCaseParams({  wethBalance: 1 ether,  usdcBalance: 5000 ether,  currentTick: 85176,  lowerTick: 84222,  upperTick: 86129,  liquidity: 1517882343751509868544,  currentSqrtP: 5602277097478614198912276234240,  shouldTransferInCallback: true,  mintLiqudity: true  });  (uint256 poolBalance0, uint256 poolBalance1) = setupTestCase(params);  We\u0026rsquo;re planning to deposit 1 ETH and 5000 USDC into the pool. We want the current tick to be 85176, and lower and upper ticks being 84222 and 86129 respectively. We\u0026rsquo;re specifying the precalculated liquidity and current $\\sqrt{P}$. We also want to deposit liquidity (mintLiquidity parameter) and transfer tokens when requested by the pool contract (shouldTransferInCallback). We don\u0026rsquo;t want to do this in each test case, so we want this to be optional.  Next, we\u0026rsquo;re calling setupTestCase with the above parameters:\nfunction setupTestCase(TestCaseParams memory params)  internal  returns (uint256 poolBalance0, uint256 poolBalance1) {  token0.mint(address(this), params.wethBalance);  token1.mint(address(this), params.usdcBalance);   pool = new UniswapV3Pool(  address(token0),  address(token1),  params.currentSqrtP,  params.currentTick  );   if (params.mintLiqudity) {  (poolBalance0, poolBalance1) = pool.mint(  address(this),  params.lowerTick,  params.upperTick,  params.liquidity  );  }   shouldTransferInCallback = params.shouldTransferInCallback; } In this function, we\u0026rsquo;re minting tokens and deploying a pool (unconditionally), as well as providing liquidity when mintLiquidity is set and setting shouldTransferInCallback flag. We\u0026rsquo;ll then check the flag in the mint callback:\nfunction uniswapV3MintCallback(uint256 amount0, uint256 amount1) public {  if (shouldTransferInCallback) {  token0.transfer(msg.sender, amount0);  token1.transfer(msg.sender, amount1);  } } Recall that test contracts act as users. Thus, this test contract must implement uniswapV3MintCallback so it could call the mint function.\nSetting up test cases like that is not mandatory, you can do it however feels most comfortable to you. Test contracts are just contracts. You can implement whatever helper functions you want.\nIn testMintSuccess, we want to test that the pool contract:\n takes the correct amounts of tokens from us; creates a position with correct key and liquidity; initializes the upper and lower ticks we\u0026rsquo;ve specified; has proper current $\\sqrt{P}$ and $L$.  Let\u0026rsquo;s do this.\nMinting happens in setupTestCase, so we don\u0026rsquo;t need to do this again. The function also returns the amounts we have provided, so let\u0026rsquo;s check them:\nuint256 expectedAmount0 = 0.998976618347425280 ether; uint256 expectedAmount1 = 5000 ether; assertEq(  poolBalance0,  expectedAmount0,  \u0026#34;incorrect token0 deposited amount\u0026#34; ); assertEq(  poolBalance1,  expectedAmount1,  \u0026#34;incorrect token1 deposited amount\u0026#34; ); We expect specific pre-calculated amounts. And we can also check that these amounts were actually transferred to the pool:\nassertEq(token0.balanceOf(address(pool)), expectedAmount0); assertEq(token1.balanceOf(address(pool)), expectedAmount1); Next, we need to check the position the pool created for us. Remember that the key in positions mapping is a hash? We need to calculate it manually and then get our position from the contract:\nbytes32 positionKey = keccak256(  abi.encodePacked(address(this), params.lowerTick, params.upperTick) ); uint128 posLiquidity = pool.positions(positionKey); assertEq(posLiquidity, params.liquidity);  Since Position.Info is a struct, it gets destructured when fetched: each field gets fetched separately.\n [TODO: double-check]\nNext come the ticks. Again, it\u0026rsquo;s straightforward:\n(bool tickInitialized, uint128 tickLiquidity) = pool.ticks(  params.lowerTick ); assertTrue(tickInitialized); assertEq(tickLiquidity, params.liquidity);  (tickInitialized, tickLiquidity) = pool.ticks(params.upperTick); assertTrue(tickInitialized); assertEq(tickLiquidity, params.liquidity); And finally $\\sqrt{P}$ and $L$:\n(uint160 sqrtPriceX96, int24 tick) = pool.slot0(); assertEq(  sqrtPriceX96,  5602277097478614198912276234240,  \u0026#34;invalid current sqrtP\u0026#34; ); assertEq(tick, 85176, \u0026#34;invalid current tick\u0026#34;); assertEq(  pool.liquidity(),  1517882343751509868544,  \u0026#34;invalid current liquidity\u0026#34; ); As you can see, writing tests in Solidity is not hard!\nFailures #  Of course, testing only successful scenarios is not enough. We also need to test failing cases. What can go wrong when providing liquidity? Here are a couple of hints:\n Upper and lower ticks are too big or too low. Zero liquidity is provided. Liquidity provider doesn\u0026rsquo;t have enough of tokens.  I\u0026rsquo;ll leave it for you to implement these scenarios! Feel free peeking at the code in the repo.\n"},{"id":12,"href":"/docs/introduction/uniswap-v3/","title":"Uniswap V3","section":"Milestone 0","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]  Introduction to Uniswap V3 #   This chapter retells the whitepaper of Uniswap V3. Again, it\u0026rsquo;s totally ok if you don\u0026rsquo;t understand all the concepts. They will be clearer when converted to code.\n To better understand the innovations Uniswap V3 brings, let\u0026rsquo;s first look at the imperfections of Uniswap V2.\nUniswap V2 is a general exchange that implements one AMM algorithm. However, not all trading pairs are equal. Pairs can be grouped by price volatility:\n Tokens with medium and high price volatility. This group includes most tokens since most tokens don\u0026rsquo;t have their prices pegged to something and are subject to market fluctuations. Tokens with low volatility. This group includes pegged tokens, mainly stablecoins: USDC-USDT, USDC-DAI, USDT-DAI, etc. Also: ETH-stETH, ETH-rETH.  These groups require different, let\u0026rsquo;s call them, pool configurations. The main difference is that pegged tokens require high liquidity to reduce the demand effect (we learned about it in the previous chapter) on big trades. The prices of USDC and USDT must stay close to 1, no matter how big the number of tokens we want to buy and sell. Since Uniswap V2\u0026rsquo;s general AMM algorithm is not very well suited for stablecoin trading, alternative AMMs (mainly Curve) were more popular for stablecoin trading.\nWhat caused this problem is that liquidity in Uniswap V2 pools is distributed infinitely–pool liquidity allows trades at any price, from 0 to infinity:\n[TODO: add illustration]\nThis might not seem like a bad thing, but this reduces capital efficiency. Historical prices of an asset stay within some defined range, whether it\u0026rsquo;s narrow or wide. For example, the historical price range of ETH is from $0.75 to $4,800 (according to CoinMarketCap). Today (June 2022, 1 ETH costs $1,1800), no one would buy 1 ether at $5000, so it makes no sense to provide liquidity at this price. Thus, a lot of liquidity in V2 pools cannot and won\u0026rsquo;t be used, ever. And this can be improved.\nConcentrated Liquidity #  Uniswap V3 introduces concentrated liquidity–liquidity providers can now choose the price range they want to provide liquidity into. This improves capital efficiency by allowing to put more liquidity into a narrow price range, which makes Uniswap more diverse: it can now have pools configured for pairs with different volatility. This fixes the problem of Uniswap V2 we discussed above.\nIn a nutshell, Uniswap V3 is many small Uniswap V2s. The main difference between V2 and V3 is that, in V3, there are many pools, not one. Each of these smaller pools exists only within a certain price range and each of them has finite reserves–we\u0026rsquo;ll call them real reserves. The entire price range (from 0 to infinity) is can be filled with these discrete pools, which provide liquidity within certain price ranges–this is the main feature of Uniswap V3.\n[TODO: add illustration, compare liquidity distributions]\nTo set a price range, we need to pick two price points on the curve, $a$ and $b$:\n[TODO: add curve with price a, b, and x_real, y_real]\nAs we saw in the previous chapter, buying or selling tokens moves the prices along the curve. A price range limits the movement of the price. When the price moves to either of the points, the pool becomes depleted: one of the token reserves will be 0 and buying this token won\u0026rsquo;t be possible.\nLet\u0026rsquo;s look closely at the chart above:\n The current price is the ratio of current reserves. To get to point $a$ we need to buy all available $Y$; to get to point $b$ we need to buy all available $X$. Real pool reserves are $x_real$ and $y_real$. These amounts define the current price and also allow to move the price to one of the edge prices.  Since reserves can be depleted, this curve better illustrates the price ranges:\n[TODO: add virtual reserves -\u0026gt; real reserves transition graph]\nThis is the original curve shifted in a way that makes it limited by the axes: the curve crosses the axes at the points corresponding to the price range. This chart also better illustrated pool reserves: amounts required to move the price of either of the tokens to one of the bounds of the price range.\nWhat happens when the current price range gets depleted? The price slips into the next price range (if it exists, of course). If the next price range doesn\u0026rsquo;t exist, a trade is not possible. We\u0026rsquo;ll see how this works later in the book.\nTo handle transitioning between price ranges, simplify liquidity management, and avoid rounding errors, Uniswap V3 uses these new concepts:\n$$L = \\sqrt{xy}$$\n$$\\sqrt{P} = \\sqrt{\\frac{y}{x}}$$\n$L$ can be seen as the amount of liquidity. In the previous chapter, we saw that the trade function can be rewritten as a comparison of geometric means of reserves before and after a swap.\n$\\frac{y}{x}$ is the price of token X in terms of Y. Since token prices in a pool are reciprocals of each other, we can use only one of them in calculations. The price of token Y in terms of token X is simply $\\frac{1}{y/x}=\\frac{x}{y}$. Similarly, $\\frac{1}{\\sqrt{P}} = \\frac{1}{\\sqrt{y/x}} = \\sqrt{\\frac{x}{y}}$.\n$L$ times price gives us the amount of liquidity. The curve of virtual reserves is shifted: along $x$ by the reserves of token X; along $y$ by the reserves of token Y. The real reserves curve crosses the axes in the coordinates equal to the amounts of reserves, that\u0026rsquo;s why reserves can be depleted.\nWhy using $\\sqrt{p}$ instead of $p$? There are two reasons:\n  Square root calculation is not precise and causes rounding errors. Thus, it\u0026rsquo;s easier to store the square root without calculating it in the contracts.\n  $\\sqrt{P}$ has an interesting connection to $L$: $L$ is also the relation between the change in output amount and the change in $\\sqrt{P}$.\n$$L = \\frac{\\Delta y}{\\Delta\\sqrt{P}}$$\n  [TODO: prove this]\nPricing #  Pool reserves in Uniswap V3 are defined as:\n$$x = \\frac{L}{\\sqrt{P}}$$ $$y = L \\sqrt{P}$$\nHowever, we\u0026rsquo;ll never need to calculate them because $L$ and $\\sqrt{P}$ allow us to find trade amounts without knowing $x$ and $y$. Let\u0026rsquo;s return to this formula:\n$$L = \\frac{\\Delta y}{\\Delta\\sqrt{P}}$$\nWe can find $\\Delta y$ from it:\n$$\\Delta y = \\Delta \\sqrt{P} L$$\nAs we discussed above, prices in a pool are reciprocals of each other. Thus, $\\Delta x$ is:\n$$\\Delta x = \\Delta \\frac{1}{\\sqrt{P}} L$$\n$L$ and $\\sqrt{P}$ allow us to not store and update pool reserves. Also, we don\u0026rsquo;t need to calculate $\\sqrt{P}$ each time because we can always find $\\Delta \\sqrt{P}$ and its reciprocal.\nTicks #  Uniswap V3, however, doesn\u0026rsquo;t allow us to select arbitrary prices when providing liquidity. Instead, it implements a scale and we choose certain marks on it.\nThe entire price range is demarcated by evenly distributed discrete ticks. Each tick has an index and corresponds to a certain price:\n$$p(i) = 1.0001^i$$\nWhere $p(i)$ is the price at tick $i$. Taking powers of 1.0001 has a desirable property: the difference between two adjacent ticks is 0.01% or 1 basis point.\n Basis point (1/100th of 1%, or 0.01%, or 0.0001) is a unit of measure of percentages in finance. You could\u0026rsquo;ve heard about basis point when central banks announced changes in interest rates.\n As we discussed above, Uniswap V3 stores $\\sqrt{P}$, not $P$. Thus, the formula is in fact:\n$$\\sqrt{p(i)} = \\sqrt{1.0001}^i = 1.0001 ^{\\frac{i}{2}}$$\nSo, we get values like: $\\sqrt{p(0)} = 1$, $\\sqrt{p(1)} = \\sqrt{1.0001} \\approx 1.00005$, $\\sqrt{p(-1)} \\approx 0.99995$.\nTicks are integers that can be positive and negative and, of course, they\u0026rsquo;re not infinite. Ticks are mapped to prices, thus they\u0026rsquo;re limited by the price range. Uniswap V3 stores $\\sqrt{P}$ as a fixed point Q64.96 number, which is a rational number that uses 64 bits for the integer part and 96 bits for the fraction part. It\u0026rsquo;s stored in an uint160 variable and it supports prices between $2^{-128}$ and $2^{128}$. Thus, the tick range is:\n$$[log_{1.0001}2^{-128}, log_{1.0001}{2^{128}}] = [-887272, 887272]$$\n"},{"id":13,"href":"/docs/introduction/dev-environment/","title":"Development Environment","section":"Milestone 0","content":"Development environment #  We\u0026rsquo;re going to build two applications:\n An on-chain one–a set of smart contracts deployed on Ethereum. An off-chain one–a front-end application that will interact with the smart contracts.  While the front-end application development is part of this book, it won\u0026rsquo;t be our main focus. We will build it solely to demonstrate how smart contracts are integrated with front-end applications. You won\u0026rsquo;t need to build it from scratch, I\u0026rsquo;ll provide a template.\nQuick Introduction to Ethereum #  Ethereum is a blockchain that allows anyone to run applications on it. It might look like a cloud provider, but there are multiple differences:\n You don\u0026rsquo;t pay for hosting your application. But you pay for deployment. Your application will be small and it will be able to interact only with other contracts and the internal blockchain storage. Your application is immutable. That is: you won\u0026rsquo;t be able to modify it after it\u0026rsquo;s deployed.  To better understand these moments, let\u0026rsquo;s see what Ethereum is made of.\nAt the core of Ethereum (and any other blockchain) is a database. The most valuable data in Ethereum\u0026rsquo;s database is the state of accounts. An account is an Ethereum address with associated data:\n Balance: account\u0026rsquo;s ether balance. Code: bytecode of the smart contract deployed at this address. Storage: space used by smart contracts to store data. Nonce: a serial integer that\u0026rsquo;s used to protect against replay attacks.  Ethereum\u0026rsquo;s main job is building and maintaining this data in a secure way that doesn\u0026rsquo;t allow unauthorized access.\nEthereum is also a network, a network of computers that build and maintain the state independently of each other. The main goal of the network is to decentralize access to the database: there must be no single authority that\u0026rsquo;s allowed to modify anything in the database unilaterally. This is achieved by a means of consensus, which is a set of rules all the nodes in the network follow. If one party decides to abuse a rule, it\u0026rsquo;ll be excluded from the network.\n Fun fact: blockchain can use MySQL! Nothing prevents this besides performance. In its turn, Ethereum uses LevelDB, a fast key-value database.\n Every Ethereum node also runs EVM, Ethereum Virtual Machine. A virtual machine is a program that can run other programs, and EVM is a program that executes smart contracts. Users interact with contracts through transactions: besides simply sending ether, transactions can contain smart contract call data. It includes:\n An encoded contract function name. Function parameters.  Transactions are packed in blocks and blocks then mined by miners. Each participant of the network can validate any transaction and any block.\nIn a sense, smart contracts are similar to JSON APIs but instead of endpoints you call smart contract functions and you pass function parameters. Similar to API backends, smart contracts execute programmed logic, which can optionally modify smart contract storage. Unlike JSON API, you need to send a transaction to mutate blockchain state, and you\u0026rsquo;ll need to pay for each transaction you\u0026rsquo;re sending.\nFinally, Ethereum nodes expose a JSON-RPC API. Through this API, we can get account balance, estimate gas costs, get blocks and transactions, send transactions, and execute contract calls without sending transactions (this is used to read data from smart contracts). Here you can find the full list of available endpoints.\nLocal Development Environment #  We\u0026rsquo;re going to build smart contracts and run them on Ethereum, which means we need a node. And this is what smart contracts development looked like until recently. Today, we don\u0026rsquo;t need to run a node, which makes development much faster and allows us to iterate quicker.\nLet\u0026rsquo;s review the tools we\u0026rsquo;re going to use.\nFoundry #  Foundry is a set of tools for Ethereum applications development. Specifically, we\u0026rsquo;re going to use:\n Forge, a testing framework for Solidity. Anvil, a local Ethereum node designed for development with Forge.  [TODO: maybe Cast?]\nForge makes smart contracts developer\u0026rsquo;s life so much easier. With Forge, we don\u0026rsquo;t need to run a local node to test contracts. Instead, Forge will run our smart contracts on its internal EVM, which is much faster and doesn\u0026rsquo;t require sending transactions and mining blocks.\nForge allows us to write tests in Solidity! Before Forge, smart contract tests were written in JavaScript and this required running a node, writing interactions with the node in JS, sending transactions, and mining blocks. Forge also makes it easier to simulate blockchain state: we can easily fake our ether or token balance, execute contracts from other addresses, deploy any contracts at any address, etc.\nHowever, we\u0026rsquo;ll still need a local node to deploy our contract to. For that, we\u0026rsquo;ll use Anvil.\nEthers.js #  Ethers.js is a set of Ethereum utilities written in JavaScript. This is one of the two (the other one is web3.js) JavaScript libraries that are used in decentralized applications development. These libraries allow us to interact with an Ethereum node via the JSON-API, and they come with multiple utility functions that make developer\u0026rsquo;s life easier.\nMetaMask #  MetaMask is an Ethereum wallet in your browser. It\u0026rsquo;s a browser extension that creates and securely stores Ethereum private keys. MetaMask is the main Ethereum wallet application used by millions of users. We\u0026rsquo;ll use it to sign transactions that we\u0026rsquo;ll send to our local node.\nReact #  React is a well-known JavaScript library for building front-end applications. You don\u0026rsquo;t need to know React, I\u0026rsquo;ll provide a template application.\n"},{"id":14,"href":"/docs/milestone_1/first-swap/","title":"First Swap","section":"Milestone 1. First Swap","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]  First Swap #  Now that we have liquidity, we can make our first swap!\nCalculating Swap Amounts #  First step, of course, is to figure out how to calculate swap amounts. And, again, let\u0026rsquo;s pick and hardcode some amount of USDC we\u0026rsquo;re going to trade in for ETH. Let it be 42! We\u0026rsquo;re going to buy ETH for 42 USDC.\nAfter deciding how many tokens we want to sell, we need to calculate how many tokens we\u0026rsquo;ll get in exchange. There are multiple ways of doing this. In Uniswap V2, we would\u0026rsquo;ve used current pool reserves, but in Uniswap V3 we have $L$ and $\\sqrt{P}$ and we know the fact that, when swapping within a price range, only $\\sqrt{P}$ changes and $L$ remains unchanged. We also know that: $$L = \\frac{\\Delta y}{\\Delta \\sqrt{P}}$$\nAnd\u0026hellip; we know $\\Delta y$! This is the 42 USDC we\u0026rsquo;re going to trade in! Thus, we can find how selling 42 USDC will affect the current $\\sqrt{P}$ given the $L$:\n$$\\Delta \\sqrt{P} = \\frac{\\Delta y}{L}$$\nIn Uniswap V3, we choose the price we want our trade to lead to (recall that swapping changes the current price, i.e. it moves the current price along the curve). Knowing the target price, the contract will calculate the amount of input token it needs to take from us and the respective amount of output token it\u0026rsquo;ll give us.\nLet\u0026rsquo;s plug in our numbers into the above formula:\n$$\\Delta \\sqrt{P} = \\frac{42 \\enspace USDC}{1517882343751509868544} = 2192253463713690532467206957$$\nAfter adding this to the current $\\sqrt{P}$, we\u0026rsquo;ll get the target price:\n$$\\sqrt{P_{target}} = \\sqrt{P_{current}} + \\Delta \\sqrt{P}$$\n$$\\sqrt{P_{target}} = 5604469350942327889444743441197$$\n To calculate the target price in Python:\namount_in = 42 * eth price_diff = (amount_in * q96) // liq price_next = sqrtp_cur + price_diff print(\u0026#34;New price:\u0026#34;, (price_next / q96) ** 2) print(\u0026#34;New sqrtP:\u0026#34;, price_next) print(\u0026#34;New tick:\u0026#34;, price_to_tick((price_next / q96) ** 2)) # New price: 5003.913912782393 # New sqrtP: 5604469350942327889444743441197 # New tick: 85184  After finding the target price, we can calculate token amounts using the amounts calculation functions from a previous chapter:\n$$ x = \\frac{L(\\sqrt{p_b}-\\sqrt{p_a})}{\\sqrt{p_b}\\sqrt{p_a}}$$ $$ y = L(\\sqrt{p_b}-\\sqrt{p_a}) $$\n In Python:\namount_in = calc_amount1(liq, price_next, sqrtp_cur) amount_out = calc_amount0(liq, price_next, sqrtp_cur)  print(\u0026#34;USDC in:\u0026#34;, amount_in / eth) print(\u0026#34;ETH out:\u0026#34;, amount_out / eth) # USDC in: 42.0 # ETH out: 0.008396714242162444  To verify the amounts, let\u0026rsquo;s recall another formula:\n$$\\Delta x = \\Delta \\frac{1}{\\sqrt{P}} L$$\nUsing this formula, we can find the amount of ETH we\u0026rsquo;re buying, $\\Delta x$, knowing the price change, $\\Delta\\frac{1}{\\sqrt{P}}$, and liquidity $L$. Be careful though: $\\Delta \\frac{1}{\\sqrt{P}}$ is not $\\frac{1}{\\Delta \\sqrt{P}}$! The former is the change of the price of ETH, and it can be found using this expression:\n$$\\Delta \\frac{1}{\\sqrt{P}} = \\frac{1}{\\sqrt{P_{target}}} - \\frac{1}{\\sqrt{P_{current}}}$$\nLuckily, we already know all the values, so we can plug them in right away (this might not fit on your screen!):\n$$\\Delta \\frac{1}{\\sqrt{P}} = \\frac{1}{5604469350942327889444743441197} - \\frac{1}{5602277097478614198912276234240}$$\n$$\\Delta \\frac{1}{\\sqrt{P}} = -0.00000553186106731426$$\nNow, let\u0026rsquo;s find $\\Delta x$:\n$$\\Delta x = -0.00000553186106731426 * 1517882343751509868544 = -8396714242162698 $$\nWhich is 0.008396714242162698 ETH, and it\u0026rsquo;s very close to the amount we found above! Notice that this amount is negative since we\u0026rsquo;re removing it from the pool.\nImplementing a Swap #  Swapping is implemented in swap function:\nfunction swap(address recipient)  public  returns (int256 amount0, int256 amount1) {  ... At this moment, it only takes a recipient, who is a receiver of tokens.\nFirst, we need to find the target price and tick, as well as calculate the token amounts. Again, we\u0026rsquo;ll simply hardcode the values we calculated earlier to keep things as simple as possible:\n... int24 nextTick = 85184; uint160 nextPrice = 5604469350942327889444743441197;  amount0 = -0.008396714242162444 ether; amount1 = 42 ether; ... Next, we need to update the current tick and sqrtP since trading affects the current price:\n... (slot0.tick, slot0.sqrtPriceX96) = (nextTick, nextPrice); ... Next, the contract sends tokens to the recipient and lets the caller transfer the input amount into the contract:\n... IERC20(token0).transfer(recipient, uint256(-amount0));  uint256 balance1Before = balance1(); IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(  amount0,  amount1 ); if (balance1Before + uint256(amount1) \u0026lt; balance1())  revert InsufficientInputAmount(); ... Again, we\u0026rsquo;re using a callback to pass the control to the caller and let it transfer the tokens. After that, we\u0026rsquo;re checking that pool\u0026rsquo;s balance is correct and includes the input amount.\nFinally, the contract emits a Swap event to make the swap discoverable. The event includes all the information about the swap:\n... emit Swap(  msg.sender,  recipient,  amount0,  amount1,  slot0.sqrtPriceX96,  liquidity,  slot0.tick ); And that\u0026rsquo;s it! The function simply sends some amount of tokens to the specified recipient address and expects a certain number of the other token in exchange. Throughout this book, the function will get much more complicated.\nTesting Swapping #  Now, we can test the swap function. In the same test file, create testSwapBuyEth function and set up the test case. This test case uses the same parameters as testMintSuccess:\nfunction testSwapBuyEth() public {  TestCaseParams memory params = TestCaseParams({  wethBalance: 1 ether,  usdcBalance: 5000 ether,  currentTick: 85176,  lowerTick: 84222,  upperTick: 86129,  liquidity: 1517882343751509868544,  currentSqrtP: 5602277097478614198912276234240,  shouldTransferInCallback: true,  mintLiqudity: true  });  (uint256 poolBalance0, uint256 poolBalance1) = setupTestCase(params);   ... Next steps will be different, however.\n We\u0026rsquo;re not going to test that liquidity has been correctly added to the pool since we tested this functionality in the other test cases.\n To make the test swap, we need 42 USDC:\ntoken1.mint(address(this), 42 ether); Before making the swap, we need to ensure we can transfer tokens to the pool contract when it requests them:\nfunction uniswapV3SwapCallback(int256 amount0, int256 amount1) public {  if (amount0 \u0026gt; 0) {  token0.transfer(msg.sender, uint256(amount0));  }   if (amount1 \u0026gt; 0) {  token1.transfer(msg.sender, uint256(amount1));  } } Since amounts during a swap can be positive (the amount that\u0026rsquo;s sent to the pool) and negative (the amount that\u0026rsquo;s taken from the pool), in the callback, we only want to send the positive amount, i.e. the amount we\u0026rsquo;re trading in.\nNow, we can call swap:\n(int256 amount0Delta, int256 amount1Delta) = pool.swap(address(this)); The function returns token amounts used in the swap, and we can check them right away:\nassertEq(amount0Delta, -0.008396714242162444 ether, \u0026#34;invalid ETH out\u0026#34;); assertEq(amount1Delta, 42 ether, \u0026#34;invalid USDC in\u0026#34;); Then, we need to ensure that tokens were actually transferred from the caller:\nassertEq(  token0.balanceOf(address(this)),  uint256(userBalance0Before - amount0Delta),  \u0026#34;invalid user ETH balance\u0026#34; ); assertEq(  token1.balanceOf(address(this)),  0,  \u0026#34;invalid user USDC balance\u0026#34; ); And sent to the pool contract:\nassertEq(  token0.balanceOf(address(pool)),  uint256(int256(poolBalance0) + amount0Delta),  \u0026#34;invalid pool ETH balance\u0026#34; ); assertEq(  token1.balanceOf(address(pool)),  uint256(int256(poolBalance1) + amount1Delta),  \u0026#34;invalid pool USDC balance\u0026#34; ); Finally, we\u0026rsquo;re checking that the pool state was updated correctly:\n(uint160 sqrtPriceX96, int24 tick) = pool.slot0(); assertEq(  sqrtPriceX96,  5604469350942327889444743441197,  \u0026#34;invalid current sqrtP\u0026#34; ); assertEq(tick, 85184, \u0026#34;invalid current tick\u0026#34;); assertEq(  pool.liquidity(),  1517882343751509868544,  \u0026#34;invalid current liquidity\u0026#34; ); Notice that swapping doesn\u0026rsquo;t change the current liquidity–in a later chapter, we\u0026rsquo;ll see when it does change it.\nHomework #  Write a test that fails with InsufficientInputAmount error. Keep in mind that there\u0026rsquo;s a hidden bug 🙂\n"},{"id":15,"href":"/docs/milestone_3/slippage-protection/","title":"Slippage Protection","section":"Milestone 3. Cross-tick Swaps","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]  Slippage Protection #  Slippage is a very important issued in decentralized exchanges. Slippage simply means the difference between the price that you see on the screen when initialing a transaction and the actual price the swap is executed at. This difference appears because there\u0026rsquo;s a short (and sometimes long, depending on network congestion and gas costs) delay between when you send a transaction and when it gets mined. In more technical terms, blockchain state changes every block and there\u0026rsquo;s no guarantee that your transaction will be applied at a specific block.\nAnother important problem that slippage protection fixes is sandwich attacks–this is a common type of attacks on decentralized exchange users. During sandwiching, attackers \u0026ldquo;wrap\u0026rdquo; your swap transactions in their two transactions: one goes before your transaction and the other goes after it. In the first transaction, an attacker modifier the state of a pool so that your swap becomes very unprofitable for you and somewhat profitable for the attacker. This is achieved by adjusting pool liquidity so that your trade happens at a lower price. In the second transaction, the attacker reestablishes pool liquidity and the price. As a result, you get much less tokens than expected due to manipulated prices and the attacker get some profit.\nThe way slippage protection is implemented in decentralized exchanges is by letting user choose how far the actual price is allowed to drop. By default, Uniswap V3 sets slippage tolerance to 0.1%, which means a swap is executed only if the price at the moment of execution is as small as 99.9% of the price the user saw in the browser. This is a very tight range and users are allowed to adjust this number, which is useful when volatility is high.\nLet\u0026rsquo;s add slippage protection to our implementation!\nSlippage Protection in Swaps #  To protect swaps, we need to add one more parameter to swap function–we want to let user choose a stop price, a price at which swapping will stop. We\u0026rsquo;ll call the parameter sqrtPriceLimitX96:\nfunction swap(  address recipient,  bool zeroForOne,  uint256 amountSpecified,  uint160 sqrtPriceLimitX96,  bytes calldata data ) public returns (int256 amount0, int256 amount1) {  ...  if (  zeroForOne  ? sqrtPriceLimitX96 \u0026gt; slot0_.sqrtPriceX96 ||  sqrtPriceLimitX96 \u0026lt; TickMath.MIN_SQRT_RATIO  : sqrtPriceLimitX96 \u0026lt; slot0_.sqrtPriceX96 \u0026amp;\u0026amp;  sqrtPriceLimitX96 \u0026gt; TickMath.MAX_SQRT_RATIO  ) revert InvalidPriceLimit();  ... When selling token $X$ (zeroForOne is true), sqrtPriceLimitX96 must be between the current price and the minimal $sqrt{P}$ since selling token $X$ moves the price down. Likewise, when selling token $Y$, sqrtPriceLimitX96 must be between the current price and the maximal $\\sqrt{P}$ because price moves up.\nIn the while loop, we want to satisfy two conditions: full swap amount is filled and current price isn\u0026rsquo;t equal to sqrtPriceLimitX96:\n.. while (  state.amountSpecifiedRemaining \u0026gt; 0 \u0026amp;\u0026amp;  state.sqrtPriceX96 != sqrtPriceLimitX96 ) { ... Which means that Uniswap V3 pools don\u0026rsquo;t fail when slippage tolerance gets hit and simply executes swap partially.\nFinal place where we need to use sqrtPriceLimitX96 is when calling SwapMath.computeSwapStep:\n(state.sqrtPriceX96, step.amountIn, step.amountOut) = SwapMath  .computeSwapStep(  state.sqrtPriceX96,  (  zeroForOne  ? step.sqrtPriceNextX96 \u0026lt; sqrtPriceLimitX96  : step.sqrtPriceNextX96 \u0026gt; sqrtPriceLimitX96  )  ? sqrtPriceLimitX96  : step.sqrtPriceNextX96,  state.liquidity,  state.amountSpecifiedRemaining  ); Here, we want to ensure that computeSwapStep never calculates swap amounts outside of sqrtPriceLimitX96–this guarantees that the current price will never cross the limiting price.\nSlippage Protection in Minting #  Adding liquidity also requires slippage protection. This comes from the fact that price cannot be changed when adding liquidity (liquidity must be proportional to current price), thus liquidity providers also suffer from slippage. Unlike swap function however, we\u0026rsquo;re not forced to implement slippage protection in Pool contract–recall that Pool contract is a core contract and we don\u0026rsquo;t want to put unnecessary logic into it. This is why we made Manager contract, and it\u0026rsquo;s in the Manager contract where we\u0026rsquo;ll implement slippage protection.\nManager contract is a wrapper contract that makes calls to Pool contract more convenient. To implement slippage protection in mint function, we can simply check the amounts of tokens taken by Pool and compare them to some minimal amounts chosen by user. Additionally, we can free users from calculating $\\sqrt{P_{lower}}$ and $\\sqrt{P_{upper}}$, as well as liquidity, and calculate these in Manager.mint function.\nOur update mint function will now take more parameters, so let\u0026rsquo;s group them in a struct:\n// src/UniswapV3Manager.sol contract UniswapV3Manager {  struct MintParams {  address poolAddress;  int24 lowerTick;  int24 upperTick;  uint256 amount0Desired;  uint256 amount1Desired;  uint256 amount0Min;  uint256 amount1Min;  }   function mint(MintParams calldata params)  public  returns (uint256 amount0, uint256 amount1)  {  ... amount0Min and amount1Min are the amounts that are calculated based on slippage tolerance. They must be smaller than the desired amounts, with the gap set by the slippage tolerance setting. Liquidity provider expect to provide amounts not smaller than amount0Min and amount1Min.\nNext, we calculate $\\sqrt{P_{lower}}$, $\\sqrt{P_{upper}}$, and liquidity:\n... IUniswapV3Pool pool = IUniswapV3Pool(params.poolAddress);  (uint160 sqrtPriceX96, ) = pool.slot0(); uint160 sqrtPriceLowerX96 = TickMath.getSqrtRatioAtTick(  params.lowerTick ); uint160 sqrtPriceUpperX96 = TickMath.getSqrtRatioAtTick(  params.upperTick );  uint128 liquidity = LiquidityMath.getLiquidityForAmounts(  sqrtPriceX96,  sqrtPriceLowerX96,  sqrtPriceUpperX96,  params.amount0Desired,  params.amount1Desired ); ... LiquidityMath.getLiquidityForAmounts is a new function, we\u0026rsquo;ll discuss it in the next chapter.\nNext step is to provide liquidity to the pool and the amounts returned by the pool: if they\u0026rsquo;re too low, we revert.\n(amount0, amount1) = pool.mint(  msg.sender,  params.lowerTick,  params.upperTick,  liquidity,  abi.encode(  IUniswapV3Pool.CallbackData({  token0: pool.token0(),  token1: pool.token1(),  payer: msg.sender  })  ) );  if (amount0 \u0026lt; params.amount0Min || amount1 \u0026lt; params.amount1Min)  revert SlippageCheckFailed(amount0, amount1); That\u0026rsquo;s it!\n"},{"id":16,"href":"/docs/milestone_2/tick-bitmap-index/","title":"Tick Bitmap Index","section":"Milestone 2. Second Swap","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]  Tick Bitmap Index #  As the first step towards dynamic swaps, we need to implement an index of ticks. In the previous milestone, we used to calculate the target tick when making a swap:\nfunction swap(address recipient, bytes calldata data)  public  returns (int256 amount0, int256 amount1) {  int24 nextTick = 85184;  ... } When there\u0026rsquo;s liquidity provided in different price ranges, we cannot simply calculate the target tick. We need to find it depending on the amount of liquidity in different price ranges. Thus, we need to index all ticks that have liquidity and then use the index to find ticks to \u0026ldquo;fill\u0026rdquo; enough liquidity for a swap. In this step, we\u0026rsquo;re going to implement such index.\nBitmap #  Bitmap is a popular technique of indexing data in a compact way. A bitmap is simply an array of zeros and ones, where each element as and index and corresponds to some external entity (something that\u0026rsquo;s indexed). Each element can be a zero or a one, which can be seemed as setting a flag: when 0, flag is not set; when 1, flag is set. What makes this approach favorable is that the whole array can be stored as a single number in the binary number system!\nFor example, the array 111101001101001 is number 31337. The number takes two bytes (0x7a69) and two bytes can store 16 flags (1 byte = 8 bits).\nUniswap V3 uses this technique to store the information about initialized ticks, that is ticks with some liquidity. When a flag is set (1), the tick has liquidity; when flag is not set (0), the tick is not initialized. Let\u0026rsquo;s review the implementation.\nTickBitmap Contract #  In the pool contract, the tick index is stored in a state variable:\ncontract UniswapV3Pool {  using TickBitmap for mapping(int16 =\u0026gt; uint256);  mapping(int16 =\u0026gt; uint256) public tickBitmap;  ... } This is mapping where keys are int16\u0026rsquo;s and values are words (uint256). Imagine an infinite continuous array of ones and zeros:\n[TODO: add illustration]\nEach element in this array corresponds to a tick. To navigate in this array, we break it into words: sub-arrays of length 256 bits. To find tick\u0026rsquo;s position in this array, we do:\nfunction position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) {  wordPos = int16(tick \u0026gt;\u0026gt; 8);  bitPos = uint8(uint24(tick % 256)); } That is: we find its word position and then its bit in this word. \u0026gt;\u0026gt; 8 is identical to division by 256. So, word position is the integer part of tick index divided by 256, and bit position is the remainder.\nAs an example, let\u0026rsquo;s calculate word and bit positions for one of our ticks:\ntick = 85176 word_pos = tick \u0026gt;\u0026gt; 8 # or tick // 2**8 bit_pos = tick % 256 print(f\u0026#34;Word {word_pos}, bit {bit_pos}\u0026#34;) # Word 332, bit 184 Flipping Flags #  When adding liquidity into a pool, we need to set a couple of tick flags in the bitmap: one for the lower tick and one for the upper tick. We do this in flipTick method of the bitmap mapping:\nfunction flipTick(  mapping(int16 =\u0026gt; uint256) storage self,  int24 tick,  int24 tickSpacing ) internal {  require(tick % tickSpacing == 0); // ensure that the tick is spaced  (int16 wordPos, uint8 bitPos) = position(tick / tickSpacing);  uint256 mask = 1 \u0026lt;\u0026lt; bitPos;  self[wordPos] ^= mask; }  Until later in the book, tickSpacing is always 1.\n After finding word and bit positions, we need to make a mask. A mask is a number that has a single 1 flag set at the bit position of the tick. To find the mask, we simply calculate 2**bit_pos (equivalent of 1 \u0026lt;\u0026lt; bit_pos):\nmask = 2**bit_pos # or 1 \u0026lt;\u0026lt; bit_pos print(bin(mask)) #0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 Next, to flip a flag, we apply the mask to the tick\u0026rsquo;s word via bitwise XOR:\nword = (2**256) - 1 # set word to all ones print(bin(word ^ mask)) #0b11111111111111111111111111111111111111111111111111111111111111111111111-\u0026gt;0\u0026lt;-1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 You\u0026rsquo;ll see that 184th bit (counting from the right starting at 0) has flipped to 0.\nFinding Next Tick #  Next step is finding ticks with liquidity using the bitmap index.\nDuring swapping, we need to find a tick with liquidity that\u0026rsquo;s before or after the current tick (that is: to the left or to the right of it). In the previous milestone, we used to calculate and hard code it, but now we need to find such tick using the bitmap index. We\u0026rsquo;ll do this in TickMath.nextInitializedTickWithinOneWord method. In this function, we\u0026rsquo;ll need to implement two scenarios:\n When selling token $X$ (ETH in our case), find next initialized tick in the current tick\u0026rsquo;s word and to the right of the current tick. When selling token $Y$ (USDC in our case), find next initialized tick in the next (current + 1) tick\u0026rsquo;s word and to the left of the current tick.  This corresponds to the price movement when making swaps in either directions:\n[TODO: add illustration, price change direction and tick change direction]\nWe include the current price when price grows.\nNow, let\u0026rsquo;s look at the implementation:\nfunction nextInitializedTickWithinOneWord(  mapping(int16 =\u0026gt; uint256) storage self,  int24 tick,  int24 tickSpacing,  bool lte ) internal view returns (int24 next, bool initialized) {  int24 compressed = tick / tickSpacing;  ...  First arguments makes this function a method of mapping(int16 =\u0026gt; uint256). tick is the current tick. tickSpacing is always 1 until we start using it in Milestone 3. lte is the flag that sets the direction. When true, we\u0026rsquo;re selling token $X$ and searching for next initialized tick to the right of the current one. When false, it\u0026rsquo;s the other way around.  if (lte) {  (int16 wordPos, uint8 bitPos) = position(compressed);  uint256 mask = (1 \u0026lt;\u0026lt; bitPos) - 1 + (1 \u0026lt;\u0026lt; bitPos);  uint256 masked = self[wordPos] \u0026amp; mask;  ... When selling $X$, we\u0026rsquo;re:\n taking current tick\u0026rsquo;s word and bit positions; making a mask where all bits to the right of the current bit position, including it, are ones (mask is all ones, its length = bitPos); applying the mask to the current tick\u0026rsquo;s word.   ...  initialized = masked != 0;  next = initialized  ? (compressed - int24(uint24(bitPos - BitMath.mostSignificantBit(masked)))) * tickSpacing  : (compressed - int24(uint24(bitPos))) * tickSpacing;  ... Next, masked won\u0026rsquo;t equal 0 if at least one bit of it is set to 1. If so, there\u0026rsquo;s an initialized tick; if not, there isn\u0026rsquo;t (not in the current word). Depending on the result, we either return the index of the next initialized tick or the leftmost bit in the next word–this will allow to search for initialized ticks in the word during another loop cycle.\n ... } else {  (int16 wordPos, uint8 bitPos) = position(compressed + 1);  uint256 mask = ~((1 \u0026lt;\u0026lt; bitPos) - 1);  uint256 masked = self[wordPos] \u0026amp; mask;  ... Similarly, when selling $Y$, we\u0026rsquo;re:\n taking next tick\u0026rsquo;s word and bit positions; making a different mask, where all bits to the left of next tick bit position are ones and all the bits to the right are zeros; applying the mask to the next tick\u0026rsquo;s word.  Again, if there\u0026rsquo;s no initialized ticks to the left, the rightmost bit of the previous word is returned:\n ...  initialized = masked != 0;  // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick  next = initialized  ? (compressed + 1 + int24(uint24((BitMath.leastSignificantBit(masked) - bitPos)))) * tickSpacing  : (compressed + 1 + int24(uint24((type(uint8).max - bitPos)))) * tickSpacing; } And that\u0026rsquo;s it!\nAs you can see, nextInitializedTickWithinOneWord doesn\u0026rsquo;t find the exact tick–it\u0026rsquo;s scope of search is current or next tick\u0026rsquo;s word. Indeed, we don\u0026rsquo;t want to iterate over all the words since the we don\u0026rsquo;t send boundaries on the bitmap index. This function, however, plays well with swap function–soon, we\u0026rsquo;ll see this.\n"},{"id":17,"href":"/docs/milestone_2/generalize-minting/","title":"Generalize Minting","section":"Milestone 2. Second Swap","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]  Generalize Minting #  Now, we\u0026rsquo;re ready to update mint function so it calculates the amounts of tokens instead of hard coding them.\nIndexing Initialized Ticks #  Recall that, in mint function, we update the TickInfo mapping to store information about available liquidity at ticks. Now, we also need to index newly initialized ticks in the bitmap index–we\u0026rsquo;ll later use this index to find next initialized tick during swapping.\nFirst, we need to update Tick.update function:\n// src/lib/Tick.sol function update(  mapping(int24 =\u0026gt; Tick.Info) storage self,  int24 tick,  uint128 liquidityDelta ) internal returns (bool flipped) {  ...  flipped = (liquidityAfter == 0) != (liquidityBefore == 0);  ... } It now returns flipped flag, which is set to true when liquidity is added to an empty tick or when entire liquidity is removed from a tick.\nThen, in mint function, we update the bitmap index:\n// src/UniswapV3Pool.sol ... bool flippedLower = ticks.update(lowerTick, amount); bool flippedUpper = ticks.update(upperTick, amount);  if (flippedLower) {  tickBitmap.flipTick(lowerTick, 1); }  if (flippedUpper) {  tickBitmap.flipTick(upperTick, 1); } ...  Again, we\u0026rsquo;re setting tick spacing to 1 until we introduce different values in Milestone 3.\n Token Amounts Calculation #  The biggest change in mint function is switching to tokens amount calculation. In Milestone 1, we hard coded these values:\n amount0 = 0.998976618347425280 ether;  amount1 = 5000 ether; And now we\u0026rsquo;re going to calculate them in Solidity using formulas from Milestone 1. Let\u0026rsquo;s recall those formulas:\n$$\\Delta x = \\frac{L(\\sqrt{p(i_u)} - \\sqrt{p(i_c)})}{\\sqrt{p(i_u)}\\sqrt{p(i_c)}}$$ $$\\Delta y = L(\\sqrt{p(i_c)} - \\sqrt{p(i_l)})$$\n$\\Delta x$ is the amount of token0, or token $X$. Let\u0026rsquo;s implement it in Solidity:\n// src/lib/Math.sol function calcAmount0Delta(  uint160 sqrtPriceAX96,  uint160 sqrtPriceBX96,  uint128 liquidity ) internal pure returns (uint256 amount0) {  if (sqrtPriceAX96 \u0026gt; sqrtPriceBX96)  (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);   require(sqrtPriceAX96 \u0026gt; 0);   amount0 = divRoundingUp(  mulDivRoundingUp(  (uint256(liquidity) \u0026lt;\u0026lt; FixedPoint96.RESOLUTION),  (sqrtPriceBX96 - sqrtPriceAX96),  sqrtPriceBX96  ),  sqrtPriceAX96  ); }  This function is identical to calc_amount0 in our Python script.\n First step is to sort the prices to ensure we don\u0026rsquo;t underflow when subtracting. Next, we convert liquidity to a Q96.64 number by multiplying it by 2**96. Next, according to the formula, we multiply it by the difference of the prices and divide it by the bigger price. Then, we divide by the smaller price. The order of division doesn\u0026rsquo;t matter, but we want to have two divisions because multiplication of prices can overflow.\nWe\u0026rsquo;re using mulDivRoundingUp to multiply and divide in one operation. This function is based on mulDiv from PRBMath:\nfunction mulDivRoundingUp(  uint256 a,  uint256 b,  uint256 denominator ) internal pure returns (uint256 result) {  result = PRBMath.mulDiv(a, b, denominator);  if (mulmod(a, b, denominator) \u0026gt; 0) {  require(result \u0026lt; type(uint256).max);  result++;  } } mulmod is a Solidity function that multiplies two numbers (a and b), divides the result by denominator, and returns the remainder. If the remainder is positive, we round the result up.\n We always round calculated amounts up because we haven\u0026rsquo;t implement liquidity removal yet. We adding liquidity, we want to ensure that calculated token amounts \u0026ldquo;fill\u0026rdquo; the entire liquidity.\n Next, $\\Delta y$:\nfunction calcAmount1Delta(  uint160 sqrtPriceAX96,  uint160 sqrtPriceBX96,  uint128 liquidity ) internal pure returns (uint256 amount1) {  if (sqrtPriceAX96 \u0026gt; sqrtPriceBX96)  (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);   amount1 = mulDivRoundingUp(  liquidity,  (sqrtPriceBX96 - sqrtPriceAX96),  FixedPoint96.Q96  ); }  This function is identical to calc_amount1 in our Python script.\n Again, we\u0026rsquo;re using mulDivRoundingUp to avoid overflows during multiplication.\nAnd that\u0026rsquo;s it! We can now use the functions to calculate token amounts:\n// src/UniswapV3Pool.sol function mint(...) {  ...  Slot0 memory slot0_ = slot0;   amount0 = Math.calcAmount0Delta(  TickMath.getSqrtRatioAtTick(slot0_.tick),  TickMath.getSqrtRatioAtTick(upperTick),  amount  );   amount1 = Math.calcAmount1Delta(  TickMath.getSqrtRatioAtTick(slot0_.tick),  TickMath.getSqrtRatioAtTick(lowerTick),  amount  );  ... } Everything else remains the same. You\u0026rsquo;ll need to update the amounts in the pool tests, they\u0026rsquo;ll be slightly different due to rounding.\n"},{"id":18,"href":"/docs/milestone_3/liquidity-calculation/","title":"Liquidity Calculation","section":"Milestone 3. Cross-tick Swaps","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]  Liquidity Calculation #  Of the whole math of Uniswap V3, what we haven\u0026rsquo;t yet implemented in Solidity is liquidity calculation. In the Python script, we have these functions:\ndef liquidity0(amount, pa, pb):  if pa \u0026gt; pb:  pa, pb = pb, pa  return (amount * (pa * pb) / q96) / (pb - pa)   def liquidity1(amount, pa, pb):  if pa \u0026gt; pb:  pa, pb = pb, pa  return amount * q96 / (pb - pa) Let\u0026rsquo;s implement them in Solidity so we could calculate liquidity in Manager.mint function.\nImplementing Liquidity Calculation for Token X #  The functions we\u0026rsquo;re going to implement allow us to calculate liquidity ($L = \\sqrt{xy}$) when token amounts and price ranges are known. Luckily, we already know all the formulas. Let\u0026rsquo;s recall this one:\n$$\\Delta x = \\Delta \\frac{1}{\\sqrt{P}}L$$\nIn a previous chapter, we used this formula to calculate swap amounts ($\\Delta x$ in this case) and now we\u0026rsquo;re going to use it to find $L$:\n$$L = \\frac{\\Delta x}{\\Delta \\frac{1}{\\sqrt{P}}}$$\nOr, after simplifying it: $$L = \\frac{\\Delta x \\sqrt{P_u} \\sqrt{P_l}}{\\sqrt{P_u} - \\sqrt{P_l}}$$\nWhere $\\Delta\\sqrt{P} = \\sqrt{P_u} - \\sqrt{P_l}$ and $\\Delta\\frac{1}{\\sqrt{P}} = \\frac{1}{\\sqrt{P_u}}-\\frac{1}{\\sqrt{P_l}}$ and $P_u$ is the bigger of the two prices and $P_l$ is the smaller of them.\nIn Solidity, we\u0026rsquo;ll again use PRBMath to handle overflows when multiplying and then dividing:\nfunction getLiquidityForAmount0(  uint160 sqrtPriceAX96,  uint160 sqrtPriceBX96,  uint256 amount0 ) internal pure returns (uint128 liquidity) {  if (sqrtPriceAX96 \u0026gt; sqrtPriceBX96)  (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);   uint256 intermediate = PRBMath.mulDiv(  sqrtPriceAX96,  sqrtPriceBX96,  FixedPoint96.Q96  );  liquidity = uint128(  PRBMath.mulDiv(amount0, intermediate, sqrtPriceBX96 - sqrtPriceAX96)  ); } Implementing Liquidity Calculation for Token Y #  Likewise, we\u0026rsquo;re using a formula from the other chapter to find $L$ when amount of $Y$ and price range is known: $$\\Delta y = \\Delta\\sqrt{P} L$$ $$L = \\frac{\\Delta y}{\\sqrt{P_u}-\\sqrt{P_l}}$$\nfunction getLiquidityForAmount1(  uint160 sqrtPriceAX96,  uint160 sqrtPriceBX96,  uint256 amount1 ) internal pure returns (uint128 liquidity) {  if (sqrtPriceAX96 \u0026gt; sqrtPriceBX96)  (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);   liquidity = uint128(  PRBMath.mulDiv(  amount1,  FixedPoint96.Q96,  sqrtPriceBX96 - sqrtPriceAX96  )  ); } I hope this is clear!\nFinding Fair Liquidity #  You might be wondering why there are two ways of calculating $L$ while we have always had only one $L$, which is calculated as $L = \\sqrt{xy}$, and which of these ways is correct. The answer is: they\u0026rsquo;re both correct.\nIn the above formulas, we calculate $L$ based on different parameters: price range and the amount of either token. Different price ranges and different token amounts will result in different values of $L$. And there\u0026rsquo;s a scenario where we need to calculate both of the $L$\u0026rsquo;s and pick one of them. Recall this piece from mint function:\nif (slot0_.tick \u0026lt; lowerTick) {  amount0 = Math.calcAmount0Delta(...); } else if (slot0_.tick \u0026lt; upperTick) {  amount0 = Math.calcAmount0Delta(...);   amount1 = Math.calcAmount1Delta(...);   liquidity = LiquidityMath.addLiquidity(liquidity, int128(amount)); } else {  amount1 = Math.calcAmount1Delta(...); } It turns out, we also need to follow this logic when calculating liquidity:\n If we\u0026rsquo;re calculating liquidity for a range that\u0026rsquo;s below current price, we use the $\\Delta x$ version on the formula. When calculation liquidity for a range that\u0026rsquo;s above current price, we use the $\\Delta y$ one. When a price range includes the current price, we calculate both and pick the smaller of them.  The reasoning is the same as that of the piece of the code above: when price range is outside of current price, it\u0026rsquo;s entirely configured by either of the tokens, not both of them.\nLet\u0026rsquo;s implement this logic now. When current price is below the lower bound of a price range:\nfunction getLiquidityForAmounts(  uint160 sqrtPriceX96,  uint160 sqrtPriceAX96,  uint160 sqrtPriceBX96,  uint256 amount0,  uint256 amount1 ) internal pure returns (uint128 liquidity) {  if (sqrtPriceAX96 \u0026gt; sqrtPriceBX96)  (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);   if (sqrtPriceX96 \u0026lt;= sqrtPriceAX96) {  liquidity = getLiquidityForAmount0(  sqrtPriceAX96,  sqrtPriceBX96,  amount0  ); When current price is within a range:\n} else if (sqrtPriceX96 \u0026lt;= sqrtPriceBX96) {  uint128 liquidity0 = getLiquidityForAmount0(  sqrtPriceX96,  sqrtPriceBX96,  amount0  );  uint128 liquidity1 = getLiquidityForAmount1(  sqrtPriceAX96,  sqrtPriceX96,  amount1  );   liquidity = liquidity0 \u0026lt; liquidity1 ? liquidity0 : liquidity1; We\u0026rsquo;re picking the smaller $L$ because the bigger one already includes it.\n[TODO: what about different distances between P_l-P-P_u? Will L be much smaller if P-P_l is smaller than P_u-P?]\nAnd finally:\n} else {  liquidity = getLiquidityForAmount1(  sqrtPriceAX96,  sqrtPriceBX96,  amount1  ); } Done.\n"},{"id":19,"href":"/docs/milestone_1/manager-contract/","title":"Manager Contract","section":"Milestone 1. First Swap","content":"Manager Contract #  Before deploying our pool contract, we need to solve one problem. As you remember, Uniswap V3 contracts are split into two categories:\n Core contracts that implement the core functions and don\u0026rsquo;t provide user-friendly interfaces. Periphery contracts that implement user-friendly interfaces for the core contracts.  The pool contract is a core contract, it\u0026rsquo;s not supposed to be user-friendly and flexible. It expects the caller to do all the calculations (prices, amounts) and to provide proper call parameters. It also doesn\u0026rsquo;t use ERC20\u0026rsquo;s transferFrom to transfer tokens from the caller. Instead, it uses two callbacks:\n uniswapV3MintCallback, which is called when minting liquidity; uniswapV3SwapCallback, which is called when swapping tokens.  In our tests, we implemented these callbacks in the test contract. Since it\u0026rsquo;s only a contract that can implement them, the pool contract cannot be called by regular users (non-contract addresses). This is fine. But not anymore 🙂.\nOur next steps in the book is deploying the pool contract to a local blockchain and interacting with it from a front-end app. Thus, we need to build a contract that will let non-contract addresses to interact with the pool. Let\u0026rsquo;s do this now!\nWorkflow #  This is how the manager contract will work:\n To mint liquidity, we\u0026rsquo;ll approve spending of tokens to the manager contract. We\u0026rsquo;ll then call mint function of the manager contract and pass it minting parameters, as well as the address of the pool we want to provide liquidity into. The manager contract will call the pool\u0026rsquo;s mint function and will implement uniswapV3MintCallback. It\u0026rsquo;ll have permissions permissions to send our tokens to the pool contract. To swap tokens, we\u0026rsquo;ll also approve spending of tokens to the manager contract. We\u0026rsquo;ll then call swap function of the manager contract and, similarly to minting, it\u0026rsquo;ll pass the call to the pool. The pool will take tokens from the manager contract, swap then, and will send the output amount to us.  At this point, the manager contract will act as a simple intermediary, but in later chapter we\u0026rsquo;ll add more useful functions to it.\nPassing Data to Callbacks #  Before implementing the manager contract, we need to upgrade the pool contract.\nThe manager contract will work with any pool and it\u0026rsquo;ll allow any address to call it. To achieve this, we need to upgrade the callbacks: we want to pass different pool addresses and user addresses to them. Let\u0026rsquo;s look at our current implementation of uniswapV3MintCallback (in the test contract):\nfunction uniswapV3MintCallback(uint256 amount0, uint256 amount1) public {  if (transferInMintCallback) {  token0.transfer(msg.sender, amount0);  token1.transfer(msg.sender, amount1);  } } Key points here:\n The function transfers tokens belonging to the test contract–we want it to transfer tokens from the caller by using transferFrom. The function knows token0 and token1, which will be different for every pool.  Conclusion: we want to change the arguments of the callback so we could pass:\n User address. Pool address.  Now, let\u0026rsquo;s look at the swap callback:\nfunction uniswapV3SwapCallback(int256 amount0, int256 amount1) public {  if (amount0 \u0026gt; 0 \u0026amp;\u0026amp; transferInSwapCallback) {  token0.transfer(msg.sender, uint256(amount0));  }   if (amount1 \u0026gt; 0 \u0026amp;\u0026amp; transferInSwapCallback) {  token1.transfer(msg.sender, uint256(amount1));  } } Identically, it transfers tokens from the test contract and it knows token0 and token1.\nTo pass the extra data to the callbacks, we need to pass it to mint and swap first (since callbacks are called from these functions). However, since this extra data is not used in the function and to not make their arguments messy, we\u0026rsquo;ll encode the extra data using abi.encode().\nLet\u0026rsquo;s define the extra data as a structure:\n// src/UniswapV3Pool.sol ... struct CallbackData {  address token0;  address token1;  address payer; } ... And then pass encoded data to callbacks:\nfunction mint(  address owner,  int24 lowerTick,  int24 upperTick,  uint128 amount,  bytes calldata data // \u0026lt;--- New line ) external returns (uint256 amount0, uint256 amount1) {  ...  IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(  amount0,  amount1,  data // \u0026lt;--- New line  );  ... }  function swap(address recipient, bytes calldata data) // \u0026lt;--- `data` added  public  returns (int256 amount0, int256 amount1) {  ...  IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(  amount0,  amount1,  data // \u0026lt;--- New line  );  ... } Now, we can read the extra data in the callbacks in the test contract.\nfunction uniswapV3MintCallback(  uint256 amount0,  uint256 amount1,  bytes calldata data ) public {  if (transferInMintCallback) {  UniswapV3Pool.CallbackData memory extra = abi.decode(  data,  (UniswapV3Pool.CallbackData)  );   IERC20(extra.token0).transferFrom(extra.payer, msg.sender, amount0);  IERC20(extra.token1).transferFrom(extra.payer, msg.sender, amount1);  } } Try updating the rest of the code yourself, and if it gets too difficult, feel free peeking at this commit.\nImplementing Manager Contract #  Besides implementing the callbacks, the manager contract won\u0026rsquo;t much; it\u0026rsquo;ll simply redirect calls to a pool contract. This is a very minimalistic contract at this moment:\ncontract UniswapV3Manager {  function mint(  address poolAddress_,  int24 lowerTick,  int24 upperTick,  uint128 liquidity,  bytes calldata data  ) public {  UniswapV3Pool(poolAddress_).mint(  msg.sender,  lowerTick,  upperTick,  liquidity,  data  );  }   function swap(address poolAddress_, bytes calldata data) public {  UniswapV3Pool(poolAddress_).swap(msg.sender, data);  }   function uniswapV3MintCallback(...) {...}  function uniswapV3SwapCallback(...) {...} } The callbacks are identical to those in the test contract, with the exception that there are no transferInMintCallback and transferInSwapCallback flags since the manager contract always transfers contracts.\nWell, we\u0026rsquo;re now fully prepared for deploying and integrating with front end!\n"},{"id":20,"href":"/docs/milestone_3/more-on-fixed-point-numbers/","title":"A Little Bit More on Fixed-point Numbers","section":"Milestone 3. Cross-tick Swaps","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]  A Little Bit More on Fixed-point Numbers #  In this bonus chapter, I\u0026rsquo;d like to show you how to convert prices to ticks in Solidity. We don\u0026rsquo;t need to do this in the main contracts, but it\u0026rsquo;s helpful to have such function in tests so we don\u0026rsquo;t hardcode ticks and could write something like tick(5000)–this makes code easier to read because it\u0026rsquo;s more convenient for us to think in prices, not tick numbers.\nRecall that, to find ticks, we use TickMath.getTickAtSqrtRatio function, which takes $\\sqrt{P}$ as its argument, and $\\sqrt{P}$ in its turns is a Q64.96 fixed-point number. In smart contract tests, we need to check $\\sqrt{P}$ many times in many different test cases: mostly after mints and swaps. Instead of hard coding actual values, it might be cleaner to use a helper function like sqrtP(5000) that converts prices to $\\sqrt{P}$.\nSo, what\u0026rsquo;s the problem?\nThe problem is that Solidity doesn\u0026rsquo;t natively support the square root operation, which means we need a third-party library. Another problem is that prices are often relatively small numbers, like 10, 5000, 0.01, etc., and we don\u0026rsquo;t want to lose precision when taking square root.\nYou probably remember that we used PRBMath earlier in the book to implement multiply-then-divide operation that doesn\u0026rsquo;t overflow during multiplication. If you check PRBMath.sol contract, you\u0026rsquo;ll notice sqrt function. However, the function doesn\u0026rsquo;t support fixed-point numbers, as the function description points at. You can give it a try and see that PRBMath.sqrt(5000) results in 70, which is an integer number with lost precision (without the fractional part).\nIf you check prb-math repo, you\u0026rsquo;ll see these contracts: PRBMathSD59x18.sol and PRBMathUD60x18.sol. Aha! These are fixed-point number implementations. Let\u0026rsquo;s pick the latter and see how it goes: PRBMathUD60x18.sqrt(5000 * PRBMathUD60x18.SCALE) returns 70710678118654752440. This looks interesting! PRBMathUD60x18 is a library that implements fixed-numbers with 18 decimal places in the fractional part. So the number we got is actually 70.710678118654752440 (use cast --from-wei 70710678118654752440).\nHowever! We cannot use this number!\nThere are fixed-point numbers and fixed-point numbers. The Q64.96 fixed-point number used by Uniswap V3 is a binary number–64 and 96 signify binary places. But PRBMathUD60x18 implements a decimal fixed-point number (UD in the contract name means \u0026ldquo;unsigned, decimal\u0026rdquo;), where 60 and 18 signify decimal places. This difference is quite significant.\nLet\u0026rsquo;s see how to convert an arbitrary number (42) to either of the above fixed-point numbers:\n Q64.96: $42 * 2^{96}$ or, using bitwise left shift, 2 \u0026lt;\u0026lt; 96. The result is 3327582825599102178928845914112. UD60.18: $42 * 10^{18}$. The result is 42000000000000000000.  Let\u0026rsquo;s now see how to convert numbers with the fractional part (42.1337):\n Q64.96: $421337 * 2^{92}$ or 421337 \u0026lt;\u0026lt; 92. The result is 2086359769329537075540689212669952. UD60.18: $421337 * 10^{14}$. The result is 42133700000000000000.  The second variant makes more sense to us because it uses the decimal system, which we learned in our childhood. The first variant uses the binary system and it makes absolutely no sense.\nBut the biggest problem with different variants is that it\u0026rsquo;s hard to convert between them.\nThis all means that we need a different library, one that implements a binary fixed-point number and sqrt function for it. Luckily, there\u0026rsquo;s such library: abdk-libraries-solidity. The library implemented Q64.64, not exactly what we need (not 96 bits in the fractional part) but this is not a problem.\nHere\u0026rsquo;s how we can implement the price-to-tick function using the new library:\nfunction tick(uint256 price) internal pure returns (int24 tick_) {  tick_ = TickMath.getTickAtSqrtRatio(  uint160(  int160(  ABDKMath64x64.sqrt(int128(int256(price \u0026lt;\u0026lt; 64))) \u0026lt;\u0026lt;  (FixedPoint96.RESOLUTION - 64)  )  )  ); } ABDKMath64x64.sqrt takes Q64.64 numbers so we need to convert price to such number. The price is expected to not have the fractional part, so we\u0026rsquo;re shifting it by 64 bits. The sqrt function also returns a Q64.64 number but TickMath.getTickAtSqrtRatio takes a Q64.96 number–this is why we need to shift the square root by 96 - 64 bits to the left.\n"},{"id":21,"href":"/docs/milestone_1/deployment/","title":"Deployment","section":"Milestone 1. First Swap","content":"Deployment #  Alright, our contract is done. Now, let\u0026rsquo;s see how we can deploy it to a local Ethereum network so we could use it from a front-end app later on.\nChoosing Local Blockchain Network #  Smart contracts development requires running a local network, where you deploy your contracts during development and testing. This is what we want from such a network:\n Real blockchain. It must be a real Ethereum network, not an emulation. We want to be sure that our contract will work in the local network exactly as it would in the mainnet. Speed. We want our transactions to be minted immediately, so we could iterate quickly. Ether. To pay transaction fees, we need some ether, and we want the local network to allow us to generate any amount of ether. Cheat codes. Besides providing the standard API, we want a local network to allow us to do more. For example, we want to be able to deploy contracts at any address, execute transactions from any address (impersonate other address), change contract state directly, etc.  There are multiple solutions as of today:\n Ganache from Truffle Suite. Hardhat, which is a development environment that includes a local node besides other useful things. Anvil from Foundry.  All of these are viable solutions and each of them will satisfy our needs. Having said that, projects have been slowly migrating from Ganache (which is the oldest of the solutions) to Hardhat (which seems to be the most widely used these days), and now there\u0026rsquo;s the new kid on the block: Foundry. Foundry is also the only of these solutions that uses Solidity for writing tests (the others use JavaScript). Moreover, Foundry also allows to write deployment scripts in Solidity. Thus, since we\u0026rsquo;ve decided to use Solidity everywhere, we\u0026rsquo;ll use Anvil to run a local development blockchain, and we\u0026rsquo;ll write deployment scripts in Solidity.\nRunning Local Blockchain #  Anvil doesn\u0026rsquo;t require configuration, we can run it with a single command and it\u0026rsquo;ll do:\n$ anvil  _ _  (_) | |  __ _ _ __ __ __ _ | |  / _` | | \u0026#39;_ \\  \\ \\ / / | | | |  | (_| | | | | | \\ V / | | | |  \\__,_| |_| |_| \\_/ |_| |_|   0.1.0 (d89f6af 2022-06-24T00:15:17.897682Z)  https://github.com/foundry-rs/foundry ... Listening on 127.0.0.1:8545 Anvil runs a single Ethereum node, so this is not really a network, but that\u0026rsquo;s ok. By default, it creates 10 accounts with 10,000 ETH in each of them. It prints the addresses and related private keys when it starts–we\u0026rsquo;ll be using one of these addresses when deploying and interacting with the contract from UI.\nAnvil exposes JSON-RPC API interface at 127.0.0.1:8545–this interface is the main way of interacting with Ethereum nodes. You can find full API reference here. And this is how you can call it via curl:\n$ curl -X POST -H \u0026#39;Content-Type: application/json\u0026#39; \\  --data \u0026#39;{\u0026#34;id\u0026#34;:1,\u0026#34;jsonrpc\u0026#34;:\u0026#34;2.0\u0026#34;,\u0026#34;method\u0026#34;:\u0026#34;eth_chainId\u0026#34;}\u0026#39; \\  http://127.0.0.1:8545 {\u0026#34;jsonrpc\u0026#34;:\u0026#34;2.0\u0026#34;,\u0026#34;id\u0026#34;:1,\u0026#34;result\u0026#34;:\u0026#34;0x7a69\u0026#34;} $ curl -X POST -H \u0026#39;Content-Type: application/json\u0026#39; \\  --data \u0026#39;{\u0026#34;id\u0026#34;:1,\u0026#34;jsonrpc\u0026#34;:\u0026#34;2.0\u0026#34;,\u0026#34;method\u0026#34;:\u0026#34;eth_getBalance\u0026#34;,\u0026#34;params\u0026#34;:[\u0026#34;0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266\u0026#34;,\u0026#34;latest\u0026#34;]}\u0026#39; \\  http://127.0.0.1:8545 {\u0026#34;jsonrpc\u0026#34;:\u0026#34;2.0\u0026#34;,\u0026#34;id\u0026#34;:1,\u0026#34;result\u0026#34;:\u0026#34;0x21e19e0c9bab2400000\u0026#34;} You can also use cast (part of Foundry) for that:\n$ cast chain-id 31337 $ cast balance 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266 10000000000000000000000 Now, let\u0026rsquo;s deploy the pool and manager contracts to the local network.\nFirst Deployment #  At its core, deploying a contract means:\n Compiling source code into EVM bytecode. Sending a transaction with the bytecode. Creating a new address, executing the constructor par of the bytecode, storing initialized bytecode on the address. This step is done automatically by an Ethereum node, when your transaction is mined.  Deployment usually consists of multiple steps: preparing parameters, deploying auxiliary contracts, deploying main contracts, initializing contracts, etc. To automate these steps, scripting is used. As you might\u0026rsquo;ve already guessed, we\u0026rsquo;ll write scripts in Solidity!\nCreate scripts/DeployDevelopment.sol contract with this content:\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.14;  import \u0026#34;forge-std/Script.sol\u0026#34;;  contract DeployDevelopment is Script {  function run() public {  ...  } } It looks very similar to the test contract, besides the fact that it inherits from Script contract, not from Test. And, by convention, we need to define run function which will be the body of our deployment script. In the run function, we define the parameters of the deployment first:\nuint256 wethBalance = 1 ether; uint256 usdcBalance = 5042 ether; int24 currentTick = 85176; uint160 currentSqrtP = 5602277097478614198912276234240; These are the same values we used before. Notice that we\u0026rsquo;re about to mint 5042 USDC–that\u0026rsquo;s 5000 USDC we\u0026rsquo;ll provide as liquidity into the pool and 42 USDC we\u0026rsquo;ll sell in a swap.\nNext, we define the set of steps that will be executed as the deployment transaction (well, each of the steps will be a separate transaction). For this, we\u0026rsquo;re using startBroadcast/endBroadcast cheat codes:\nvm.startBroadcast(); ... vm.stopBroadcast();  Everything that goes after broadcast() cheat code or between startBroadcast/stopBroadcast is converted to transactions and these transactions are sent to the node that executes the script.\n Between the broadcast cheat codes, we\u0026rsquo;ll put the actual deployment steps. First, we need to deploy the tokens:\nERC20Mintable token0 = new ERC20Mintable(\u0026#34;Wrapped Ether\u0026#34;, \u0026#34;WETH\u0026#34;, 18); ERC20Mintable token1 = new ERC20Mintable(\u0026#34;USD Coin\u0026#34;, \u0026#34;USDC\u0026#34;, 18); We cannot deploy the pool without having tokens, so we need to deploy them first.\n Since we\u0026rsquo;re deploying to a local development network, we need to deploy the tokens ourselves. In the mainnet and public test networks (Ropsten, Goerli, Sepolia), the tokens are already created. Thus, to deploy to those networks, we\u0026rsquo;ll need to write network-specific deployment scripts.\n The next step is to deploy the pool contract:\nUniswapV3Pool pool = new UniswapV3Pool(  address(token0),  address(token1),  currentSqrtP,  currentTick ); Next, manager contract deployment:\nUniswapV3Manager manager = new UniswapV3Manager(); And finally, we can mint some amount of ETH and USDC to our address:\ntoken0.mint(msg.sender, wethBalance); token1.mint(msg.sender, usdcBalance); msg.sender in Foundy scripts is the address sending transactions, i.e. this is the address that will pay for the transaction.\nFinally, at the end of the script, add some console.log calls to print the addresses of deployed contracts:\nconsole.log(\u0026#34;WETH address\u0026#34;, address(token0)); console.log(\u0026#34;USDC address\u0026#34;, address(token1)); console.log(\u0026#34;Pool address\u0026#34;, address(pool)); console.log(\u0026#34;Manager address\u0026#34;, address(manager)); Alright, let\u0026rsquo;s run the script (ensure Anvil is running in another terminal window):\n$ forge script scripts/DeployDevelopment.s.sol --broadcast --fork-url localhost:8545 --private-key $PRIVATE_KEY --broadcast enables broadcasting of transactions. It\u0026rsquo;s not enabled by default because not every script sends transactions. --fork-url sets the address of the node to send transactions to. --private-key sets the sender account: a private key is needed to sign transactions. You can pick any of the private keys printed by Anvil when it\u0026rsquo;s starting. I picked the first one:\n 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\n Deployment takes several seconds. In the end, you\u0026rsquo;ll see a list of transactions it sent. It\u0026rsquo;ll also save transactions receipts to broadcast folder. In Anvil, you\u0026rsquo;ll also see many lines with eth_sendRawTransaction, eth_getTransactionByHash, and eth_getTransactionReceipt–after sending transactions to Anvil, Forge uses the JSON-RPC API to check their status and get transaction execution results (receipts).\nCongratulations! You\u0026rsquo;ve just deployed a smart contract!\nInteracting With Contracts, ABI #  Now, let\u0026rsquo;s see how we can interact with the deployed contracts.\nEvery contract exposes a set of public functions. In the case of the pool contract, these are mint and swap. Additionally, Solidity creates getters for public variables, so we can also call token0, token1, positions, etc. However, since contracts are compiled bytecodes, function names are lost during compilation and not stored on blockchain. Instead, every function is identified by a selector, which is the first 4 bytes of the hash of the signature of the function. In pseudocode:\nkeccak256(\u0026#34;transfer(address,address,uint256)\u0026#34;)[0:4] Knowing this, let\u0026rsquo;s make two calls to the deployed contracts: one will be a low-level call via curl, and one will be done via cast.\n We\u0026rsquo;ll soon learn how to make contract calls from a front-end application using a JS library.\n Token Balance #  Let\u0026rsquo;s check the WETH balance of the deployer address. The signature of the function is balanceOf(address). To find the id of this function (its selector), we\u0026rsquo;ll hash it and take the first four bytes:\n$ cast keccak \u0026#34;balanceOf(address)\u0026#34;| cut -b 1-10 0x70a08231 To pass the address, we simply append it to the function selector (and add left padding up to 32 digits since addresses take 32 bytes in calldata):\n 0x70a08231000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266\n 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266 is the address we\u0026rsquo;re going to check balance of. This is our address, the first account in Anvil.\nNext, we execute eth_call JSON-RPC method to make the call. Notice that this doesn\u0026rsquo;t require sending a transaction–this endpoint is used to read data from contracts.\n$ params=\u0026#39;{\u0026#34;from\u0026#34;:\u0026#34;0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266\u0026#34;,\u0026#34;to\u0026#34;:\u0026#34;0xe7f1725e7734ce288f8367e1bb143e90bb3f0512\u0026#34;,\u0026#34;data\u0026#34;:\u0026#34;0x70a08231000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266\u0026#34;}\u0026#39; $ curl -X POST -H \u0026#39;Content-Type: application/json\u0026#39; \\  --data \u0026#39;{\u0026#34;id\u0026#34;:1,\u0026#34;jsonrpc\u0026#34;:\u0026#34;2.0\u0026#34;,\u0026#34;method\u0026#34;:\u0026#34;eth_call\u0026#34;,\u0026#34;params\u0026#34;:[\u0026#39;\u0026#34;$params\u0026#34;\u0026#39;,\u0026#34;latest\u0026#34;]}\u0026#39; \\  http://127.0.0.1:8545 {\u0026#34;jsonrpc\u0026#34;:\u0026#34;2.0\u0026#34;,\u0026#34;id\u0026#34;:1,\u0026#34;result\u0026#34;:\u0026#34;0x00000000000000000000000000000000000000000000011153ce5e56cf880000\u0026#34;}  The \u0026ldquo;to\u0026rdquo; address is the USDC token. It\u0026rsquo;s printed by the deployment script and it can be different in your case.\n The node responses are in the hexadecimal system. To parse the result, we need to know its type. In the case of balanceOf function, the type of returned value is uint256. Using cast, we can convert it to a decimal number and then convert it to ethers:\n$ cast --to-dec 0x00000000000000000000000000000000000000000000011153ce5e56cf880000| cast --from-wei 5042.000000000000000000 The balance is correct! We minted to ourselves 42 USDC.\nCurrent Tick and Price #  The above example is a demonstration of low-level contract calls. Usually, you never do calls via curl and use a tool or library instead. And Cast can help us here again!\nLet\u0026rsquo;s get current pool liquidity using cast:\n$ cast call POOL_ADDRESS \u0026#34;slot0()\u0026#34;| xargs cast --abi-decode \u0026#34;a()(uint160,int24)\u0026#34; 5602277097478614198912276234240 85176 Nice! The first value is the current $\\sqrt{P}$ and the second value is the current tick.\n Since --abi-decode requires full function signature we have to specify \u0026ldquo;a()\u0026rdquo; even though we only want to decode function output.\n ABI #  To simplify interaction with contracts, Solidity compiler can output ABI, Application Binary Interface.\nABI is a JSON file that contains the description of all public methods and events of a contract. The goal of this file is to make it easier to encode function parameters and decode return values. To get ABI with Forge, use this command:\n$ forge inspect UniswapV3Pool abi Feel free skimming through the file better understand its content.\n"},{"id":22,"href":"/docs/milestone_2/generalize-swapping/","title":"Generalize Swapping","section":"Milestone 2. Second Swap","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]  Generalize Swapping #  This will be the hardest chapter of this milestone. Before updating the code, we need to understand how the algorithm of swapping in Uniswap V3 works.\nYou can think of swap as order fillings. A user submits an order to buy a specified amount of tokens to a pool. The pool needs to \u0026ldquo;fill\u0026rdquo; the amount specified by the user, send tokens to the user, and request some amount of the other token in exchange. This \u0026ldquo;filling\u0026rdquo; of an order is what we\u0026rsquo;re going to do in swap function.\nfunction swap(  address recipient,  bool zeroForOne,  uint256 amountSpecified,  bytes calldata data ) public returns (int256 amount0, int256 amount1) {  ... In swap function, we add two new parameters: zeroForOne and amountSpecified. zeroForOne is the flag that controls swap direction: when true, token0 is traded in for token1; when false, it\u0026rsquo;s the opposite. For example, if token0 is ETH and token1 is USDC, zeroForOne means buying USDC for ETH. amountSpecified is the amount of tokens user wants to sell.\nFilling Orders #  Since, in Uniswap V3, liquidity is stored in multiple price ranges, Pool contract needs to find all liquidity that\u0026rsquo;s required to \u0026ldquo;fill an order\u0026rdquo; from user. This is done via iterating over initialized ticks in a direction chosen by user.\nBefore continuing, we need to define two new structures:\nstruct SwapState {  uint256 amountSpecifiedRemaining;  uint256 amountCalculated;  uint160 sqrtPriceX96;  int24 tick; }  struct StepState {  uint160 sqrtPriceStartX96;  int24 nextTick;  uint160 sqrtPriceNextX96;  uint256 amountIn;  uint256 amountOut; } SwapState maintains current swap\u0026rsquo;s state. amountSpecifiedRemaining tracks the remaining amount of tokens that needs to be bought by Pool. When it\u0026rsquo;s zero, a swap is done. amountCalculated is the out amount calculated by the contract– it might not exactly match the amount specified by user due to slippage or incorrect calculations by user. sqrtPriceX96 and tick are new current price and tick after a swap is done.\nStepState maintains current swap step\u0026rsquo;s state. This structure tracks the state of one iteration of \u0026ldquo;order execution\u0026rdquo;. sqrtPriceStartX96 tracks the price the iteration begins with. nextTick is the next initialized tick that will provide liquidity for the swap and sqrtPriceNextX96 is the price at the next tick. amountIn and amountOut are amounts that can be provided by the liquidity of the current iteration.\n After we implement multi-range swaps (that is, swaps that happen across multiple price ranges), the idea of iterating will be clearer.\n ... Slot0 memory slot0_ = slot0;  SwapState memory state = SwapState({  amountSpecifiedRemaining: amountSpecified,  amountCalculated: 0,  sqrtPriceX96: slot0_.sqrtPriceX96,  tick: slot0_.tick }); ... Before filling an order, we initialize a SwapState instance. We\u0026rsquo;ll loop until amountSpecifiedRemaining is 0, which will mean that the pool has enough liquidity to buy amountSpecified tokens from user.\n... while (state.amountSpecifiedRemaining \u0026gt; 0) {  StepState memory step;   step.sqrtPriceStartX96 = state.sqrtPriceX96;   (step.nextTick, ) = tickBitmap.nextInitializedTickWithinOneWord(  state.tick,  1,  zeroForOne  );   step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.nextTick); In the loop, we set up a price range that should provide liquidity for the swap. The range is from state.sqrtPriceX96 to step.sqrtPriceNextX96, where the latter is the price at the next initialized tick (as returned by nextInitializedTickWithinOneWord–we know this function from a previous chapter).\n(state.sqrtPriceX96, step.amountIn, step.amountOut) = SwapMath  .computeSwapStep(  state.sqrtPriceX96,  step.sqrtPriceNextX96,  liquidity,  state.amountSpecifiedRemaining  ); Next, we\u0026rsquo;re calculating the amounts that can be provider by current price range, and the new current price the swap will result in.\n state.amountSpecifiedRemaining -= step.amountIn;  state.amountCalculated += step.amountOut;  state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96); } Final steps in the loop is updating the SwapState. step.amountIn is the amount of tokens the price range can buy from user; step.amountOut is the related number of the other token the pool can sell to user. state.sqrtPriceX96 is the current price that will be set after the swap (recall that trading changes current price).\nSwapMath Contract #  Let\u0026rsquo;s look closer at SwapMath.computeSwapStep.\n// src/lib/SwapMath.sol function computeSwapStep(  uint160 sqrtPriceCurrentX96,  uint160 sqrtPriceTargetX96,  uint128 liquidity,  uint256 amountRemaining )  internal  pure  returns (  uint160 sqrtPriceNextX96,  uint256 amountIn,  uint256 amountOut  ) {  ... This is the core logic of swapping. The function calculates input and amount amounts of a swap within a price range and respecting available liquidity.\nbool zeroForOne = sqrtPriceCurrentX96 \u0026gt;= sqrtPriceTargetX96;  sqrtPriceNextX96 = Math.getNextSqrtPriceFromInput(  sqrtPriceCurrentX96,  liquidity,  amountRemaining,  zeroForOne ); By checking the price, we can determine the direction of the swap. Knowing the direction, we can calculate the price after swapping amountRemaining of tokens. We\u0026rsquo;ll return to this function below.\nAfter finding the new price, we can calculate input and output amounts of the swap. We\u0026rsquo;re recalculating amountIn (it replaces amountRemaining) because amountRemaining is provided by user and it can be not accurate (and it can be affected by slippage):\namountIn = Math.calcAmount0Delta(  sqrtPriceCurrentX96,  sqrtPriceNextX96,  liquidity ); amountOut = Math.calcAmount1Delta(  sqrtPriceCurrentX96,  sqrtPriceNextX96,  liquidity ); And swap the amounts if the direction is opposite:\nif (!zeroForOne) {  (amountIn, amountOut) = (amountOut, amountIn); } That\u0026rsquo;s it for computeSwapStep!\nFinding Price by Swap Amount #  Let\u0026rsquo;s now look at Math.getNextSqrtPriceFromInput–the function calculates a $\\sqrt{P}$ given another $\\sqrt{P}$, liquidity, and input amount. It tells what the price will be after swapping the specified input amount of tokens, given the current price and liquidity.\nGood news is that we already know the formulas: recall how we calculated price_next in Python:\n# When amount_in is token0 price_next = int((liq * q96 * sqrtp_cur) // (liq * q96 + amount_in * sqrtp_cur)) # When amount_in is token1 price_next = sqrtp_cur + (amount_in * q96) // liq We\u0026rsquo;re going to implement this in Solidity:\n// src/lib/Math.sol function getNextSqrtPriceFromInput(  uint160 sqrtPriceX96,  uint128 liquidity,  uint256 amountIn,  bool zeroForOne ) internal pure returns (uint160 sqrtPriceNextX96) {  sqrtPriceNextX96 = zeroForOne  ? getNextSqrtPriceFromAmount0RoundingUp(  sqrtPriceX96,  liquidity,  amountIn  )  : getNextSqrtPriceFromAmount1RoundingDown(  sqrtPriceX96,  liquidity,  amountIn  ); } The function handles swapping in both directions.\nfunction getNextSqrtPriceFromAmount0RoundingUp(  uint160 sqrtPriceX96,  uint128 liquidity,  uint256 amountIn ) internal pure returns (uint160) {  uint256 numerator = uint256(liquidity) \u0026lt;\u0026lt; FixedPoint96.RESOLUTION;  uint256 product = amountIn * sqrtPriceX96;   if (product / amountIn == sqrtPriceX96) {  uint256 denominator = numerator + product;  if (denominator \u0026gt;= numerator) {  return  uint160(  mulDivRoundingUp(numerator, sqrtPriceX96, denominator)  );  }  }   return  uint160(  divRoundingUp(numerator, (numerator / sqrtPriceX96) + amountIn)  ); } In this function, we\u0026rsquo;re implementing two formulas. At the first return, it implements the same formula we implemented in Python. This is the most precise formula, but it can overflow when multiplying amountIn by sqrtPriceX96. The formula is (we discussed it in \u0026ldquo;Output Amount Calculation\u0026rdquo;): $$\\sqrt{P_{target}} = \\frac{\\sqrt{P}L}{\\Delta x \\sqrt{P} + L}$$\nWhen it overflows, we use an alternative formula which is less precise: $$\\sqrt{P_{target}} = \\frac{L}{\\Delta x + \\frac{L}{\\sqrt{P}}}$$\nWhich is simply the previous formula with numerator and denominator divided by $\\sqrt{P}$ to get rid of the multiplication.\nThe other function has simpler math:\nfunction getNextSqrtPriceFromAmount1RoundingDown(  uint160 sqrtPriceX96,  uint128 liquidity,  uint256 amountIn ) internal pure returns (uint160) {  return  sqrtPriceX96 +  uint160((amountIn \u0026lt;\u0026lt; FixedPoint96.RESOLUTION) / liquidity); } Finishing the Swap #  Let\u0026rsquo;s finish swap function. By this moment, we have looped over next initialized ticks, filled amountSpecified specified by user, calculated input and amount amounts, and found new price and tick. We now need to update contract\u0026rsquo;s state, send tokens to user, and get tokens in exchange.\nif (state.tick != slot0_.tick) {  (slot0.sqrtPriceX96, slot0.tick) = (state.sqrtPriceX96, state.tick); } First, we set new price and tick. Since this operation writes to contract\u0026rsquo;s storage, we want to do it only if the new tick is different, to optimize gas consumption.\n(amount0, amount1) = zeroForOne  ? (  int256(amountSpecified - state.amountSpecifiedRemaining),  -int256(state.amountCalculated)  )  : (  -int256(state.amountCalculated),  int256(amountSpecified - state.amountSpecifiedRemaining)  ); Next, we calculate swap amounts based on swap direction and the amounts calculated during the swap loop.\nif (zeroForOne) {  IERC20(token1).transfer(recipient, uint256(-amount1));   uint256 balance0Before = balance0();  IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(  amount0,  amount1,  data  );  if (balance0Before + uint256(amount0) \u0026gt; balance0())  revert InsufficientInputAmount(); } else {  IERC20(token0).transfer(recipient, uint256(-amount0));   uint256 balance1Before = balance1();  IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(  amount0,  amount1,  data  );  if (balance1Before + uint256(amount1) \u0026gt; balance1())  revert InsufficientInputAmount(); } Next, we\u0026rsquo;re exchanging tokens with user, depending on swap direction. This piece is identical to what we had in Milestone 2, only handling of the other swap direction was added.\nThat\u0026rsquo;s it! Swapping is done!\nTesting #  Test won\u0026rsquo;t change significantly, we only need to pass amountSpecified and zeroForOne to swap function. Output amount will change insignificantly though, because it\u0026rsquo;s now calculated in Solidity.\nWe can now test swapping in the opposite direction! I\u0026rsquo;ll leave this for you, as a homework (just be sure to choose a small input amount so the whole swap can be handled by our single price range).\n"},{"id":23,"href":"/docs/milestone_2/quoter-contract/","title":"Quoter Contract","section":"Milestone 2. Second Swap","content":"Quoter Contract #  To integrate our updated Pool contract into the front end app, we need a way to calculate swap amounts without making a swap. Users will type in the amount they want to sell, and we want to calculate and show them the amount they\u0026rsquo;ll get in exchange. We\u0026rsquo;ll do this through Quoter contract.\nSince liquidity in Uniswap V3 is scattered over multiple price ranges, we cannot calculate swap amounts with a formula (which was possible in Uniswap V2). The design of Uniswap V3 forces us to use a different approach: to calculate swap amounts, we\u0026rsquo;ll initiate a real swap and will interrupt it in the callback function, grabbing the amounts calculated by Pool contract. That is, we have to simulate a real swap to calculate output amount.\nLet\u0026rsquo;s do this in a separate contract!\ncontract UniswapV3Quoter {  struct QuoteParams {  address pool;  uint256 amountIn;  bool zeroForOne;  }   function quote(QuoteParams memory params)  public  returns (  uint256 amountOut,  uint160 sqrtPriceX96After,  int24 tickAfter  )  {  ... Quoter is a contract that implements only one public function–quote. Quoter is a universal contract that works with any pool so it takes pool address as a parameter. The other parameters (amountIn and zeroForOne) are required to simulate a swap.\ntry  IUniswapV3Pool(params.pool).swap(  address(this),  params.zeroForOne,  params.amountIn,  abi.encode(params.pool)  ) {} catch (bytes memory reason) {  return abi.decode(reason, (uint256, uint160, int24)); } The only thing that the contract does is calling swap function of a pool. The call is expected to revert (i.e. throw an error)–we\u0026rsquo;ll do this in the swap callback. In case of a revert, revert reason is decoded and returned (quote will not revert). Notice that we\u0026rsquo;re passing only pool address as the extra data–we\u0026rsquo;re free to pass whatever data we want, but we\u0026rsquo;ll need to know pool address to read updated price and tick. Yes, the function also returns updated price and tick.\nfunction uniswapV3SwapCallback(  int256 amount0Delta,  int256 amount1Delta,  bytes memory data ) external view {  address pool = abi.decode(data, (address));   uint256 amountOut = amount0Delta \u0026gt; 0  ? uint256(-amount1Delta)  : uint256(-amount0Delta);   (uint160 sqrtPriceX96After, int24 tickAfter) = IUniswapV3Pool(pool)  .slot0(); In the swap callback, we\u0026rsquo;re collecting values that we need: output amount, new price, and corresponding tick. Next, we need to save these values and revert:\nassembly {  let ptr := mload(0x40)  mstore(ptr, amountOut)  mstore(add(ptr, 0x20), sqrtPriceX96After)  mstore(add(ptr, 0x40), tickAfter)  revert(ptr, 96) } Since revert function in Solidity can only return a string as the reason (not bytes), we need to turn to Yul, the language used for inline assembly in Solidity. Let\u0026rsquo;s break this piece down:\n mload(0x40) reads the pointer of the next available memory slot (memory in EVM is organized in 32 byte slots); at that memory slot, mstore(ptr, amountOut) writes amountOut; mstore(add(ptr, 0x20), sqrtPriceX96After) writes sqrtPriceX96After right after amountOut; mstore(add(ptr, 0x40), tickAfter) writes tickAfter after sqrtPriceX96After; revert(ptr, 96) reverts the call and returns 96 bytes (total length of the values we wrote to memory) of data at address ptr (start of the data we wrote above).  Notice that the offsets are always 32 bytes, even though sqrtPriceX96After takes 14 bytes (uint160) and tickAfter takes 3 bytes (int24). This is so we could use abi.decode() to decode the data: its counterpart, abi.encode(), encodes all integers as 32-byte words.\nAaaand, done.\nRecap #  Let\u0026rsquo;s recap to better understand the algorithm:\n quote calls swap of a pool with input amount and swap direction; swap performs a real swap, it runs the loop to fill the input amount specified by user; to get tokens from user, swap calls the swap callback on the caller; the caller (Quote contract) implements the callback, in which it reverts with output amount, new price, and new tick; the revert bubbles up to the initial quote call; in quote, the revert is caught, revert reason is decoded and returned as the result of calling quote.  I hope this is clear!\nQuoter Limitation #  This design has one significant limitation: since quote calls swap function of Pool contract, and swap function is not a pure or view function (because it modifies contract state), quote cannot also be pure or view. swap modifies state and so does quote, even if not in Quoter contract. But we treat quote as a getter, a function that only reads contract data. This inconsistency means that EVM will use CALL opcode instead of CALLSTATIC when quote is called. This is not a big problem since Quoter reverts in the swap callback, and reverting reset state modified during a call–this guarantees that quote won\u0026rsquo;t modify state of Pool contract.\nAnother inconvenience that comes from this issue is that calling quote from a client library (ethers.js, web3.js, etc.) will trigger a transaction. To fix this, we\u0026rsquo;ll need to force the library to make a static call. We\u0026rsquo;ll see how to do this in ethers.js later in this milestone.\n"},{"id":24,"href":"/docs/milestone_1/user-interface/","title":"User Interface","section":"Milestone 1. First Swap","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]  User Interface #  Finally, we made it to the final stop of this milestone–building a user interface!\n[TODO: screenshot of the main page]\nSince building a front-end app is not the main goal of this book, I won\u0026rsquo;t show how to build such an app from scratch. Instead, I\u0026rsquo;ll show how to use MetaMask to interact with a decentralized exchange.\n If you want to experiment with the app and run it locally, you can fund it in ui folder in the code repo. This is a simple React app, to run it locally set contracts addresses in App.js and run yarn start.\n Overview of Tools #  What is MetaMask? #  MetaMask is an Ethereum wallet implemented as a browser extension. It creates and stores private keys, shows token balances, allows to connect to different networks, sends, and receives ether and tokens-everything a wallet needs to do.\nBesides that, MetaMask acts as a signer and a provider. As a provider, it connects to an Ethereum node and provides an interface to use its JSON-RPC API. As a signer, it provides an interface for secure transaction signing, thus it can be used to sign any transaction using a private key from the wallet.\n[TODO: draw a scheme]\nConvenience Libraries #  MetaMask, however, doesn\u0026rsquo;t provide much functionality: it can only manage accounts and send raw transactions. We need another library that will make interaction with contracts easy. And we also want a set of utilities that will make our life easier when handling EVM-specific data (ABI encoding/decoding, big numbers handling, etc.).\nThere are multiple such libraries. The two most popular ones are: web3.js and ethers.js. Picking either of them is a matter of personal preference. To me, Ethers.js seems to have a cleaner contract interaction interface, so I\u0026rsquo;ll pick it.\nWorkflows #  Let\u0026rsquo;s now see how we can implement interaction scenarios using MetaMask + Ethers.js.\nConnecting to Local Node #  To send transactions and fetch blockchain data, MetaMask connects to an Ethereum node. To interact with our contracts, we need to connect to the local Anvil node. To do this, open MetaMask, click on the list of networks, click \u0026ldquo;Add Network\u0026rdquo;, and add a network with RPC URL http://localhost:8545. It\u0026rsquo;ll automatically detect the chain ID (31337 in the case of Anvil).\nAfter connecting to the local node, we need to import. In MetaMask, click on the list of addresses, click \u0026ldquo;Import Account\u0026rdquo;, and paste the private key of the address you picked before deploying the contracts. After that, go to the assets list and import the addresses of the two tokens. Now you should see the token balances in MetaMask.\n MetaMask is still somewhat bugged. One problem I struggled with is that it caches blockchain state when connected to localhost. Because of this, when restarting the node, you might see old token balances and state. To fix this, go to the advanced settings and click \u0026ldquo;Reset Account\u0026rdquo;. You\u0026rsquo;ll need to do this each time after restarting the node.\n Connecting to MetaMask #  Not every website is allowed to get access to your address in MetaMask. A website first needs to connect to MetaMask. When a new website is connecting to MetaMask, you\u0026rsquo;ll see a window that asks for permissions.\nHere\u0026rsquo;s how to connect to MetaMask from a front-end app:\n// ui/src/contexts/MetaMask.js const connect = () =\u0026gt; {  if (typeof (window.ethereum) === \u0026#39;undefined\u0026#39;) {  return setStatus(\u0026#39;not_installed\u0026#39;);  }   Promise.all([  window.ethereum.request({ method: \u0026#39;eth_requestAccounts\u0026#39; }),  window.ethereum.request({ method: \u0026#39;eth_chainId\u0026#39; }),  ]).then(function ([accounts, chainId]) {  setAccount(accounts[0]);  setChain(chainId);  setStatus(\u0026#39;connected\u0026#39;);  })  .catch(function (error) {  console.error(error)  }); } window.ethereum is an object provided by MetaMask, it\u0026rsquo;s the interface to communicate with MetaMask. If it\u0026rsquo;s undefined, MetaMask is not installed. If it\u0026rsquo;s defined, we can send two requests to MetaMask: eth_requestAccounts and eth_chainId. It\u0026rsquo;s the first one that \u0026ldquo;connects\u0026rdquo; to MetaMask. It basically asks for access to get user\u0026rsquo;s addresses. The user will be able to choose which addresses to give access to. eth_chainId will ask for the chain ID of the node MetaMask is connected to. After obtaining an address and chain ID, it\u0026rsquo;s a good practice to display them in the interface:\n[TODO: MetaMask connected]\nProviding Liquidity #  To provide liquidity into the pool, we need to build a form that asks the user to type the amounts they want to deposit. After clicking \u0026ldquo;Submit\u0026rdquo;, the app will build a transaction that calls mint in the pool contract and provides the amounts chosen by users. Let\u0026rsquo;s see how to do this.\nEther.js provides Contract interface to interact with contracts. It makes our life much easier, since it takes on the job of encoding function parameters, creating a valid transaction, and handing it over to MetaMask. For us, calling contracts looks like calling asynchronous methods on a JS object.\nLet\u0026rsquo;s see how to create an instance of Contracts:\ntoken0 = new ethers.Contract(  props.config.token0Address,  props.config.ABIs.ERC20,  new ethers.providers.Web3Provider(window.ethereum).getSigner() ); A Contract instance is an address and the ABI of the contract deployed at this address. The ABI is needed to interact with the contract. The third parameter is the signer interface provided by MetaMask–it\u0026rsquo;s used by the JS contract instance to sign transactions via MetaMask.\nNow, let\u0026rsquo;s add a function for adding liquidity to the pool:\nconst addLiquidity = (account, { token0, token1, manager }, { managerAddress, poolAddress }) =\u0026gt; {  const amount0 = ethers.utils.parseEther(\u0026#34;0.998976618347425280\u0026#34;);  const amount1 = ethers.utils.parseEther(\u0026#34;5000\u0026#34;); // 5000 USDC  const lowerTick = 84222;  const upperTick = 86129;  const liquidity = ethers.BigNumber.from(\u0026#34;1517882343751509868544\u0026#34;);  const extra = ethers.utils.defaultAbiCoder.encode(  [\u0026#34;address\u0026#34;, \u0026#34;address\u0026#34;, \u0026#34;address\u0026#34;],  [token0.address, token1.address, account]  );  ... The first thing to do is to prepare the parameters. We use the same values we calculated earlier.\nNext, we allow the manager contract to take our tokens. First, we check the current allowances:\nPromise.all(  [  token0.allowance(account, managerAddress),  token1.allowance(account, managerAddress)  ] ) Then, we check if either of them is enough to transfer a corresponding amount of tokens. If not, we\u0026rsquo;re sending an approve transaction, which asks the user to approve spending of a specific amount to the manager contract. After ensuring that the user has approved full amounts, we call manager.mint to add liquidity:\n.then(([allowance0, allowance1]) =\u0026gt; {  return Promise.resolve()  .then(() =\u0026gt; {  if (allowance0.lt(amount0)) {  return token0.approve(managerAddress, amount0).then(tx =\u0026gt; tx.wait())  }  })  .then(() =\u0026gt; {  if (allowance1.lt(amount1)) {  return token1.approve(managerAddress, amount1).then(tx =\u0026gt; tx.wait())  }  })  .then(() =\u0026gt; {  return manager.mint(poolAddress, lowerTick, upperTick, liquidity, extra)  .then(tx =\u0026gt; tx.wait())  })  .then(() =\u0026gt; {  alert(\u0026#39;Liquidity added!\u0026#39;);  }); })  lt is a method of BigNumber. Ethers.js uses BigNumber to represent uint256 type, for which JavaScript doesn\u0026rsquo;t have enough precision. This is another reason why we want a convenience library.\n This is pretty much similar to the test contract, besides checking current allowances.\ntoken0, token1, and manager in the above code are instances of Contract. approve and mint are contract functions, which were generated dynamically from the ABIs we provided when instantiated the contracts. When calling these methods, Ethers.js:\n encodes function parameters; builds a transaction; passes the transaction to MetaMask and asks to sign it; user sees a MetaMask window and presses \u0026ldquo;Confirm\u0026rdquo;; sends the transaction to the node MetaMask is connected to; returns a transaction object with full information about the sent transaction.  The transaction object also contains wait function, which we call to fail for a transaction to be mined–this allows us to wait for a transaction to be mined before sending another.\n Ethereum requires a strict order of transaction. Remember the nonce? It\u0026rsquo;s an account-wide index of transactions, sent by this account. Every new transaction increases this index, and Ethereum won\u0026rsquo;t mint a transaction until a previous transaction (one with a smaller nonce) was mined.\n Swapping Tokens #  To swap tokens, we use the same pattern: get parameters from the user, check allowance, call swap on the manager.\nconst swap = (amountIn, account, { tokenIn, manager, token0, token1 }, { managerAddress, poolAddress }) =\u0026gt; {  const amountInWei = ethers.utils.parseEther(amountIn);  const extra = ethers.utils.defaultAbiCoder.encode(  [\u0026#34;address\u0026#34;, \u0026#34;address\u0026#34;, \u0026#34;address\u0026#34;],  [token0.address, token1.address, account]  );   tokenIn.allowance(account, managerAddress)  .then((allowance) =\u0026gt; {  if (allowance.lt(amountInWei)) {  return tokenIn.approve(managerAddress, amountInWei).then(tx =\u0026gt; tx.wait())  }  })  .then(() =\u0026gt; {  return manager.swap(poolAddress, extra).then(tx =\u0026gt; tx.wait())  })  .then(() =\u0026gt; {  alert(\u0026#39;Swap succeeded!\u0026#39;);  }).catch((err) =\u0026gt; {  console.error(err);  alert(\u0026#39;Failed!\u0026#39;);  }); } The only new thing here is ethers.utils.parseEther() function, which use to convert user-friendly amount (42 USDC) to wei, the smallest unit in Ethereum.\nSubscribing to Changes #  For a decentralized application, it\u0026rsquo;s important to reflect the current blockchain state. For example, in the case of a decentralized exchange, it\u0026rsquo;s critical to properly calculate swap prices based on current pool reserves; outdated data can cause slippage and make a swap transaction fail.\nWhile developing the pool contract, we learned about events, which act as blockchain data indexes: whenever smart contract state is modified, it\u0026rsquo;s a good practice to emit an event since events are indexed for quick search. What we\u0026rsquo;re going to do now, is to subscribe to contract events to keep our front-end app updated. Let\u0026rsquo;s build an event feed.\nIf you checked the ABI file as I recommended to you earlier, you saw that it also contains description of events: event name and its fields. Well, Ether.js parses them and provides an interface to subscribe to new events. Let\u0026rsquo;s see how this works.\nTo subscribe to events, we\u0026rsquo;ll use on(EVENT_NAME, handler) function. The callback receives all the fields of the event\n the event itself as parameters:  const subscribeToEvents = (pool, callback) =\u0026gt; {  pool.on(\u0026#34;Mint\u0026#34;, (sender, owner, tickLower, tickUpper, amount, amount0, amount1, event) =\u0026gt; callback(event));  pool.on(\u0026#34;Swap\u0026#34;, (sender, recipient, amount0, amount1, sqrtPriceX96, liquidity, tick, event) =\u0026gt; callback(event)); } To filter and fetch previous events, we can use queryFilter:\nPromise.all([  pool.queryFilter(\u0026#34;Mint\u0026#34;, \u0026#34;earliest\u0026#34;, \u0026#34;latest\u0026#34;),  pool.queryFilter(\u0026#34;Swap\u0026#34;, \u0026#34;earliest\u0026#34;, \u0026#34;latest\u0026#34;), ]).then(([mints, swaps]) =\u0026gt; {  ... }); You probably noticed that some event fields are marked as indexed–such fields are indexed by Ethereum nodes, which lets search events by specific values in such fields. For example, the Swap event has sender and recipient fields indexed, so we can search by swap sender and recipient. And again, Ethere.js makes this easier:\nconst swapFilter = pool.filters.Swap(sender, recipient); const swaps = await pool.queryFilter(swapFilter, fromBlock, toBlock);  And that\u0026rsquo;s it! We\u0026rsquo;re done with milestone 1!\n🎉🍾🍾🍾🎉 "},{"id":25,"href":"/docs/milestone_3/user-interface/","title":"User Interface","section":"Milestone 3. Cross-tick Swaps","content":"  function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\\\(', right: '\\\\)', display: false }, { left: '\\\\[', right: '\\\\]', display: true } ], throwOnError: false }); }    \\[ \\]  User Interface #  We\u0026rsquo;re now ready to update the UI with the changes we made in this milestone. We\u0026rsquo;ll update two things:\n Add Liquidity dialog window. Slippage tolerance in swapping.  Add Liquidity Dialog #  This change will finally remove hard coded liquidity amounts from our code and will allow use to add liquidity at arbitrary ranges.\nThe dialog is a simple component with a couple of inputs. We can even re-use addLiquidity function from previous implementation. However, now we need to convert prices to tick indices in JavaScript: we want users to type in prices but the contracts expect ticks. To make our job easier, we\u0026rsquo;ll use the official Uniswap V3 SDK for that.\nTo convert price to $\\sqrt{P}$, we can use encodeSqrtRatioX96 function. The function takes two amounts as input and calculates a price by dividing one by the other. Since we expect prices for users, we can pass a price as the first argument and 1 as the second one:\nconst priceToSqrtP = (price) =\u0026gt; encodeSqrtRatioX96(price, 1); To convert price to tick index, we can use TickMath.getTickAtSqrtRatio function. This is the implementation of the Solidity TickMath library in JavaScript:\nconst priceToTick = (price) =\u0026gt; TickMath.getTickAtSqrtRatio(priceToSqrtP(price)); So we can now convert prices typed in by users to ticks:\nconst lowerTick = priceToTick(lowerPrice); const upperTick = priceToTick(upperPrice); Another thing we need to add here is slippage protection. For simplicity, I made it a hard coded value and set it to 0.5%. Here\u0026rsquo;s how to use slippage tolerance to calculate minimal amounts:\nconst slippage = 0.5; const amount0Desired = ethers.utils.parseEther(amount0); const amount1Desired = ethers.utils.parseEther(amount1); const amount0Min = amount0Desired.mul((100 - slippage) * 100).div(10000); const amount1Min = amount1Desired.mul((100 - slippage) * 100).div(10000); Slippage Tolerance in Swapping #  Even though we\u0026rsquo;re the only user of the application and thus will never have problems with slippage during development, let\u0026rsquo;s add an input to control slippage tolerance during swaps.\nWhen swapping, slippage protection is implemented via limiting price–a price we don\u0026rsquo;t to go above during a swap. This means that we need to know this price before sending a swap transaction. However, we don\u0026rsquo;t need to calculate it on the front end because Quoter contract does this for us:\nfunction quote(QuoteParams memory params)  public  returns (  uint256 amountOut,  uint160 sqrtPriceX96After,  int24 tickAfter  ) { ... } And we\u0026rsquo;re calling Quoter to calculate swap amounts.\nSo, to calculate limiting price we need to take sqrtPriceX96After and subtract slippage tolerance from it–this will be the price we don\u0026rsquo;t want to go below during a swap.\nconst limitPrice = priceAfter.mul((100 - parseFloat(slippage)) * 100).div(10000); And that\u0026rsquo;s it!\n"},{"id":26,"href":"/docs/milestone_2/user-interface/","title":"User Interface","section":"Milestone 2. Second Swap","content":"User Interface #  Let\u0026rsquo;s make our web app work more like a real DEX. We can now remove hardcoded swap amounts and let users type arbitrary amounts. Moreover, we can now let users swap in the both direction, so we also need a button to swap the token inputs. After updating, the swap form will look like:\n\u0026lt;form className=\u0026#34;SwapForm\u0026#34;\u0026gt;  \u0026lt;SwapInput  amount={zeroForOne ? amount0 : amount1}  disabled={!enabled || loading}  readOnly={false}  setAmount={setAmount_(zeroForOne ? setAmount0 : setAmount1, zeroForOne)}  token={zeroForOne ? pair[0] : pair[1]} /\u0026gt;  \u0026lt;ChangeDirectionButton zeroForOne={zeroForOne} setZeroForOne={setZeroForOne} disabled={!enabled || loading} /\u0026gt;  \u0026lt;SwapInput  amount={zeroForOne ? amount1 : amount0}  disabled={!enabled || loading}  readOnly={true}  token={zeroForOne ? pair[1] : pair[0]} /\u0026gt;  \u0026lt;button className=\u0026#39;swap\u0026#39; disabled={!enabled || loading} onClick={swap_}\u0026gt;Swap\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; Each input has an amount assigned to it depending on swap direction controlled by zeroForOne state variable. The lower input field is always read-only because its value is calculated by Quoter contract.\nsetAmount_ function does two things: it updates the value of the top input and calls Quoter contract to calculate the value of the lower input:\nconst updateAmountOut = debounce((amount) =\u0026gt; {  if (amount === 0 || amount === \u0026#34;0\u0026#34;) {  return;  }   setLoading(true);   quoter.callStatic  .quote({ pool: config.poolAddress, amountIn: ethers.utils.parseEther(amount), zeroForOne: zeroForOne })  .then(({ amountOut }) =\u0026gt; {  zeroForOne ? setAmount1(ethers.utils.formatEther(amountOut)) : setAmount0(ethers.utils.formatEther(amountOut));  setLoading(false);  })  .catch((err) =\u0026gt; {  zeroForOne ? setAmount1(0) : setAmount0(0);  setLoading(false);  console.error(err);  }) })  const setAmount_ = (setAmountFn) =\u0026gt; {  return (amount) =\u0026gt; {  amount = amount || 0;  setAmountFn(amount);  updateAmountOut(amount)  } } Notice the callStatic called on quoter–this is what we discussed in a previous chapter. We need to force ethers.js to make a static call. Since quote doesn\u0026rsquo;t have a pure or view restriction, ethers.js will try to call quote in a transaction.\nAnd that\u0026rsquo;s it! The UI now allows to specify arbitrary amounts and swap in either direction!\n"}]